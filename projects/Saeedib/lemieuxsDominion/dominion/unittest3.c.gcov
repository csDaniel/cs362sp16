        -:    0:Source:unittest3.c
        -:    0:Graph:unittest3.gcno
        -:    0:Data:unittest3.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include <string.h>
        -:    4:#include <stdio.h>
        -:    5:#include <assert.h>
        -:    6:#include "rngs.h"
        -:    7:#include <stdlib.h>
        -:    8:
        1:    9:int checkBuyCard(int numPlayers, int supply [], int seed, struct gameState * game) {
        -:   10:	int r, i;
        -:   11:	struct gameState testGame;
        1:   12:	int thisPlayer = whoseTurn(game);
        -:   13:
        1:   14:	game->numBuys = 1;
        -:   15:
        -:   16:
        1:   17:	game->deck[thisPlayer][0] = village;
        1:   18:	game->deck[thisPlayer][1] = copper;
        1:   19:	game->deck[thisPlayer][2] = minion;
        1:   20:	game->deck[thisPlayer][3] = silver;
        1:   21:	game->deck[thisPlayer][4] = village;
        -:   22:
        1:   23:	game->hand[thisPlayer][0] = silver;
        1:   24:	game->hand[thisPlayer][1] = copper;
        1:   25:	game->hand[thisPlayer][2] = copper;
        1:   26:	game->hand[thisPlayer][3] = gold;
        1:   27:	game->hand[thisPlayer][4] = village;
        -:   28:
        1:   29:	updateCoins(thisPlayer, game, 0);
        -:   30:
        -:   31:
        1:   32:	memcpy(&testGame, game, sizeof(struct gameState));
        -:   33:
        1:   34:	printf("\nTest 1: buying embargo\n");
        -:   35:
        1:   36:	r = buyCard(embargo, game);
        1:   37:	assert(r == 0);
        -:   38:
        1:   39:	printf("hand count = %d, expected = %d\n", game->handCount[thisPlayer], testGame.handCount[thisPlayer]);
        1:   40:	assert(game->handCount[thisPlayer] == testGame.handCount[thisPlayer]);
        -:   41:
        1:   42:	printf("deck count = %d, expected = %d\n", game->deckCount[thisPlayer], testGame.deckCount[thisPlayer]);
        1:   43:	assert(game->deckCount[thisPlayer] == testGame.deckCount[thisPlayer]);
        -:   44:
        1:   45:	printf("discard count = %d, expected = %d\n", game->discardCount[thisPlayer], testGame.discardCount[thisPlayer] + 1);
        1:   46:	assert(game->discardCount[thisPlayer] == testGame.discardCount[thisPlayer] + 1);
        -:   47:	
        -:   48:	// make sure card has been added to the player's discard pile
        1:   49:	assert(game->discard[thisPlayer][0] == embargo);
        -:   50:
        -:   51:	
        -:   52:
        -:   53:	// check that other players' state hasn't been modified
        -:   54:
        -:   55:	// start at 1 since the current player is 0.
        2:   56:	for (i = 1; i < game->numPlayers; ++i) {
        1:   57:		printf("\nChecking Player Number %d:\n", i);
        -:   58:
        1:   59:		printf("Checking handCount\n");
        1:   60:		printf("hand count = %d, expected = %d\n", game->handCount[i], testGame.handCount[i]);
        1:   61:		assert(game->handCount[i] == testGame.handCount[i]);
        -:   62:
        1:   63:		printf("Checking deckCount\n");
        1:   64:		printf("deck count = %d, expected = %d\n", game->deckCount[i], testGame.deckCount[i]);
        1:   65:		assert(game->deckCount[i] == testGame.deckCount[i]);
        -:   66:
        1:   67:		printf("Checking discardCount\n");
        1:   68:		printf("discard count = %d, expected = %d\n", game->discardCount[i], testGame.discardCount[i]);
        1:   69:		assert(game->discardCount[i] == testGame.discardCount[i]);
        -:   70:	}
        -:   71:
        -:   72:	// check that the victory and kingdom card piles are ok
       28:   73:	for (i = 0; i <= treasure_map; ++i){
       27:   74:		if (i == embargo) {
        1:   75:			printf("Supply count for embargo = %d, expected = %d\n", game->supplyCount[i], testGame.supplyCount[i] - 1);
        1:   76:			assert(game->supplyCount[i] == testGame.supplyCount[i] - 1);
        -:   77:		}
        -:   78:		else
       26:   79:			assert(game->supplyCount[i] == testGame.supplyCount[i]);
        -:   80:	}
        -:   81:
        -:   82:
        -:   83:	// test on mine
        -:   84:
        1:   85:	printf("\nTest 2: buying mine\n");
        -:   86:
        -:   87:
        1:   88:	game->numBuys = 1;
        -:   89:
        1:   90:	game->deck[thisPlayer][0] = village;
        1:   91:	game->deck[thisPlayer][1] = copper;
        1:   92:	game->deck[thisPlayer][2] = minion;
        1:   93:	game->deck[thisPlayer][3] = silver;
        1:   94:	game->deck[thisPlayer][4] = village;
        -:   95:
        1:   96:	game->hand[thisPlayer][0] = silver;
        1:   97:	game->hand[thisPlayer][1] = village;
        1:   98:	game->hand[thisPlayer][2] = adventurer;
        1:   99:	game->hand[thisPlayer][3] = gold;
        1:  100:	game->hand[thisPlayer][4] = village;
        -:  101:
        1:  102:	updateCoins(thisPlayer, game, 0);
        -:  103:
        1:  104:	memcpy(&testGame, game, sizeof(struct gameState));
        -:  105:
        1:  106:	r = buyCard(mine, game);
        1:  107:	assert(r == 0);
        -:  108:
        1:  109:	printf("hand count = %d, expected = %d\n", game->handCount[thisPlayer], testGame.handCount[thisPlayer]);
        1:  110:	assert(game->handCount[thisPlayer] == testGame.handCount[thisPlayer]);
        -:  111:
        1:  112:	printf("deck count = %d, expected = %d\n", game->deckCount[thisPlayer], testGame.deckCount[thisPlayer]);
        1:  113:	assert(game->deckCount[thisPlayer] == testGame.deckCount[thisPlayer]);
        -:  114:
        1:  115:	printf("discard count = %d, expected = %d\n", game->discardCount[thisPlayer], testGame.discardCount[thisPlayer] + 1);
        1:  116:	assert(game->discardCount[thisPlayer] == testGame.discardCount[thisPlayer] + 1);
        -:  117:
        -:  118:	// make sure card has been added to the player's discard pile
        1:  119:	assert(game->discard[thisPlayer][1] == mine);
        -:  120:
        -:  121:
        -:  122:
        -:  123:	// check that other players' state hasn't been modified
        -:  124:
        -:  125:	// start at 1 since the current player is 0.
        2:  126:	for (i = 1; i < game->numPlayers; ++i) {
        1:  127:		printf("\nChecking Player Number %d:\n", i);
        -:  128:
        1:  129:		printf("Checking handCount\n");
        1:  130:		printf("hand count = %d, expected = %d\n", game->handCount[i], testGame.handCount[i]);
        1:  131:		assert(game->handCount[i] == testGame.handCount[i]);
        -:  132:
        1:  133:		printf("Checking deckCount\n");
        1:  134:		printf("deck count = %d, expected = %d\n", game->deckCount[i], testGame.deckCount[i]);
        1:  135:		assert(game->deckCount[i] == testGame.deckCount[i]);
        -:  136:
        1:  137:		printf("Checking discardCount\n");
        1:  138:		printf("discard count = %d, expected = %d\n", game->discardCount[i], testGame.discardCount[i]);
        1:  139:		assert(game->discardCount[i] == testGame.discardCount[i]);
        -:  140:	}
        -:  141:
        -:  142:	// check that the victory and kingdom card piles are ok
       28:  143:	for (i = 0; i <= treasure_map; ++i){
       27:  144:		if (i == mine) {
        1:  145:			printf("Supply count for mine = %d, expected = %d\n", game->supplyCount[i], testGame.supplyCount[i] - 1);
        1:  146:			assert(game->supplyCount[i] == testGame.supplyCount[i] - 1);
        -:  147:		}
        -:  148:		else
       26:  149:			assert(game->supplyCount[i] == testGame.supplyCount[i]);
        -:  150:	}
        -:  151:
        -:  152:
        1:  153:	printf("\nTest 3: attempting to buy adventurer\n");
        -:  154:
        -:  155:	// test on adventurer (too expensive)
        -:  156:
        1:  157:	game->numBuys = 1;
        -:  158:
        1:  159:	game->deck[thisPlayer][0] = village;
        1:  160:	game->deck[thisPlayer][1] = copper;
        1:  161:	game->deck[thisPlayer][2] = minion;
        1:  162:	game->deck[thisPlayer][3] = silver;
        1:  163:	game->deck[thisPlayer][4] = village;
        -:  164:
        1:  165:	game->hand[thisPlayer][0] = village;
        1:  166:	game->hand[thisPlayer][1] = village;
        1:  167:	game->hand[thisPlayer][2] = adventurer;
        1:  168:	game->hand[thisPlayer][3] = village;
        1:  169:	game->hand[thisPlayer][4] = village;
        -:  170:
        1:  171:	updateCoins(thisPlayer, game, 0);
        -:  172:
        1:  173:	memcpy(&testGame, game, sizeof(struct gameState));
        -:  174:
        1:  175:	r = buyCard(adventurer, game);
        1:  176:	assert(r != 0);
        -:  177:
        1:  178:	printf("hand count = %d, expected = %d\n", game->handCount[thisPlayer], testGame.handCount[thisPlayer]);
        1:  179:	assert(game->handCount[thisPlayer] == testGame.handCount[thisPlayer]);
        -:  180:
        1:  181:	printf("deck count = %d, expected = %d\n", game->deckCount[thisPlayer], testGame.deckCount[thisPlayer]);
        1:  182:	assert(game->deckCount[thisPlayer] == testGame.deckCount[thisPlayer]);
        -:  183:
        1:  184:	printf("discard count = %d, expected = %d\n", game->discardCount[thisPlayer], testGame.discardCount[thisPlayer]);
        1:  185:	assert(game->discardCount[thisPlayer] == testGame.discardCount[thisPlayer]);
        -:  186:
        -:  187:	// make sure card has been added to the player's discard pile
        -:  188:	//assert(game->discard[thisPlayer][0] == mine);
        -:  189:
        -:  190:
        -:  191:
        -:  192:	// check that other players' state hasn't been modified
        -:  193:
        -:  194:	// start at 1 since the current player is 0.
        2:  195:	for (i = 1; i < game->numPlayers; ++i) {
        1:  196:		printf("\nChecking Player Number %d:\n", i);
        -:  197:
        1:  198:		printf("Checking handCount\n");
        1:  199:		printf("hand count = %d, expected = %d\n", game->handCount[i], testGame.handCount[i]);
        1:  200:		assert(game->handCount[i] == testGame.handCount[i]);
        -:  201:
        1:  202:		printf("Checking deckCount\n");
        1:  203:		printf("deck count = %d, expected = %d\n", game->deckCount[i], testGame.deckCount[i]);
        1:  204:		assert(game->deckCount[i] == testGame.deckCount[i]);
        -:  205:
        1:  206:		printf("Checking discardCount\n");
        1:  207:		printf("discard count = %d, expected = %d\n", game->discardCount[i], testGame.discardCount[i]);
        1:  208:		assert(game->discardCount[i] == testGame.discardCount[i]);
        -:  209:	}
        -:  210:
        -:  211:	// check that the victory and kingdom card piles are ok
       28:  212:	for (i = 0; i <= treasure_map; ++i){
       27:  213:			assert(game->supplyCount[i] == testGame.supplyCount[i]);
        -:  214:	}
        -:  215:
        -:  216:
        -:  217:	// test with numBuys = 0
        -:  218:
        1:  219:	printf("\nTest 4: attempting to buy embargo while numBuys = 0\n");
        -:  220:
        -:  221:
        1:  222:	game->numBuys = 0;
        -:  223:
        -:  224:
        1:  225:	game->deck[thisPlayer][0] = village;
        1:  226:	game->deck[thisPlayer][1] = copper;
        1:  227:	game->deck[thisPlayer][2] = minion;
        1:  228:	game->deck[thisPlayer][3] = silver;
        1:  229:	game->deck[thisPlayer][4] = village;
        -:  230:
        1:  231:	game->hand[thisPlayer][0] = silver;
        1:  232:	game->hand[thisPlayer][1] = copper;
        1:  233:	game->hand[thisPlayer][2] = copper;
        1:  234:	game->hand[thisPlayer][3] = gold;
        1:  235:	game->hand[thisPlayer][4] = village;
        -:  236:
        1:  237:	updateCoins(thisPlayer, game, 0);
        -:  238:
        -:  239:
        1:  240:	memcpy(&testGame, game, sizeof(struct gameState));
        -:  241:
        1:  242:	r = buyCard(embargo, game);
        1:  243:	assert(r != 0);
        -:  244:
        1:  245:	printf("hand count = %d, expected = %d\n", game->handCount[thisPlayer], testGame.handCount[thisPlayer]);
        1:  246:	assert(game->handCount[thisPlayer] == testGame.handCount[thisPlayer]);
        -:  247:
        1:  248:	printf("deck count = %d, expected = %d\n", game->deckCount[thisPlayer], testGame.deckCount[thisPlayer]);
        1:  249:	assert(game->deckCount[thisPlayer] == testGame.deckCount[thisPlayer]);
        -:  250:
        1:  251:	printf("discard count = %d, expected = %d\n", game->discardCount[thisPlayer], testGame.discardCount[thisPlayer]);
        1:  252:	assert(game->discardCount[thisPlayer] == testGame.discardCount[thisPlayer]);
        -:  253:
        -:  254:
        -:  255:
        -:  256:
        -:  257:	// check that other players' state hasn't been modified
        -:  258:
        -:  259:	// start at 1 since the current player is 0.
        2:  260:	for (i = 1; i < game->numPlayers; ++i) {
        1:  261:		printf("\nChecking Player Number %d:\n", i);
        -:  262:
        1:  263:		printf("Checking handCount\n");
        1:  264:		printf("hand count = %d, expected = %d\n", game->handCount[i], testGame.handCount[i]);
        1:  265:		assert(game->handCount[i] == testGame.handCount[i]);
        -:  266:
        1:  267:		printf("Checking deckCount\n");
        1:  268:		printf("deck count = %d, expected = %d\n", game->deckCount[i], testGame.deckCount[i]);
        1:  269:		assert(game->deckCount[i] == testGame.deckCount[i]);
        -:  270:
        1:  271:		printf("Checking discardCount\n");
        1:  272:		printf("discard count = %d, expected = %d\n", game->discardCount[i], testGame.discardCount[i]);
        1:  273:		assert(game->discardCount[i] == testGame.discardCount[i]);
        -:  274:	}
        -:  275:
        -:  276:	// check that the victory and kingdom card piles are ok
       28:  277:	for (i = 0; i <= treasure_map; ++i){
       27:  278:			assert(game->supplyCount[i] == testGame.supplyCount[i]);
        -:  279:	}
        -:  280:
        -:  281:	// test with a card that his out of supply
        -:  282:
        1:  283:	printf("\nTest 5: attempting to buy a card that is out of supply\n");
        -:  284:
        -:  285:
        1:  286:	game->numBuys = 1;
        -:  287:
        -:  288:
        1:  289:	game->deck[thisPlayer][0] = village;
        1:  290:	game->deck[thisPlayer][1] = copper;
        1:  291:	game->deck[thisPlayer][2] = minion;
        1:  292:	game->deck[thisPlayer][3] = silver;
        1:  293:	game->deck[thisPlayer][4] = village;
        -:  294:
        1:  295:	game->hand[thisPlayer][0] = silver;
        1:  296:	game->hand[thisPlayer][1] = copper;
        1:  297:	game->hand[thisPlayer][2] = copper;
        1:  298:	game->hand[thisPlayer][3] = gold;
        1:  299:	game->hand[thisPlayer][4] = village;
        -:  300:
        1:  301:	game->supplyCount[embargo] = 0;
        -:  302:
        1:  303:	updateCoins(thisPlayer, game, 0);
        -:  304:
        -:  305:
        1:  306:	memcpy(&testGame, game, sizeof(struct gameState));
        -:  307:
        1:  308:	r = buyCard(embargo, game);
        1:  309:	assert(r != 0);
        -:  310:
        1:  311:	printf("hand count = %d, expected = %d\n", game->handCount[thisPlayer], testGame.handCount[thisPlayer]);
        1:  312:	assert(game->handCount[thisPlayer] == testGame.handCount[thisPlayer]);
        -:  313:
        1:  314:	printf("deck count = %d, expected = %d\n", game->deckCount[thisPlayer], testGame.deckCount[thisPlayer]);
        1:  315:	assert(game->deckCount[thisPlayer] == testGame.deckCount[thisPlayer]);
        -:  316:
        1:  317:	printf("discard count = %d, expected = %d\n", game->discardCount[thisPlayer], testGame.discardCount[thisPlayer]);
        1:  318:	assert(game->discardCount[thisPlayer] == testGame.discardCount[thisPlayer]);
        -:  319:
        -:  320:
        -:  321:
        -:  322:
        -:  323:	// check that other players' state hasn't been modified
        1:  324:	printf("\nTesting other players' state:\n");
        -:  325:	// start at 1 since the current player is 0.
        2:  326:	for (i = 1; i < game->numPlayers; ++i) {
        1:  327:		printf("\nChecking Player Number %d:\n", i);
        -:  328:
        1:  329:		printf("Checking handCount\n");
        1:  330:		printf("hand count = %d, expected = %d\n", game->handCount[i], testGame.handCount[i]);
        1:  331:		assert(game->handCount[i] == testGame.handCount[i]);
        -:  332:
        1:  333:		printf("Checking deckCount\n");
        1:  334:		printf("deck count = %d, expected = %d\n", game->deckCount[i], testGame.deckCount[i]);
        1:  335:		assert(game->deckCount[i] == testGame.deckCount[i]);
        -:  336:
        1:  337:		printf("Checking discardCount\n");
        1:  338:		printf("discard count = %d, expected = %d\n", game->discardCount[i], testGame.discardCount[i]);
        1:  339:		assert(game->discardCount[i] == testGame.discardCount[i]);
        -:  340:	}
        -:  341:
        1:  342:	printf("\nTesting victory and kingdom cards:\n");
        -:  343:	// check that the victory and kingdom card piles are ok
       28:  344:	for (i = 0; i <= treasure_map; ++i){
       27:  345:		assert(game->supplyCount[i] == testGame.supplyCount[i]);
        -:  346:	}
        -:  347:
        1:  348:	return 0;
        -:  349:}
        -:  350:
        -:  351:
        -:  352:
        1:  353:int main() {
        -:  354:	
        1:  355:	int k[10] = { adventurer, gardens, embargo, village, minion, mine, cutpurse,
        -:  356:		sea_hag, tribute, smithy };
        -:  357:
        -:  358:
        -:  359:	struct gameState G;
        -:  360:
        1:  361:	int seed = 1000;
        1:  362:	int numPlayers = 2;
        -:  363:
        -:  364:
        1:  365:	printf("Testing buyCard\n");
        -:  366:
        -:  367:
        1:  368:	initializeGame(numPlayers, k, seed, &G);
        -:  369:
        -:  370:
        1:  371:	checkBuyCard(numPlayers, k, seed, &G);
        -:  372:
        -:  373:
        -:  374:
        1:  375:	return 0;
        -:  376:}
