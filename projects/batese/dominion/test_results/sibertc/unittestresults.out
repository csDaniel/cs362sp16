%-------------------------------------UNITTEST1-------------------------------------%
TESTING discardCard():
Testing player 0 with handCount 1, discarding card from handPos 0 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 4, expected = 4.
PASSED: Hand Count = 0, expected 0.
Testing player 0 with handCount 2, discarding card from handPos 0 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 4, expected = 4.
PASSED: Hand Count = 1, expected 1.
PASSED: Card switched with = 5, expected = 5.
Testing player 0 with handCount 2, discarding card from handPos 1 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 5, expected = 5.
PASSED: Hand Count = 1, expected 1.
Testing player 0 with handCount 3, discarding card from handPos 0 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 4, expected = 4.
PASSED: Hand Count = 2, expected 2.
PASSED: Card switched with = 6, expected = 6.
Testing player 0 with handCount 3, discarding card from handPos 1 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 5, expected = 5.
PASSED: Hand Count = 2, expected 2.
PASSED: Card switched with = 6, expected = 6.
Testing player 0 with handCount 3, discarding card from handPos 2 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 6, expected = 6.
PASSED: Hand Count = 2, expected 2.
Testing player 0 with handCount 4, discarding card from handPos 0 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 4, expected = 4.
PASSED: Hand Count = 3, expected 3.
PASSED: Card switched with = 7, expected = 7.
Testing player 0 with handCount 4, discarding card from handPos 1 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 5, expected = 5.
PASSED: Hand Count = 3, expected 3.
PASSED: Card switched with = 7, expected = 7.
Testing player 0 with handCount 4, discarding card from handPos 2 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 6, expected = 6.
PASSED: Hand Count = 3, expected 3.
PASSED: Card switched with = 7, expected = 7.
Testing player 0 with handCount 4, discarding card from handPos 3 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 7, expected = 7.
PASSED: Hand Count = 3, expected 3.
Testing player 0 with handCount 5, discarding card from handPos 0 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 4, expected = 4.
PASSED: Hand Count = 4, expected 4.
PASSED: Card switched with = 13, expected = 13.
Testing player 0 with handCount 5, discarding card from handPos 1 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 5, expected = 5.
PASSED: Hand Count = 4, expected 4.
PASSED: Card switched with = 13, expected = 13.
Testing player 0 with handCount 5, discarding card from handPos 2 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 6, expected = 6.
PASSED: Hand Count = 4, expected 4.
PASSED: Card switched with = 13, expected = 13.
Testing player 0 with handCount 5, discarding card from handPos 3 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 7, expected = 7.
PASSED: Hand Count = 4, expected 4.
PASSED: Card switched with = 13, expected = 13.
Testing player 0 with handCount 5, discarding card from handPos 4 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 13, expected = 13.
PASSED: Hand Count = 4, expected 4.
Testing player 1 with handCount 1, discarding card from handPos 0 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 4, expected = 4.
PASSED: Hand Count = 0, expected 0.
Testing player 1 with handCount 2, discarding card from handPos 0 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 4, expected = 4.
PASSED: Hand Count = 1, expected 1.
PASSED: Card switched with = 5, expected = 5.
Testing player 1 with handCount 2, discarding card from handPos 1 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 5, expected = 5.
PASSED: Hand Count = 1, expected 1.
Testing player 1 with handCount 3, discarding card from handPos 0 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 4, expected = 4.
PASSED: Hand Count = 2, expected 2.
PASSED: Card switched with = 6, expected = 6.
Testing player 1 with handCount 3, discarding card from handPos 1 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 5, expected = 5.
PASSED: Hand Count = 2, expected 2.
PASSED: Card switched with = 6, expected = 6.
Testing player 1 with handCount 3, discarding card from handPos 2 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 6, expected = 6.
PASSED: Hand Count = 2, expected 2.
Testing player 1 with handCount 4, discarding card from handPos 0 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 4, expected = 4.
PASSED: Hand Count = 3, expected 3.
PASSED: Card switched with = 7, expected = 7.
Testing player 1 with handCount 4, discarding card from handPos 1 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 5, expected = 5.
PASSED: Hand Count = 3, expected 3.
PASSED: Card switched with = 7, expected = 7.
Testing player 1 with handCount 4, discarding card from handPos 2 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 6, expected = 6.
PASSED: Hand Count = 3, expected 3.
PASSED: Card switched with = 7, expected = 7.
Testing player 1 with handCount 4, discarding card from handPos 3 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 7, expected = 7.
PASSED: Hand Count = 3, expected 3.
Testing player 1 with handCount 5, discarding card from handPos 0 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 4, expected = 4.
PASSED: Hand Count = 4, expected 4.
PASSED: Card switched with = 13, expected = 13.
Testing player 1 with handCount 5, discarding card from handPos 1 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 5, expected = 5.
PASSED: Hand Count = 4, expected 4.
PASSED: Card switched with = 13, expected = 13.
Testing player 1 with handCount 5, discarding card from handPos 2 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 6, expected = 6.
PASSED: Hand Count = 4, expected 4.
PASSED: Card switched with = 13, expected = 13.
Testing player 1 with handCount 5, discarding card from handPos 3 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 7, expected = 7.
PASSED: Hand Count = 4, expected 4.
PASSED: Card switched with = 13, expected = 13.
Testing player 1 with handCount 5, discarding card from handPos 4 without trash flag.
PASSED: Played card count = 1, expected 1.
PASSED: Top card in playedCards = 13, expected = 13.
PASSED: Hand Count = 4, expected 4.
File 'unittest1.c'
Lines executed:87.50% of 32
Creating 'unittest1.c.gcov'

File 'unittest1.c'
Lines executed:87.50% of 32
Branches executed:100.00% of 18
Taken at least once:72.22% of 18
Calls executed:66.67% of 12
Creating 'unittest1.c.gcov'

        -:    0:Source:unittest1.c
        -:    0:Graph:unittest1.gcno
        -:    0:Data:unittest1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:File: unittest1.c
        -:    3:Author: Elliot Bates
        -:    4:Description: Unit test for discard card function from dominion
        -:    5:*/
        -:    6:
        -:    7:/*
        -:    8:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -:    9:{
        -:   10:	
        -:   11:  //if card is not trashed, added to Played pile 
        -:   12:  if (trashFlag < 1)
        -:   13:    {
        -:   14:      //add card to played pile
        -:   15:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
        -:   16:      state->playedCardCount++;
        -:   17:    }
        -:   18:	
        -:   19:  //set played card to -1
        -:   20:  state->hand[currentPlayer][handPos] = -1;
        -:   21:	
        -:   22:  //remove card from player's hand
        -:   23:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -:   24:    {
        -:   25:      //reduce number of cards in hand
        -:   26:      state->handCount[currentPlayer]--;
        -:   27:    }
        -:   28:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -:   29:    {
        -:   30:      //reduce number of cards in hand
        -:   31:      state->handCount[currentPlayer]--;
        -:   32:    }
        -:   33:  else 	
        -:   34:    {
        -:   35:      //replace discarded card with last card in hand
        -:   36:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -:   37:      //set last card to -1
        -:   38:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -:   39:      //reduce number of cards in hand
        -:   40:      state->handCount[currentPlayer]--;
        -:   41:    }
        -:   42:	
        -:   43:  return 0;
        -:   44:}
        -:   45:*/
        -:   46:
        -:   47:#include "dominion.h"
        -:   48:#include "dominion_helpers.h"
        -:   49:#include <string.h>
        -:   50:#include <stdio.h>
        -:   51:#include <assert.h>
        -:   52:#include "rngs.h"
        -:   53:
        -:   54:
        -:   55:
function main called 1 returned 100% blocks executed 86%
        1:   56:int main() {
        -:   57:	int i;
        1:   58:    int seed = 1000;
        1:   59:    int numPlayer = 2;
        -:   60:    int p, r, handCount, handPos;
        1:   61:    int k[10] = {adventurer, council_room, feast, gardens, mine
        -:   62:               , remodel, smithy, village, baron, great_hall};
        -:   63:    struct gameState G;
        1:   64:    int maxHandCount = 5;
        1:   65:	int testHand1[] = {copper, silver, gold, adventurer, smithy};
        -:   66:	int prePlayedCount, postPlayedCount;
        -:   67:	
        1:   68:	printf ("TESTING discardCard():\n");
call    0 returned 100%
        3:   69:    for (p = 0; p < numPlayer; p++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
       12:   70:		for (handCount = 1; handCount <= maxHandCount; handCount++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
       40:   71:			for (handPos = 0; handPos < handCount; handPos++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:   72:				// perform tests with no trash flag
       30:   73:				printf("Testing player %d with handCount %d, discarding card from handPos %d without trash flag.\n", p, handCount, handPos);
call    0 returned 100%
       30:   74:                memset(&G, 23, sizeof(struct gameState));   // clear the game state
       30:   75:                r = initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
       30:   76:                G.handCount[p] = handCount;                 // set the number of cards on hand
       30:   77:                memcpy(G.hand[p], testHand1, sizeof(int) * handCount); // copy across some random cards from the test hand
       30:   78:				prePlayedCount = G.playedCardCount;
       30:   79:				discardCard(handPos, p, &G, 0); //Call discard card without trash flag
call    0 returned 100%
       30:   80:				postPlayedCount = G.playedCardCount;
       30:   81:				if (postPlayedCount == (prePlayedCount + 1)) //check played cards has increased by 1
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       30:   82:					printf("PASSED: Played card count = %d, expected %d.\n", postPlayedCount, (prePlayedCount + 1));
call    0 returned 100%
        -:   83:				else
    #####:   84:					printf("FAILED: Played card count = %d, expected %d.\n", postPlayedCount, (prePlayedCount + 1));
call    0 never executed
       30:   85:				if (G.playedCards[G.playedCardCount-1] == testHand1[handPos]) // check correct card was added to played cards
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       30:   86:					printf("PASSED: Top card in playedCards = %d, expected = %d.\n", G.playedCards[G.playedCardCount-1], testHand1[handPos]); 
call    0 returned 100%
        -:   87:				else
    #####:   88:					printf("FAILED: Top card in playedCards = %d, expected = %d.\n", G.playedCards[G.playedCardCount-1], testHand1[handPos]);
call    0 never executed
       30:   89:				if (G.handCount[p] == (handCount - 1)) // Check handcount has recreases
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       30:   90:					printf("PASSED: Hand Count = %d, expected %d.\n", G.handCount[p], (handCount - 1));
call    0 returned 100%
        -:   91:				else
    #####:   92:					printf("FAILED: Hand Count = %d, expected %d.\n", G.handCount[p], (handCount - 1));
call    0 never executed
       30:   93:				if ((handPos != (handCount - 1)) && (handCount != 1)) { // ie is not the last card in the hand
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
       20:   94:					if (G.hand[p][handPos] == testHand1[handCount - 1])
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       20:   95:						printf("PASSED: Card switched with = %d, expected = %d.\n", G.hand[p][handPos], testHand1[handCount - 1]); //Check that the card was switched with the expected card
call    0 returned 100%
        -:   96:					else
    #####:   97:						printf("FAILED: Card switched with = %d, expected = %d.\n", G.hand[p][handPos], testHand1[handCount - 1]); //Check that the card was switched with the expected card
call    0 never executed
        -:   98:				}		
        -:   99:
        -:  100:			}
        -:  101:		}
        -:  102:	}
        1:  103:	return 0;
        -:  104:}
%-------------------------------------UNITTEST2-------------------------------------%
TESTING getWinners():
PASSED: Player1 score = 1, expected = 1  Player2 score = 0, expected = 0.
FAILED: Player1 score = 1, expected = 0  Player2 score = 0, expected = 1.
FAILED: Player1 score = 1, expected = 0  Player2 score = 0, expected = 1.
FAILED: Player1 score = 1, expected = 1  Player2 score = 0, expected = 1.
File 'unittest2.c'
Lines executed:89.47% of 38
Creating 'unittest2.c.gcov'

File 'unittest2.c'
Lines executed:89.47% of 38
Branches executed:75.00% of 16
Taken at least once:37.50% of 16
Calls executed:76.47% of 17
Creating 'unittest2.c.gcov'

        -:    0:Source:unittest2.c
        -:    0:Graph:unittest2.gcno
        -:    0:Data:unittest2.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:File: unittest2.c
        -:    3:Author: Elliot Bates
        -:    4:Description: Unit test for get winners function from dominion
        -:    5:*/
        -:    6:
        -:    7:/*
        -:    8:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:    9:  int i;	
        -:   10:  int j;
        -:   11:  int highScore;
        -:   12:  int currentPlayer;
        -:   13:
        -:   14:  //get score for each player
        -:   15:  for (i = 0; i < MAX_PLAYERS; i++)
        -:   16:    {
        -:   17:      //set unused player scores to -9999
        -:   18:      if (i >= state->numPlayers)
        -:   19:	{
        -:   20:	  players[i] = -9999;
        -:   21:	}
        -:   22:      else
        -:   23:	{
        -:   24:	  players[i] = scoreFor (i, state);
        -:   25:	}
        -:   26:    }
        -:   27:
        -:   28:  //find highest score
        -:   29:  j = 0;
        -:   30:  for (i = 0; i < MAX_PLAYERS; i++)
        -:   31:    {
        -:   32:      if (players[i] > players[j])
        -:   33:	{
        -:   34:	  j = i;
        -:   35:	}
        -:   36:    }
        -:   37:  highScore = players[j];
        -:   38:
        -:   39:  //add 1 to players who had less turns
        -:   40:  currentPlayer = whoseTurn(state);
        -:   41:  for (i = 0; i < MAX_PLAYERS; i++)
        -:   42:    {
        -:   43:      if ( players[i] == highScore && i > currentPlayer )
        -:   44:	{
        -:   45:	  players[i]++;
        -:   46:	}
        -:   47:    }
        -:   48:
        -:   49:  //find new highest score
        -:   50:  j = 0;
        -:   51:  for (i = 0; i < MAX_PLAYERS; i++)
        -:   52:    {
        -:   53:      if ( players[i] > players[j] )
        -:   54:	{
        -:   55:	  j = i;
        -:   56:	}
        -:   57:    }
        -:   58:  highScore = players[j];
        -:   59:
        -:   60:  //set winners in array to 1 and rest to 0
        -:   61:  for (i = 0; i < MAX_PLAYERS; i++)
        -:   62:    {
        -:   63:      if ( players[i] == highScore )
        -:   64:	{
        -:   65:	  players[i] = 1;
        -:   66:	}
        -:   67:      else
        -:   68:	{
        -:   69:	  players[i] = 0;
        -:   70:	}
        -:   71:    }
        -:   72:
        -:   73:  return 0;
        -:   74:}
        -:   75:*/
        -:   76:
        -:   77:#include "dominion.h"
        -:   78:#include "dominion_helpers.h"
        -:   79:#include <string.h>
        -:   80:#include <stdio.h>
        -:   81:#include <assert.h>
        -:   82:#include "rngs.h"
        -:   83:
        -:   84:
        -:   85:
function main called 1 returned 100% blocks executed 78%
        1:   86:int main() {
        -:   87:	int i;
        1:   88:    int seed = 1000;
        1:   89:    int numPlayer = 2;
        -:   90:    int p, r;
        1:   91:    int k[10] = {adventurer, council_room, feast, gardens, mine
        -:   92:               , remodel, smithy, village, baron, great_hall};
        -:   93:    struct gameState G;
        -:   94:	int x, y; // p1 and p2 scores respectively
        -:   95:	int players[MAX_PLAYERS];
        -:   96:
        1:   97:	printf ("TESTING getWinners():\n");	
call    0 returned 100%
        -:   98:
        -:   99:	//Player 1 higher score
        1:  100:	memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:  101:	r = initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
        1:  102:	G.whoseTurn = 0; // Set to player 1's turn
        -:  103:	// add province to player 1's deck
        1:  104:	G.hand[0][G.handCount[0]] = 4; //4 is code for province
        1:  105:	G.handCount[0]++;
        1:  106:	getWinners(players, &G);
call    0 returned 100%
        -:  107:	// Player 1 is winner
        1:  108:	if (players[0] == 1 && players[1] == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1:  109:		printf("PASSED: Player1 score = %d, expected = 1  Player2 score = %d, expected = 0.\n", players[0], players[1]);
call    0 returned 100%
        -:  110:	else
    #####:  111:		printf("FAILED: Player1 score = %d, expected = 1  Player2 score = %d, expected = 0.\n", players[0], players[1]);
call    0 never executed
        -:  112:
        -:  113:
        -:  114:	//Player 2 higher score
        1:  115:	memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:  116:	r = initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
        1:  117:	G.whoseTurn = 0; // Set to player 1's turn
        -:  118:	// add province to player 2's deck
        1:  119:	G.hand[1][G.handCount[1]] = 4; //4 is code for province
        1:  120:	G.handCount[1]++;
        1:  121:	getWinners(players, &G);
call    0 returned 100%
        1:  122:	if (players[0] == 0 && players[1] == 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:  123:		printf("PASSED: Player1 score = %d, expected = 0  Player2 score = %d, expected = 1.\n", players[0], players[1]);
call    0 never executed
        -:  124:	else
        1:  125:		printf("FAILED: Player1 score = %d, expected = 0  Player2 score = %d, expected = 1.\n", players[0], players[1]);
call    0 returned 100%
        -:  126:
        -:  127:	
        -:  128:	//Same score player 1's turn
        1:  129:	memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:  130:	r = initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
        1:  131:	G.whoseTurn = 0; // Set to player 1's turn
        1:  132:	getWinners(players, &G);
call    0 returned 100%
        1:  133:	if (players[0] == 0 && players[1] == 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:  134:		printf("PASSED: Player1 score = %d, expected = 0  Player2 score = %d, expected = 1.\n", players[0], players[1]);
call    0 never executed
        -:  135:	else
        1:  136:		printf("FAILED: Player1 score = %d, expected = 0  Player2 score = %d, expected = 1.\n", players[0], players[1]);	
call    0 returned 100%
        -:  137:	
        -:  138:	//Same score player 2's turn
        1:  139:	memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:  140:	r = initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
        1:  141:	G.whoseTurn = 1; // Set to player 1's turn
        1:  142:	getWinners(players, &G);
call    0 returned 100%
        1:  143:	if (players[0] == 1 && players[1] == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  144:		printf("PASSED: Player1 score = %d, expected = 1  Player2 score = %d, expected = 1.\n", players[0], players[1]);
call    0 never executed
        -:  145:	else
        1:  146:		printf("FAILED: Player1 score = %d, expected = 1  Player2 score = %d, expected = 1.\n", players[0], players[1]);
call    0 returned 100%
        -:  147:	
        1:  148:	return 0;
        -:  149:}
%-------------------------------------UNITTEST3-------------------------------------%
TESTING isGameOver():
Testing effect of function on supply counts.
PASSED: supplyCount[0] = 10, expected = 10.
PASSED: supplyCount[1] = 8, expected = 8.
PASSED: supplyCount[2] = 8, expected = 8.
PASSED: supplyCount[3] = 8, expected = 8.
PASSED: supplyCount[4] = 46, expected = 46.
PASSED: supplyCount[5] = 40, expected = 40.
PASSED: supplyCount[6] = 30, expected = 30.
PASSED: supplyCount[7] = 10, expected = 10.
PASSED: supplyCount[8] = 10, expected = 10.
PASSED: supplyCount[9] = 10, expected = 10.
PASSED: supplyCount[10] = 8, expected = 8.
PASSED: supplyCount[11] = 10, expected = 10.
PASSED: supplyCount[12] = 10, expected = 10.
PASSED: supplyCount[13] = 10, expected = 10.
PASSED: supplyCount[14] = 10, expected = 10.
PASSED: supplyCount[15] = 10, expected = 10.
PASSED: supplyCount[16] = 8, expected = 8.
PASSED: supplyCount[17] = -1, expected = -1.
PASSED: supplyCount[18] = -1, expected = -1.
PASSED: supplyCount[19] = -1, expected = -1.
PASSED: supplyCount[20] = -1, expected = -1.
PASSED: supplyCount[21] = -1, expected = -1.
PASSED: supplyCount[22] = -1, expected = -1.
PASSED: supplyCount[23] = -1, expected = -1.
PASSED: supplyCount[24] = -1, expected = -1.
Testing that no province cards causes end of game.
PASSED: isGameOver = 1, expected = 1.
Testing that 3 empty piles causes end of game.
PASSED: isGameOver = 1, expected = 1.
Testing that 2 empty piles does not cause end of game.
PASSED: isGameOver = 0, expected = 0.
File 'unittest3.c'
Lines executed:90.70% of 43
Creating 'unittest3.c.gcov'

File 'unittest3.c'
Lines executed:90.70% of 43
Branches executed:100.00% of 12
Taken at least once:66.67% of 12
Calls executed:80.95% of 21
Creating 'unittest3.c.gcov'

        -:    0:Source:unittest3.c
        -:    0:Graph:unittest3.gcno
        -:    0:Data:unittest3.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:File: unittest3.c
        -:    3:Author: Elliot Bates
        -:    4:Description: Unit test for is game over function from dominion
        -:    5:*/
        -:    6:
        -:    7:/*
        -:    8:int isGameOver(struct gameState *state) {
        -:    9:  int i;
        -:   10:  int j;
        -:   11:	
        -:   12:  //if stack of Province cards is empty, the game ends
        -:   13:  if (state->supplyCount[province] == 0)
        -:   14:    {
        -:   15:      return 1;
        -:   16:    }
        -:   17:
        -:   18:  //if three supply pile are at 0, the game ends
        -:   19:  j = 0;
        -:   20:  for (i = 0; i < 25; i++)
        -:   21:    {
        -:   22:      if (state->supplyCount[i] == 0)
        -:   23:	{
        -:   24:	  j++;
        -:   25:	}
        -:   26:    }
        -:   27:  if ( j >= 3)
        -:   28:    {
        -:   29:      return 1;
        -:   30:    }
        -:   31:
        -:   32:  return 0;
        -:   33:}
        -:   34:*/
        -:   35:
        -:   36:#include "dominion.h"
        -:   37:#include "dominion_helpers.h"
        -:   38:#include <string.h>
        -:   39:#include <stdio.h>
        -:   40:#include <assert.h>
        -:   41:#include "rngs.h"
        -:   42:
        -:   43:
        -:   44:
function main called 1 returned 100% blocks executed 88%
        1:   45:int main() {
        -:   46:	int i;
        1:   47:    int seed = 1000;
        1:   48:    int numPlayer = 2;
        -:   49:    int p, r;
        1:   50:    int k[10] = {adventurer, council_room, feast, gardens, mine
        -:   51:               , remodel, smithy, village, baron, great_hall};
        -:   52:    struct gameState G;
        -:   53:	int supplyCounts[25];
        -:   54:	int gameOver;
        -:   55:
        1:   56:	printf ("TESTING isGameOver():\n");
call    0 returned 100%
        -:   57:	
        -:   58:	// check function does not modify any supply counts
        1:   59:	printf("Testing effect of function on supply counts.\n");
call    0 returned 100%
        1:   60:	memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:   61:	r = initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
       26:   62:	for (i = 0; i < 25; i++) {
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
       25:   63:		supplyCounts[i] = G.supplyCount[i];
        -:   64:	}
        1:   65:	isGameOver(&G);
call    0 returned 100%
       26:   66:	for (i = 0; i < 25; i++) {
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
       25:   67:		if (supplyCounts[i] == G.supplyCount[i])
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       25:   68:			printf("PASSED: supplyCount[%d] = %d, expected = %d.\n", i, G.supplyCount[i], supplyCounts[i]);
call    0 returned 100%
        -:   69:		else
    #####:   70:			printf("FAILED: supplyCount[%d] = %d, expected = %d.\n", i, G.supplyCount[i], supplyCounts[i]);
call    0 never executed
        -:   71:	}
        -:   72:	
        -:   73:	// check no provice cards causes game to end
        1:   74:	printf("Testing that no province cards causes end of game.\n");
call    0 returned 100%
        1:   75:	memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:   76:	r = initializeGame(numPlayer, k, seed, &G); // initialize a new game	
call    0 returned 100%
        1:   77:	G.supplyCount[province] = 0;
        1:   78:	gameOver = isGameOver(&G);
call    0 returned 100%
        1:   79:	if (gameOver == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   80:		printf("PASSED: isGameOver = %d, expected = 1.\n", gameOver);
call    0 returned 100%
        -:   81:	else
    #####:   82:		printf("FAILED: isGameOver = %d, expected = 1.\n", gameOver);
call    0 never executed
        -:   83:	
        -:   84:	// check 3 empty piles causes game over
        1:   85:	printf("Testing that 3 empty piles causes end of game.\n");
call    0 returned 100%
        1:   86:	memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:   87:	r = initializeGame(numPlayer, k, seed, &G); // initialize a new game	
call    0 returned 100%
        1:   88:	G.supplyCount[copper] = 0;
        1:   89:	G.supplyCount[silver] = 0;
        1:   90:	G.supplyCount[smithy] = 0;
        1:   91:	gameOver = isGameOver(&G);
call    0 returned 100%
        1:   92:	if (gameOver == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   93:		printf("PASSED: isGameOver = %d, expected = 1.\n", gameOver);
call    0 returned 100%
        -:   94:	else
    #####:   95:		printf("FAILED: isGameOver = %d, expected = 1.\n", gameOver);
call    0 never executed
        -:   96:	
        -:   97:	// check 2 empty piles does not cause game over
        1:   98:	printf("Testing that 2 empty piles does not cause end of game.\n");
call    0 returned 100%
        1:   99:	memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:  100:	r = initializeGame(numPlayer, k, seed, &G); // initialize a new game	
call    0 returned 100%
        1:  101:	G.supplyCount[copper] = 0;
        1:  102:	G.supplyCount[smithy] = 0;
        1:  103:	gameOver = isGameOver(&G);
call    0 returned 100%
        1:  104:	if (gameOver == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  105:		printf("PASSED: isGameOver = %d, expected = 0.\n", gameOver);
call    0 returned 100%
        -:  106:	else
    #####:  107:		printf("FAILED: isGameOver = %d, expected = 0.\n", gameOver);
call    0 never executed
        1:  108:	return 0;
        -:  109:}
%-------------------------------------UNITTEST4-------------------------------------%
TESTING fullDeckCount():
Testing with player 0 and card 1.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 0 and card 2.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 0 and card 3.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 0 and card 4.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 0 and card 5.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 0 and card 6.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 0 and card 7.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 0 and card 8.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 0 and card 9.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 0 and card 10.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 0 and card 11.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 0 and card 12.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 0 and card 13.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 0 and card 14.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 0 and card 15.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 0 and card 16.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 0 and card 17.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 0 and card 18.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 0 and card 19.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 0 and card 20.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 0 and card 21.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 0 and card 22.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 0 and card 23.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 1 and card 1.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 1 and card 2.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 1 and card 3.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 1 and card 4.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 1 and card 5.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 1 and card 6.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 1 and card 7.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 1 and card 8.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 1 and card 9.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 1 and card 10.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 1 and card 11.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 1 and card 12.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 1 and card 13.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 1 and card 14.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 1 and card 15.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 1 and card 16.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 1 and card 17.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 1 and card 18.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 1 and card 19.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 1 and card 20.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 1 and card 21.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 1 and card 22.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
Testing with player 1 and card 23.
Testing with 1 card in each location.
PASSED: fullDeckCount = 3, expected = 3.
Testing with 1 card in both deck and discard.
PASSED: fullDeckCount = 2, expected = 2.
Testing with 1 card in just hand.
PASSED: fullDeckCount = 1, expected = 1.
File 'unittest4.c'
Lines executed:93.33% of 45
Creating 'unittest4.c.gcov'

File 'unittest4.c'
Lines executed:93.33% of 45
Branches executed:100.00% of 10
Taken at least once:70.00% of 10
Calls executed:82.35% of 17
Creating 'unittest4.c.gcov'

        -:    0:Source:unittest4.c
        -:    0:Graph:unittest4.gcno
        -:    0:Data:unittest4.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:File: unittest1.c
        -:    3:Author: Elliot Bates
        -:    4:Description: Unit test for full deck count function from dominion
        -:    5:*/
        -:    6:
        -:    7:/*
        -:    8:int fullDeckCount(int player, int card, struct gameState *state) {
        -:    9:  int i;
        -:   10:  int count = 0;
        -:   11:
        -:   12:  for (i = 0; i < state->deckCount[player]; i++)
        -:   13:    {
        -:   14:      if (state->deck[player][i] == card) count++;
        -:   15:    }
        -:   16:
        -:   17:  for (i = 0; i < state->handCount[player]; i++)
        -:   18:    {
        -:   19:      if (state->hand[player][i] == card) count++;
        -:   20:    }
        -:   21:
        -:   22:  for (i = 0; i < state->discardCount[player]; i++)
        -:   23:    {
        -:   24:      if (state->discard[player][i] == card) count++;
        -:   25:    }
        -:   26:
        -:   27:  return count;
        -:   28:}
        -:   29:*/
        -:   30:
        -:   31:#include "dominion.h"
        -:   32:#include "dominion_helpers.h"
        -:   33:#include <string.h>
        -:   34:#include <stdio.h>
        -:   35:#include <assert.h>
        -:   36:#include "rngs.h"
        -:   37:
function main called 1 returned 100% blocks executed 89%
        1:   38:int main() {
        -:   39:	int i;
        1:   40:    int seed = 1000;
        1:   41:    int numPlayer = 2;
        -:   42:    int p, r;
        1:   43:    int k[10] = {adventurer, council_room, feast, gardens, mine
        -:   44:               , remodel, smithy, village, baron, great_hall};
        -:   45:    struct gameState G;
        -:   46:	int supplyCounts[25];
        -:   47:	int gameOver;
        -:   48:	int card, deckCount;
        -:   49:
        1:   50:	printf ("TESTING fullDeckCount():\n");
call    0 returned 100%
        -:   51:	
        3:   52:	for (p = 0; p < numPlayer; p++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
       48:   53:		for (card = 1; card < 24; card++) {
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
       46:   54:			printf("Testing with player %d and card %d.\n", p, card);
call    0 returned 100%
        -:   55:			// Check with 1 cards in each place
       46:   56:			printf("Testing with 1 card in each location.\n");
call    0 returned 100%
       46:   57:			memset(&G, 23, sizeof(struct gameState));   // clear the game state
       46:   58:			r = initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
       46:   59:			G.deck[p][0] = card;
       46:   60:			G.deckCount[p] = 1;
       46:   61:			G.hand[p][0] = card;
       46:   62:			G.handCount[p] = 1;
       46:   63:			G.discard[p][0] = card;
       46:   64:			G.discardCount[p] = 1;
       46:   65:			deckCount = fullDeckCount(p, card, &G);
call    0 returned 100%
       46:   66:			if (deckCount == 3)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       46:   67:				printf("PASSED: fullDeckCount = %d, expected = 3.\n", deckCount);
call    0 returned 100%
        -:   68:			else
    #####:   69:				printf("FAILED: fullDeckCount = %d, expected = 3.\n", deckCount);
call    0 never executed
        -:   70:			
        -:   71:			// Check with 1 cards in 2 places
       46:   72:			printf("Testing with 1 card in both deck and discard.\n");
call    0 returned 100%
       46:   73:			memset(&G, 23, sizeof(struct gameState));   // clear the game state
       46:   74:			r = initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
       46:   75:			G.deck[p][0] = card;
       46:   76:			G.deckCount[p] = 1;
       46:   77:			G.handCount[p] = 0;
       46:   78:			G.discard[p][0] = card;
       46:   79:			G.discardCount[p] = 1;
       46:   80:			deckCount = fullDeckCount(p, card, &G);
call    0 returned 100%
       46:   81:			if (deckCount == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       46:   82:				printf("PASSED: fullDeckCount = %d, expected = 2.\n", deckCount);
call    0 returned 100%
        -:   83:			else
    #####:   84:				printf("FAILED: fullDeckCount = %d, expected = 2.\n", deckCount);
call    0 never executed
        -:   85:			
        -:   86:			// Check with 1 card in 1 places
       46:   87:			printf("Testing with 1 card in just hand.\n");
call    0 returned 100%
       46:   88:			memset(&G, 23, sizeof(struct gameState));   // clear the game state
       46:   89:			r = initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
       46:   90:			G.deckCount[p] = 0;
       46:   91:			G.hand[p][0] = card;
       46:   92:			G.handCount[p] = 1;
       46:   93:			G.discardCount[p] = 0;
       46:   94:			deckCount = fullDeckCount(p, card, &G);
call    0 returned 100%
       46:   95:			if (deckCount == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       46:   96:				printf("PASSED: fullDeckCount = %d, expected = 1.\n", deckCount);
call    0 returned 100%
        -:   97:			else
    #####:   98:				printf("FAILED: fullDeckCount = %d, expected = 1.\n", deckCount);
call    0 never executed
        -:   99:		}
        -:  100:	}
        1:  101:	return 0;
        -:  102:}
%-------------------------------------CARDTEST1-------------------------------------%
Testing ADVENTURER card.
Testing for player 0.
PASSED: New hand count = 7, expected = 7.
PASSED: First card added = 4, expected 4, 5, or 6.
PASSED: Second card added = 4, expected 4, 5, or 6.
Testing for player 1.
PASSED: New hand count = 2, expected = 2.
PASSED: First card added = 4, expected 4, 5, or 6.
FAILED: Second card added = 1, expected 4, 5, or 6.
File 'cardtest1.c'
Lines executed:91.67% of 24
Creating 'cardtest1.c.gcov'

File 'cardtest1.c'
Lines executed:91.67% of 24
Branches executed:75.00% of 16
Taken at least once:50.00% of 16
Calls executed:80.00% of 10
Creating 'cardtest1.c.gcov'

        -:    0:Source:cardtest1.c
        -:    0:Graph:cardtest1.gcno
        -:    0:Data:cardtest1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:File: cardtest1.c
        -:    3:Author: Elliot Bates
        -:    4:Description: Unit test for the adventurer card function in dominion.c
        -:    5:*/
        -:    6:
        -:    7:/*
        -:    8:int adventurerCard(int currentPlayer, struct gameState *state)
        -:    9:{
        -:   10:	int temphand[MAX_HAND];// moved above the if statement
        -:   11:	int drawntreasure=0;
        -:   12:	int cardDrawn;
        -:   13:	int z = 0;// this is the counter for the temp hand
        -:   14:	
        -:   15:      while(drawntreasure<2){
        -:   16:	if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
        -:   17:	  shuffle(currentPlayer, state);
        -:   18:	}
        -:   19:	drawCard(currentPlayer, state);
        -:   20:	cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
        -:   21:	if (cardDrawn == copper || cardDrawn == silver)
        -:   22:	  drawntreasure++;
        -:   23:	else{
        -:   24:	  temphand[z]=cardDrawn;
        -:   25:	  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
        -:   26:	  z++;
        -:   27:	}
        -:   28:      }
        -:   29:      while(z-1>=0){
        -:   30:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
        -:   31:	z=z-1;
        -:   32:      }
        -:   33:      return 0;
        -:   34:}
        -:   35:*/
        -:   36:
        -:   37:#include "dominion.h"
        -:   38:#include "dominion_helpers.h"
        -:   39:#include "rngs.h"
        -:   40:#include <stdio.h>
        -:   41:#include <assert.h>
        -:   42:#include <stdlib.h>
        -:   43:#include <string.h>
        -:   44:
function main called 1 returned 100% blocks executed 82%
        1:   45:int main(){
        -:   46:
        -:   47:	int i, r, p; 					 				
        -:   48:	int c1, c2;								// cards
        -:   49:	int pos;
        1:   50:	int seed = 1000;
        1:   51:	int numPlayers = 2;  					// players for valid gamestate
        -:   52:	struct gameState O;						// original gameState
        -:   53:	struct gameState G;						// test gameState
        1:   54:	int k[10] = {feast, gardens, embargo, adventurer, tribute, mine, cutpurse, ambassador, great_hall, smithy};
        -:   55:
        1:   56:	printf("Testing ADVENTURER card.\n");
call    0 returned 100%
        3:   57:	for (p = 0; p < numPlayers; p++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        2:   58:		printf("Testing for player %d.\n", p);
call    0 returned 100%
        -:   59:		//Create game state
        2:   60:		memset(&O, 23, sizeof(struct gameState));   // clear the game state
        2:   61:		r = initializeGame(numPlayers, k, seed, &O); // initialize a new game
call    0 returned 100%
        2:   62:		memcpy(&G, &O, sizeof(struct gameState)); // Copy game state
        2:   63:		G.whoseTurn = p; //set players turn
        -:   64:		//play card
        2:   65:		cardEffect(adventurer, 0, 0, 0, &G, 0, 0);
call    0 returned 100%
        -:   66:		
        -:   67:		//Check players hand has gained 2 cards
        2:   68:		if (G.handCount[p] == (O.handCount[p] + 2))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2:   69:			printf("PASSED: New hand count = %d, expected = %d.\n", G.handCount[p], (O.handCount[p] + 2));
call    0 returned 100%
        -:   70:		else
    #####:   71:			printf("FAILED: New hand count = %d, expected = %d.\n", G.handCount[p], (O.handCount[p] + 2));
call    0 never executed
        -:   72:		
        -:   73:		//Check 2 cards gained are treasure
        2:   74:		c1 = G.hand[p][G.handCount[p]-2]; // first added card
        2:   75:		c2 = G.hand[p][G.handCount[p]-1]; // second added card
        2:   76:		if (c1 == 4 || c1 == 5 || c1 == 6)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        2:   77:			printf("PASSED: First card added = %d, expected 4, 5, or 6.\n", c1);
call    0 returned 100%
        -:   78:		else
    #####:   79:			printf("FAILED: First card added = %d, expected 4, 5, or 6.\n", c1);
call    0 never executed
        2:   80:		if (c2 == 4 || c2 == 5 || c2 == 6)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        1:   81:			printf("PASSED: Second card added = %d, expected 4, 5, or 6.\n", c2);
call    0 returned 100%
        -:   82:		else
        1:   83:			printf("FAILED: Second card added = %d, expected 4, 5, or 6.\n", c2);
call    0 returned 100%
        -:   84:	}
        1:   85:	return 0;
        -:   86:}
%-------------------------------------CARDTEST2-------------------------------------%
Testing SMITHY card.
Testing for player 0 and handPos 0.
FAILED: New hand count = 8, expected = 7.
PASSED: New played count = 1, expected = 1.
Testing for player 0 and handPos 1.
FAILED: New hand count = 8, expected = 7.
PASSED: New played count = 1, expected = 1.
Testing for player 0 and handPos 2.
FAILED: New hand count = 8, expected = 7.
PASSED: New played count = 1, expected = 1.
Testing for player 0 and handPos 3.
FAILED: New hand count = 8, expected = 7.
PASSED: New played count = 1, expected = 1.
Testing for player 1 and handPos 0.
FAILED: New hand count = 8, expected = 7.
PASSED: New played count = 1, expected = 1.
Testing for player 1 and handPos 1.
FAILED: New hand count = 8, expected = 7.
PASSED: New played count = 1, expected = 1.
Testing for player 1 and handPos 2.
FAILED: New hand count = 8, expected = 7.
PASSED: New played count = 1, expected = 1.
Testing for player 1 and handPos 3.
FAILED: New hand count = 8, expected = 7.
PASSED: New played count = 1, expected = 1.
File 'cardtest2.c'
Lines executed:92.00% of 25
Creating 'cardtest2.c.gcov'

File 'cardtest2.c'
Lines executed:92.00% of 25
Branches executed:100.00% of 12
Taken at least once:83.33% of 12
Calls executed:77.78% of 9
Creating 'cardtest2.c.gcov'

        -:    0:Source:cardtest2.c
        -:    0:Graph:cardtest2.gcno
        -:    0:Data:cardtest2.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:File: cardtest2.c
        -:    3:Author: Elliot Bates
        -:    4:Description: Unit test for the smithy card function in dominion.c
        -:    5:*/
        -:    6:
        -:    7:/*
        -:    8:int smithyCard(int currentPlayer, struct gameState *state, int handPos)
        -:    9:{
        -:   10:	int i = 0;
        -:   11:      //+3 Cards
        -:   12:      for (i = 0; i > 3; i++)
        -:   13:	{
        -:   14:	  drawCard(currentPlayer, state);
        -:   15:	}
        -:   16:			
        -:   17:      //discard card from hand
        -:   18:      discardCard(handPos, currentPlayer, state, 0);
        -:   19:      return 0;
        -:   20:}
        -:   21:*/
        -:   22:
        -:   23:#include "dominion.h"
        -:   24:#include "dominion_helpers.h"
        -:   25:#include "rngs.h"
        -:   26:#include <stdio.h>
        -:   27:#include <assert.h>
        -:   28:#include <stdlib.h>
        -:   29:#include <string.h>
        -:   30:
function main called 1 returned 100% blocks executed 91%
        1:   31:int main(){
        -:   32:
        -:   33:	int i, r, p; 					 				
        -:   34:	int c1, c2;								// cards
        -:   35:	int pos;
        1:   36:	int seed = 1000;
        1:   37:	int numPlayers = 2;  					// players for valid gamestate
        -:   38:	struct gameState O;						// original gameState
        -:   39:	struct gameState G;						// test gameState
        1:   40:	int k[10] = {feast, gardens, embargo, adventurer, tribute, mine, cutpurse, ambassador, great_hall, smithy};
        -:   41:	int handPos;
        1:   42:	int maxHandPos = 4;
        -:   43:
        1:   44:	printf("Testing SMITHY card.\n");
call    0 returned 100%
        3:   45:	for (p = 0; p < numPlayers; p++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
       10:   46:		for (handPos = 0; handPos < maxHandPos; handPos++) {
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        8:   47:			printf("Testing for player %d and handPos %d.\n", p, handPos);
call    0 returned 100%
        -:   48:			//Create game state
        8:   49:			memset(&O, 23, sizeof(struct gameState));   // clear the game state
        8:   50:			memset(&G, 23, sizeof(struct gameState));   // clear the game state
        8:   51:			r = initializeGame(numPlayers, k, seed, &O); // initialize a new game
call    0 returned 100%
        8:   52:			O.whoseTurn = p; //set players turn
        8:   53:			if (p != 0) { //If not first player need to draw first hand
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
       24:   54:				  for (i = 0; i < 5; i++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
       20:   55:					drawCard(O.whoseTurn, &O);
call    0 returned 100%
        -:   56:				  }
        -:   57:			}
        8:   58:			memcpy(&G, &O, sizeof(struct gameState)); // Copy game state
        -:   59:			//play card
        8:   60:			cardEffect(smithy, 0, 0, 0, &G, handPos, 0);
call    0 returned 100%
        -:   61:			
        -:   62:			//Check players hand has gained 2 cards
        8:   63:			if (G.handCount[p] == (O.handCount[p] + 2))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   64:				printf("PASSED: New hand count = %d, expected = %d.\n", G.handCount[p], (O.handCount[p] + 2));
call    0 never executed
        -:   65:			else
        8:   66:				printf("FAILED: New hand count = %d, expected = %d.\n", G.handCount[p], (O.handCount[p] + 2));
call    0 returned 100%
        -:   67:			
        -:   68:			//check player has played 1 card
        8:   69:			if (G.playedCardCount == (O.playedCardCount + 1))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        8:   70:				printf("PASSED: New played count = %d, expected = %d.\n", G.playedCardCount, (O.playedCardCount + 1));
call    0 returned 100%
        -:   71:			else
    #####:   72:				printf("FAILED: New played count = %d, expected = %d.\n", G.playedCardCount, (O.playedCardCount + 1));
call    0 never executed
        -:   73:		}
        -:   74:	}
        1:   75:	return 0;
        -:   76:}
%-------------------------------------CARDTEST3-------------------------------------%
