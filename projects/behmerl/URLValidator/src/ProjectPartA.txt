CS 362
Spring 2016
Project Part A

Team Members:
Mark Dillman - dillmanm@oregonstate.edu
Lucile Behmer- behmerl@oregonstate.edu
Aaron Sealy - sealya@oregonstate.edu

How many test cases are generated? Explain where these are coming from.

There are 35,910 assembled and tested. I arrived at this by checking the maximum number 
of statements executed within the do-while loop that extends from line 94 to line 127, calculated as follows:

9 (testurlScheme) * 19 (testurlAuthority) * 7 (testurlPort) * 10 (testPath) 
* 3(testurlQuery) = 35,910

This loop is responsible for constructing unique test cases from data and comparing them to expected 
results.  The tests are generated by taking all possible permutations of ResultPair array elements in the 
testUrlParts object. These objects are constructed in a variety of ways depending on the options set selected, 
and their potential components can be seen in the data portion of the test class from lines 343 to 416.

Exploring the data objects more closely, we see that a ResultPair consists of a string fragment which is a 
particular part of a URL ( the scheme, authority, port, path, and query) and a Boolean value which states 
whether this value should make a test fail or whether it should pass pending the success of the other URL 
components. Any false ResultPair used to construct a complete URL should make the validator return invalid, 
and conversely if they are all true the URL will be valid. The testUrlParts object consists of an ordered 
array of ResultPair arrays. These are iterated over to assemble URL strings and expected test result values 
for those URL strings on lines 94-102 and also by the do-while loop that extends from line to 94 line 127. 
The test results for each string are run and compared in lines 107-9.

1)   Explain testIsValid Function of UrlValidator test code
A version of this function is called in main on line 331 which refers to the (argument-free) version of the 
function on line 43.  This function in turn calls the version of testisValid that we are concerned with, which 
takes as arguments the testUrlParts object created on line 415 and a second parameter, a long value used to 
specify options.  This function is defined beginning on line 85 and it works by creating a complete url using 
the 5 parts (scheme, authority, port, path, query) contained in the arrays passed by the testUrlParts object.  
Each piece also contains a Boolean value indicating if it is valid or not.  If any of the url parts contain an 
invalid flag, the entire url will have an expected invalid result.  If none of the parts contain invalid parts, 
then the url is expected to be valid.  The method uses a do-while loop as discussed above to test all possible 
combinations to determine (and print out) any cases where the actual results differ from the expected results.  
If there is a discrepancy, this indicates a bug.

2) Give an example of valid url being tested and an invalid url being tested by testIsValid() method.

A valid url being tested is “http://www.google.com” – This is tested on line 87
An invalid url being tested is "http/1.2.3.4.5:65a/$23.?action=view", which is a combination of the 
invalid parts: "http/" + "1.2.3.4.5" + ":65a" + "/$23” and the valid query "?action=view."

3)  Do you think that a real world test (URL Validator's testIsValid() test in this case) is very different 
than the unit tests and card tests that we wrote (in terms of concepts & complexity)? Explain in few lines

They are similar in that they both adhere to the same testing principles.  For example, both cases compare 
the expected result of running the function with the actual results obtained in order to determine if the 
function performed as expected.  

They are different in terms of scope and complexity, however. With the unit tests for the game, the expected 
inputs and outputs are very limited, based on the logic of the game, and it does not have to deal with testing 
scenarios with unpredictable user inputs.  It is fairly simple to test that a function performs a straightforward 
task, like adding or subtracting from given variables, while real world tests are often more complex in that are 
evaluating functions that perform much complicated tasks, which are therefore more difficult to test.  In this case, 
for example, we are testing tens of thousands of url combinations.

The functions contained in the URL validation class also take advantage of overloading to provide the opportunity 
to run custom test cases in addition to those URLs that are part of the default package contained in the member 
data of the class. This expandability allows for the easy addition of new edge test cases for code that was 
added or altered in the URL validator source code. Added flexibility to test routines allows the test classes 
to grow along with the source code being tested, which is particularly useful in the open-source model of software development.

