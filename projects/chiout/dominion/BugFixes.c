/*

I received several bug reports for my refactored dominion.c from both of my teammates.
Two bug reports were for the smithy card, one for the adventurer card, and three for the steward card.
 
Fixing Bug in smithyDrawn function:
 The two bug reports for the smithy card noted that the number of cards in the player's hand, after playing the smithy card, was wrong. One bug report noted that the expected results are wrong as the deck count is one less than expected and the hand count is one more than expected. The second bug report for smithy indicated the bug is that the drawCard function is being called 4 times instead of three, and so the current player is drawing 1 extra card. To fix this bug, the for loop in the smithyDrawn function was fixed - the for loop condition was changed from i<=3 to i<3 - so that the drawCard function is only called three times.
 
Fixing Bug in adventurerDrawn function:
 I received a bug report for the adventurer card. The bug report revealed that the number of coins, or treasure cards, is one greater than expected and the number of cards in the current player's hand is one more than expected. This reveals that the number of treasure cards being drawn by the current player is one more than expected. To fix this, the while loop condition is changed from drawntreasure<=2 to drawntreasure<2 so that the while loop ends when 2 treasure cards are drawn instead of 3.
 
Fixing Bugs in stewardDrawn function:
 I received information of 3 different bugs for the steward card. One bug was that if a player chooses choice 1, the played card does not go into the played pile. The report further stated that the flag for the discardCard function call at the end should be 0 instead of 1 so that the played card is discarded. I fixed this in stewardDrawn. Another bug reported to me in the stewardDrawn function is that if the player chooses choice 2, the player should be gaining 2 coins, not 3. I fixed this bug by changing state->coins+3 to state->coins+2. The last bug reported was that if the player chooses choice3, the played card count is wrong. The report told me to change the flag for the discardcard function calls to be 1 instead of 0, so I changed the function calls' flags from 0 to 1 in the body of the else statement.
 
Bugs not reported and isolated by debugging with GDB:
 Debugging adventurerDrawn Function:
 	Before running GDB, I ran cardtest1.c, which tests the adventurer card, and verified that there were some failures in the adventurer card. The results told me that the deck+discard count was not 2 less than before and was either missing or containing invalid cards. I went ahead and used GDB on my cardtest1.c to debug the adventurerDrawn function. To do this, I called gdb on the cardtest1 executable, set a break point for adventurerDrawn function call - so when that function is called, and told GDB to run. At the first breakpoint, the different count values were printed out; namely state->handCount[currentPlayer] which was 5, state->discardCount[currentPlayer] which was 20, and state->deckCount[currentPlayer], which was 6. I also printed out z, which was 0. I then set a breakpoint for line 667, which is when the second while loop begins in adventuererDrawn, and continued running the code. At the next breakpoint, I printed out the count values again, and got state->handCount[currentPlayer] = 7, state->deckCount[currentPlayer] = 1, and state->discardCount[currentPlayer] = 20. z was now 3. The handCount is 2 cards more than before, which makes sense because the player should have a net gain of 2 treasure cards. The deck count is now 1, the player gained 2 cards and z=3, which means that 1+2+3 should equal the original deck count. 1+2+3 = 6 and the original deck count was 6 so this makes sense. The discard count did not change which also makes sense because no cards have been discarded yet - so far nothing unexpected has occured. Now I set a break point for after the while loop as executed to see if anything unexpected happens. The breakpoint is set at line 671, which is the closing brace of the function. I then printed out the different counts and z to see what their values are. state->handCount[currentPlayer] was 7, state->discardCount[currentPlayer] was 22, and state->deckCount[currentPlayer] was 1. The value of z was 1. The hand and deck count did not change, which makes sense. However, the discard count only increased by 2, whereas it should have increased by 3 and z should be 0 instead of 1. This means that all cards except 1 in the temphand array were transferred to the discard array, and the bug is in the second while loop. This lead me to fix the condition in the second while loop from z-1>0 to z-1>=0. I quit GDB and ran cardtest1 against the fixed adventurerDrawn code. All the tests were passed. This method of using GDB to navigate through the adventurerDrawn had very good statement coverage for the adventurerDrawn fuction, as it ran through every line in the adventuererDrawn function, but not necessarily for the drawCard function as trying to achieve good coverage of other functions is not the purpose of GDB. Since the temphand array was not empty, both bodies of code in the if/else statement must have been executed; therefore every line in adventurerDrawn must have been executed when debugging with GDB.
 
 Debugging remodelDrawn function:
 	As I did not have a unit test to test the remodel drawn card, I wrote a short program called remodelCard.c (which I added to my dominion directory) that calls the remodelDrawn function so that I could use GDB to test it. The remodelCard.c program uses the same gameState setup as my randomtestdventurer.c test, and I added some additional code to give values to the choice1, choice2, and handPos variables. The code ensures that handPos and choice1 have different values.
 	I ensure better statement coverage, I hard coded values for choice1 and choice2 into two different test runs in remodelCard.c. The first scenario sets choice1 and choice2 such that it should not return -1 in the first if statement. The second test run sets the values of choice1 and choice2 such that remodelDrawn should return -1 in the first if statement. Executing both restcases should ensure good statement coverage of the remodelDrawn function.
 	I called GDB on testremodel (which compiles remodelCard.c against dominion.o and rngs.o) and set a breakpoint at the remodelDrawn function call. I then ran GDB and printed out the values of getCost(state->hand[currentPlayer][choice1]), which was 2, and getCost(choice2), which was 5. Since 2+2 < 4, I would not expect this function to return -1. I then printed out the hand count, which was 337, and played card count, which was 286. I then set the next breakpoint for line 715, after the first discardCard function, so I can check the playedCard count and hand count. Instead of continuing to line 715, the function seemingly returned with -1 and moved onto the next testcase, stopping at the remodelDrawn function call breakpoint again.
 	This error lead me to deduce that there is a bug in the first if statement. I changed ">getCost(choice1) to >getCost(choice2) in the condition of the first if statement in remodelDrawn, recompiled testremodel, and restarted gdb. I did the same thing as before - set breakpoint at remodelDrawn, printed out values (which were all the same as before thanks to the pseudo-random number generators), and this time the function was able to reach line 715. I then checked the hand and played card counts as well as supplyCount(choice2, state). supplyCount returned 0, which means that a card is not gained and therefore the hand count should be one less than before and the played card count should be one more than before. The hand count was 336 and the played card count was 287, which are expected values.
 	Finally, we move onto the final for loop. I set a break point at the end of the for loop, line 721. I then printed out the values of hand count and played card count, which were 336 and 287 respectively. The hand count should be one less (335) and the discard count should be one (288) more since a card is discarded; thus the card that needs to be discarded is not being discarded. This signaled a bug in the for loop, and I noticed that the for loop does not browse through every card but rather every other card. I exited gdb and changed i+=2 to i++ in the last for loop of remodelDrawn (in dominion.c).
 	I relaunched GDB with the fixed dominion.c code, and ran it with the same steps as my previous runs. The values of all the variables were the same thanks to the pseudo-random number generator and my hardcoded values. This time, the hand count came out to be 335, which is to be expected. However the played card count is still 287, whereas it should be 288 since a card is discarded from the hand. This told me that a card is removed from the current player's hand but is trashed instead of discarded to the played card pile. In the remodelDrawn function, I changed the discardCard flag from 1 to 0. I recompiled my code and restarted GDB with testremodel.
 	Once again I relaunched GDB and ran it the same way I did before. This time, the played card count came out correctly to 288, whereas the hand count was 335. I then continued running GDB and it stopped at the breakpoint for the next test case. I printed out getCost(state->hand[currentPlayer][choice1]), which was 5, and getCost(choice2), which was 5. I set the next break point for line 715, although the function should end and breakpoint 715 should not be reached because 5+2>5. I ran GDB and it declared that the program had ended (process exited normally), which is to be expected since the remodelDrawn should return with -1 and remodelCard.c exits after running remodelDrawn twice.
 	Running GDB against the remodelDrawn function no doubt had complete statement coverage for the remodelDrawn function. However, as remodelCard.c only manually runs the remodelDrawn function twice, it did not achieve good statement coverage for the functions that remodelDrawn calls, such as gainCard and discardCard. It seemingly may be quite time consuming to use GDB on enough tests in an attempt to try to achieve complete statement coverage. I think that it makes more sense, for testing, to run unit tests (like random testers) to achieve coverage, and just use GDB to debug failed tests as opposed to using GDB for the purpose of trying to achieve some kind of complete coverage.
 
 
 
 
 
 
 
 
 
 
 
 
 

*/