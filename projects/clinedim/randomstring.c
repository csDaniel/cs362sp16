/*
	FileName:  randomstring.c
	Author:    Marc Clinedinst

	*** Introduction ***

	This file contains my write up for the testme.c program, which is the second quiz for OSU CS 362.

	This quiz ended up being a little trickier than I anticipated, mostly because my C is a little bit
	rusty.  I haven't touched C since around this time last year, so I had to spend a good bit of time
	reminding myself about how pointers and strings work in C. After getting past those little bumps,
	the program wasn't too bad.

	*** Implementation Details ***

	One of the first challenges I encountered was determining which characters would be a part of the
	set of characters from which I would generate random characters and strings.  Upon examining the
	test, I realized that the lower case alphabet, the space character, and the variations on the 
	bracket charcters--specificially, (), [], and {}--were the most important to include in the set 
	of characters.  The final set of characters I used is listed below (note--even though it may not
	be ready apparent, the space character is part of this set):

					abcdefghijklmnopqrstuvwxyz([{}]) 	

	To generate random characters, I stored this set of characters in a one-dimensional array of
	characters, and then generated a random index in a valid range for the array.  The character
	at this random index became the random character.

	Next, I turned my focus to generating random strings.  I decided to limit my strings to six
	characters, including the null terminator.  I then built a character array with six indices and
	loop through it five times, calling the inputChar function at each index.  Once the iteration was
	complete, I stored the null-terminator in the final index, completing the string.

	*** Justification for Implementation ***

	While I was implementing the functions above, I needed to accomplish a couple of things in order to
	get the program into a state that would cause the error message to print to the screen.

	Firstly, I needed to get the program to enter the 9th state.  I accomplished this by making sure that
	all of the characters required for each state were included in the character set.  Secondly, once the
	9th state is reached, he word "reset" needs to be generated by the random string generator.  To accomplish
	this, I also needed to make sure that the the letters were in the character set used for generating
	random characters.  I limited the random strings to six characters (including the null-terminator), so 
	that the word "reset" would be more likely to be generated.  Even with this limitation, it can still
	take a large number of iterations for the word to occur.

	*** Results ***

	With these two functions complete, I began running the test.  One thing that I noticed immediately
	is that the test appeared to be running forever.  I observed millions of iterations in the output
	and thought that my implementations of my functions  were incorrect.  In reality, the following 
	call was simply slowing the program down, giving it the appearance of running forever:

		printf("Iteration %d: c = %c, s = %s, state = %d\n", tcCount, c, s, state);

	I ended up temporarily commenting this out, and the program did in fact terminate, although it was still 
	taking five to ten seconds to do so on my computer.  I ended up making some small modifications to the output
	so that I could easily see how many iterations it was taking to reach the error condition.  I ran
	the program ten times and observed that the program took the following number of iterations to
	terminate on these runs:

		81049771
		24365136
		1513113
		18030082
		36294351
		5438210
		5623900
		2470611
		7799513
		103189359

	The average number of iterations during these ten runs was 28577404 iterations.  This number of iterations
	would take a long time to complete with the output turned on.  You may need to turn off all output except
	for the error message in order to observe the program terminating with the error message.  Otherwise, the
	program may appear to run infinitely.

	I also examined the coverage of this program using gcov, and 96.88% of the lines were covered under the 
	current implementation.  This is a fairly high level of coverage.
*/