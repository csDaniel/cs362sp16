Function Coverage
As expected, my test suite executed 100% of the lines in the functions tested, including playAdventurer, playSmithy, and playRemodel, updateCoins, fullDeckCount, and endTurn.  Because I had not refactored the embargo card, this likely ended up merely increasing the number of lines used in cardEffect, which came out to a measly 9.44%, likely because I had refactored most of the functions I tested. 

However, the fact that I had executed so many other functions somewhat undermines the integrity of my unit tests. For example, I executed 100% of the supplyCount function and shuffle function. I often used the supplyCount function in order to keep track of any state changes in the supply of the cards (especially in making sure that the card functions worked properly). Additionally, although I did not call the shuffle function directly, I purposely tried to create a state in which the discard pile would have to be reshuffled into the deck, just to make sure that all the cards really made it to where they were supposed to go. Unfortunately, if supplyCount or the shuffle function were faulty, then many of my unit tests would also have inexplicably failed, making it all the more difficult to spot why my functions were getting errors.  

Another factor in this is that my tests often repeatedly checked certain aspects of the game. For example, the whoseTurn function is called 49 times and isGameOver function 44 times because I always wanted to make sure that playing a card didn’t unexpectedly cause a player to lose his/her turn or end the game (both of which would be very high-impact bugs).  

On the other hand, some of the other functions probably should have been executed more often.  For example, the initializeGame had only 88.71% of the lines covered. Theoretically, the way that the game was initialized itself had corner cases that would have affected the rest of the functions. Similarly, the buyCard function only executed 76.92% of the lines, but this probably just suggests that I did not test enough functions that enable players to buy cards. 


Statement Coverage
Overall, 43.47% of the lines were executed in the unit tests. Again, this has its benefits and concerns. On the one hand, it’s more than a little worrisome that the “unit” tests that are meant to isolate bugs for only 8 functions cover almost half of an entire program. Although many of the tests were simply lengthier than others, the fact that two of the cards were Smithy and Embargo (less than 10 lines each), suggests that my code was not. 

Fortunately, the majority of the statements that failed to execute were simply in cards that I never tested, including playAmbassador and a number of cards in cardEffect. Some of the unit functions, on the other hand, such as scoreFor and getWinners simply have a lot of lines in them because they need to calculate separate possibilities for each of the potential cards that a player could end with. 

Branch Coverage
Unlike mere function coverage and statement coverage, a 44.84% branch coverage suggests that my code at least covers a lot of corner cases in the functions that I do call. However, a large part of that may have to do with the various unit functions that were called, as well as the number of helper functions I used to keep track of the current state of each player’s hand, deck, discard, and played pile, as well as each of the supply counts. 

A large area that I need to fix is the cardEffect function, each of which have a very large number of branches within each card that were never executed either way. Additionally, although I did try to cover as many branches as I could, there are a lot of “fallthrough” branches, mostly because I had simply tested that corner case once. Because I found so many bugs in the functions, especially in the card functions, I found it far more useful to try to use various “normal” cases to try to figure out the conditions that triggered failure. However, especially considering that I did not find fault with any of the unit cases, it probably would have been better to explore the corner cases just as often, if not more often, for those functions.  
