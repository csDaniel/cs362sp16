Test 0
Test 1
Test 2
Test 3
Test 4
Test 5
Test 6
Test 7
Test 8
Test 9
Test 10
Test 11
Test 12
Test 13
Test 14
Test 15
Test 16
Test 17
Test 18
Test 19
Test 20
Test 21
Test 22
Test 23
Test 24
Test 25
Test 26
Test 27
Test 28
Test 29
Test 30
Test 31
Test 32
Test 33
Test 34
Test 35
Test 36
Test 37
Test 38
Test 39
Test 40
Test 41
Test 42
Test 43
Test 44
Test 45
Test 46
Test 47
Test 48
Test 49
Test 50
Test 51
Test 52
Test 53
Test 54
Test 55
Test 56
Test 57
Test 58
Test 59
Test 60
Test 61
Test 62
Test 63
Test 64
Test 65
Test 66
Test 67
Test 68
Test 69
Test 70
Test 71
Test 72
Test 73
Test 74
Test 75
Test 76
Test 77
Test 78
Test 79
Test 80
Test 81
Test 82
Test 83
Test 84
Test 85
Test 86
Test 87
Test 88
Test 89
Test 90
Test 91
Test 92
Test 93
Test 94
Test 95
Test 96
Test 97
Test 98
Test 99
Test 100
Test 101
Test 102
Test 103
Test 104
Test 105
Test 106
Test 107
Test 108
Test 109
Test 110
Test 111
Test 112
Test 113
Test 114
Test 115
Test 116
Test 117
Test 118
Test 119
Test 120
Test 121
Test 122
Test 123
Test 124
Test 125
Test 126
Test 127
Test 128
Test 129
Test 130
Test 131
Test 132
Test 133
Test 134
Test 135
Test 136
Test 137
Test 138
Test 139
Test 140
Test 141
Test 142
Test 143
Test 144
Test 145
Test 146
Test 147
Test 148
Test 149
Test 150
Test 151
Test 152
Test 153
Test 154
Test 155
Test 156
Test 157
Test 158
Test 159
Test 160
Test 161
Test 162
Test 163
Test 164
Test 165
Test 166
Test 167
Test 168
Test 169
Test 170
Test 171
Test 172
Test 173
Test 174
Test 175
Test 176
Test 177
Test 178
Test 179
Test 180
Test 181
Test 182
Test 183
Test 184
Test 185
Test 186
Test 187
Test 188
Test 189
Test 190
Test 191
Test 192
Test 193
Test 194
Test 195
Test 196
Test 197
Test 198
Test 199
Test 200
Test 201
Test 202
Test 203
Test 204
Test 205
Test 206
Test 207
Test 208
Test 209
Test 210
Test 211
Test 212
Test 213
Test 214
Test 215
Test 216
Test 217
Test 218
Test 219
Test 220
Test 221
Test 222
Test 223
Test 224
Test 225
Test 226
Test 227
Test 228
Test 229
Test 230
Test 231
Test 232
Test 233
Test 234
Test 235
Test 236
Test 237
Test 238
Test 239
Test 240
Test 241
Test 242
Test 243
Test 244
Test 245
Test 246
Test 247
Test 248
Test 249
Test 250
Test 251
Test 252
Test 253
Test 254
Test 255
Test 256
Test 257
Test 258
Test 259
Test 260
Test 261
Test 262
Test 263
Test 264
Test 265
Test 266
Test 267
Test 268
Test 269
Test 270
Test 271
Test 272
Test 273
Test 274
Test 275
Test 276
Test 277
Test 278
Test 279
Test 280
Test 281
Test 282
Test 283
Test 284
Test 285
Test 286
Test 287
Test 288
Test 289
Test 290
Test 291
Test 292
Test 293
Test 294
Test 295
Test 296
Test 297
Test 298
Test 299
Test 300
Test 301
Test 302
Test 303
Test 304
Test 305
Test 306
Test 307
Test 308
Test 309
Test 310
Test 311
Test 312
Test 313
Test 314
Test 315
Test 316
Test 317
Test 318
Test 319
Test 320
Test 321
Test 322
Test 323
Test 324
Test 325
Test 326
Test 327
Test 328
Test 329
Test 330
Test 331
Test 332
Test 333
Test 334
Test 335
Test 336
Test 337
Test 338
Test 339
Test 340
Test 341
Test 342
Test 343
Test 344
Test 345
Test 346
Test 347
Test 348
Test 349
Test 350
Test 351
Test 352
Test 353
Test 354
Test 355
Test 356
Test 357
Test 358
Test 359
Test 360
Test 361
Test 362
Test 363
Test 364
Test 365
Test 366
Test 367
Test 368
Test 369
Test 370
Test 371
Test 372
Test 373
Test 374
Test 375
Test 376
Test 377
Test 378
Test 379
Test 380
Test 381
Test 382
Test 383
Test 384
Test 385
Test 386
Test 387
Test 388
Test 389
Test 390
Test 391
Test 392
Test 393
Test 394
Test 395
Test 396
Test 397
Test 398
Test 399
Test 400
Test 401
Test 402
Test 403
Test 404
Test 405
Test 406
Test 407
Test 408
Test 409
Test 410
Test 411
Test 412
Test 413
Test 414
Test 415
Test 416
Test 417
Test 418
Test 419
Test 420
Test 421
Test 422
Test 423
Test 424
Test 425
Test 426
Test 427
Test 428
Test 429
Test 430
Test 431
Test 432
Test 433
Test 434
Test 435
Test 436
Test 437
Test 438
Test 439
Test 440
Test 441
Test 442
Test 443
Test 444
Test 445
Test 446
Test 447
Test 448
Test 449
Test 450
Test 451
Test 452
Test 453
Test 454
Test 455
Test 456
Test 457
Test 458
Test 459
Test 460
Test 461
Test 462
Test 463
Test 464
Test 465
Test 466
Test 467
Test 468
Test 469
Test 470
Test 471
Test 472
Test 473
Test 474
Test 475
Test 476
Test 477
Test 478
Test 479
Test 480
Test 481
Test 482
Test 483
Test 484
Test 485
Test 486
Test 487
Test 488
Test 489
Test 490
Test 491
Test 492
Test 493
Test 494
Test 495
Test 496
Test 497
Test 498
Test 499
Test 500
Test 501
Test 502
Test 503
Test 504
Test 505
Test 506
Test 507
Test 508
Test 509
Test 510
Test 511
Test 512
Test 513
Test 514
Test 515
Test 516
Test 517
Test 518
Test 519
Test 520
Test 521
Test 522
Test 523
Test 524
Test 525
Test 526
Test 527
Test 528
Test 529
Test 530
Test 531
Test 532
Test 533
Test 534
Test 535
Test 536
Test 537
Test 538
Test 539
Test 540
Test 541
Test 542
Test 543
Test 544
Test 545
Test 546
Test 547
Test 548
Test 549
Test 550
Test 551
Test 552
Test 553
Test 554
Test 555
Test 556
Test 557
Test 558
Test 559
Test 560
Test 561
Test 562
Test 563
Test 564
Test 565
Test 566
Test 567
Test 568
Test 569
Test 570
Test 571
Test 572
Test 573
Test 574
Test 575
Test 576
Test 577
Test 578
Test 579
Test 580
Test 581
Test 582
Test 583
Test 584
Test 585
Test 586
Test 587
Test 588
Test 589
Test 590
Test 591
Test 592
Test 593
Test 594
Test 595
Test 596
Test 597
Test 598
Test 599
Test 600
Test 601
Test 602
Test 603
Test 604
Test 605
Test 606
Test 607
Test 608
Test 609
Test 610
Test 611
Test 612
Test 613
Test 614
Test 615
Test 616
Test 617
Test 618
Test 619
Test 620
Test 621
Test 622
Test 623
Test 624
Test 625
Test 626
Test 627
Test 628
Test 629
Test 630
Test 631
Test 632
Test 633
Test 634
Test 635
Test 636
Test 637
Test 638
Test 639
Test 640
Test 641
Test 642
Test 643
Test 644
Test 645
Test 646
Test 647
Test 648
Test 649
Test 650
Test 651
Test 652
Test 653
Test 654
Test 655
Test 656
Test 657
Test 658
Test 659
Test 660
Test 661
Test 662
Test 663
Test 664
Test 665
Test 666
Test 667
Test 668
Test 669
Test 670
Test 671
Test 672
Test 673
Test 674
Test 675
Test 676
Test 677
Test 678
Test 679
Test 680
Test 681
Test 682
Test 683
Test 684
Test 685
Test 686
Test 687
Test 688
Test 689
Test 690
Test 691
Test 692
Test 693
Test 694
Test 695
Test 696
Test 697
Test 698
Test 699
Test 700
Test 701
Test 702
Test 703
Test 704
Test 705
Test 706
Test 707
Test 708
Test 709
Test 710
Test 711
Test 712
Test 713
Test 714
Test 715
Test 716
Test 717
Test 718
Test 719
Test 720
Test 721
Test 722
Test 723
Test 724
Test 725
Test 726
Test 727
Test 728
Test 729
Test 730
Test 731
Test 732
Test 733
Test 734
Test 735
Test 736
Test 737
Test 738
Test 739
Test 740
Test 741
Test 742
Test 743
Test 744
Test 745
Test 746
Test 747
Test 748
Test 749
Test 750
Test 751
Test 752
Test 753
Test 754
Test 755
Test 756
Test 757
Test 758
Test 759
Test 760
Test 761
Test 762
Test 763
Test 764
Test 765
Test 766
Test 767
Test 768
Test 769
Test 770
Test 771
Test 772
Test 773
Test 774
Test 775
Test 776
Test 777
Test 778
Test 779
Test 780
Test 781
Test 782
Test 783
Test 784
Test 785
Test 786
Test 787
Test 788
Test 789
Test 790
Test 791
Test 792
Test 793
Test 794
Test 795
Test 796
Test 797
Test 798
Test 799
Test 800
Test 801
Test 802
Test 803
Test 804
Test 805
Test 806
Test 807
Test 808
Test 809
Test 810
Test 811
Test 812
Test 813
Test 814
Test 815
Test 816
Test 817
Test 818
Test 819
Test 820
Test 821
Test 822
Test 823
Test 824
Test 825
Test 826
Test 827
Test 828
Test 829
Test 830
Test 831
Test 832
Test 833
Test 834
Test 835
Test 836
Test 837
Test 838
Test 839
Test 840
Test 841
Test 842
Test 843
Test 844
Test 845
Test 846
Test 847
Test 848
Test 849
Test 850
Test 851
Test 852
Test 853
Test 854
Test 855
Test 856
Test 857
Test 858
Test 859
Test 860
Test 861
Test 862
Test 863
Test 864
Test 865
Test 866
Test 867
Test 868
Test 869
Test 870
Test 871
Test 872
Test 873
Test 874
Test 875
Test 876
Test 877
Test 878
Test 879
Test 880
Test 881
Test 882
Test 883
Test 884
Test 885
Test 886
Test 887
Test 888
Test 889
Test 890
Test 891
Test 892
Test 893
Test 894
Test 895
Test 896
Test 897
Test 898
Test 899
Test 900
Test 901
Test 902
Test 903
Test 904
Test 905
Test 906
Test 907
Test 908
Test 909
Test 910
Test 911
Test 912
Test 913
Test 914
Test 915
Test 916
Test 917
Test 918
Test 919
Test 920
Test 921
Test 922
Test 923
Test 924
Test 925
Test 926
Test 927
Test 928
Test 929
Test 930
Test 931
Test 932
Test 933
Test 934
Test 935
Test 936
Test 937
Test 938
Test 939
Test 940
Test 941
Test 942
Test 943
Test 944
Test 945
Test 946
Test 947
Test 948
Test 949
Test 950
Test 951
Test 952
Test 953
Test 954
Test 955
Test 956
Test 957
Test 958
Test 959
Test 960
Test 961
Test 962
Test 963
Test 964
Test 965
Test 966
Test 967
Test 968
Test 969
Test 970
Test 971
Test 972
Test 973
Test 974
Test 975
Test 976
Test 977
Test 978
Test 979
Test 980
Test 981
Test 982
Test 983
Test 984
Test 985
Test 986
Test 987
Test 988
Test 989
Test 990
Test 991
Test 992
Test 993
Test 994
Test 995
Test 996
Test 997
Test 998
Test 999
Final tally for Random Test ( Village ):
Fail: 2947
File 'dominion.c'
Lines executed:22.46% of 561
Branches executed:18.71% of 417
Taken at least once:16.07% of 417
Calls executed:10.42% of 96
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 46630 returned 100% blocks executed 100%
    46630:    8:int compare(const void* a, const void* b) {
    46630:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
     1190:   10:    return 1;
    45440:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
    12364:   12:    return -1;
    33076:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 1000 returned 100% blocks executed 95%
     1000:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
     1000:   44:  SelectStream(1);
call    0 returned 100%
     1000:   45:  PutSeed((long)randomSeed);
call    0 returned 100%
        -:   46:  
        -:   47:  //check number of players
     1000:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
     1000:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
    11000:   57:  for (i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   58:    {
   110000:   59:      for (j = 0; j < 10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   60:        {
   100000:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
     1000:   73:  if (numPlayers == 2)
branch  0 taken 36% (fallthrough)
branch  1 taken 64%
        -:   74:    {
      361:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
      639:   77:  else if (numPlayers == 3)
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
        -:   78:    {
      324:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
      315:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
     1000:   87:  if (numPlayers == 2)
branch  0 taken 36% (fallthrough)
branch  1 taken 64%
        -:   88:    {
      361:   89:      state->supplyCount[estate] = 8;
      361:   90:      state->supplyCount[duchy] = 8;
      361:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
      639:   95:      state->supplyCount[estate] = 12;
      639:   96:      state->supplyCount[duchy] = 12;
      639:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
     1000:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
     1000:  102:  state->supplyCount[silver] = 40;
     1000:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    21000:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  107:    {
   165000:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  109:	{
   155000:  110:	  if (kingdomCards[j] == i)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
    10000:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 11% (fallthrough)
branch  3 taken 89%
        -:  114:		{
     4000:  115:		  if (numPlayers == 2){ 
branch  0 taken 36% (fallthrough)
branch  1 taken 64%
      722:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
     1278:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
     8000:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
    10000:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
   145000:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
     3954:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  139:    {
     2954:  140:      state->deckCount[i] = 0;
    11816:  141:      for (j = 0; j < 3; j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  142:	{
     8862:  143:	  state->deck[i][j] = estate;
     8862:  144:	  state->deckCount[i]++;
        -:  145:	}
    23632:  146:      for (j = 3; j < 10; j++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -:  147:	{
    20678:  148:	  state->deck[i][j] = copper;
    20678:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
     3954:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  155:    {
     2954:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
     3954:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
     2954:  166:      state->handCount[i] = 0;
     2954:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    28000:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  177:    {
    27000:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
     1000:  182:  state->outpostPlayed = 0;
     1000:  183:  state->phase = 0;
     1000:  184:  state->numActions = 1;
     1000:  185:  state->numBuys = 1;
     1000:  186:  state->playedCardCount = 0;
     1000:  187:  state->whoseTurn = 0;
     1000:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
     6000:  192:  for (it = 0; it < 5; it++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
     5000:  193:    drawCard(state->whoseTurn, state);
call    0 returned 100%
        -:  194:  }
        -:  195:
     1000:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 100%
        -:  197:
     1000:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 2956 returned 100% blocks executed 94%
     2956:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
     2956:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
     2956:  209:  if (state->deckCount[player] < 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  210:    return -1;
     2956:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 100%
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    35818:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
    29906:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 100%
    29906:  216:    newDeck[newDeckPos] = state->deck[player][card];
    29906:  217:    newDeckPos++;
   113247:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 74%
branch  1 taken 26% (fallthrough)
    83341:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
    29906:  221:    state->deckCount[player]--;
        -:  222:  }
    32862:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
    29906:  224:    state->deck[player][i] = newDeck[i];
    29906:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
     2956:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
branch  0 never executed
branch  1 never executed
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  298:  
    #####:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
    #####:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 0 returned 0% blocks executed 0%
    #####:  320:int supplyCount(int card, struct gameState *state) {
    #####:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 0 returned 0% blocks executed 0%
    #####:  346:int whoseTurn(struct gameState *state) {
    #####:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
    #####:  353:  int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  354:  
        -:  355:  //Discard hand
    #####:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
    #####:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
    #####:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 never executed
branch  1 never executed
    #####:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
    #####:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
    #####:  370:  state->outpostPlayed = 0;
    #####:  371:  state->phase = 0;
    #####:  372:  state->numActions = 1;
    #####:  373:  state->coins = 0;
    #####:  374:  state->numBuys = 1;
    #####:  375:  state->playedCardCount = 0;
    #####:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    #####:  380:  for (k = 0; k < 5; k++){
branch  0 never executed
branch  1 never executed
    #####:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  382:  }
        -:  383:
        -:  384:  //Update money
    #####:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 never executed
        -:  386:
    #####:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
    #####:  395:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  396:    {
    #####:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
    #####:  401:  j = 0;
    #####:  402:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  403:    {
    #####:  404:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  405:	{
    #####:  406:	  j++;
        -:  407:	}
        -:  408:    }
    #####:  409:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  410:    {
    #####:  411:      return 1;
        -:  412:    }
        -:  413:
    #####:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 6000 returned 100% blocks executed 92%
     6000:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
     6000:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
      368:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
      366:  534:      state->deck[player][i] = state->discard[player][i];
      366:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
        2:  538:    state->deckCount[player] = state->discardCount[player];
        2:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
        2:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 100%
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
        2:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
        2:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
        2:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
        2:  559:    if (deckCounter == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  560:      return -1;
        -:  561:
        2:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
        2:  563:    state->deckCount[player]--;
        2:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
     5998:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
     5998:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
     5998:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     5998:  576:    state->deckCount[player]--;
     5998:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
     6000:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 0 returned 0% blocks executed 0%
    #####:  583:int getCost(int cardNumber)
        -:  584:{
    #####:  585:  switch( cardNumber ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
        -:  586:    {
        -:  587:    case curse:
    #####:  588:      return 0;
        -:  589:    case estate:
    #####:  590:      return 2;
        -:  591:    case duchy:
    #####:  592:      return 5;
        -:  593:    case province:
    #####:  594:      return 8;
        -:  595:    case copper:
    #####:  596:      return 0;
        -:  597:    case silver:
    #####:  598:      return 3;
        -:  599:    case gold:
    #####:  600:      return 6;
        -:  601:    case adventurer:
    #####:  602:      return 6;
        -:  603:    case council_room:
    #####:  604:      return 5;
        -:  605:    case feast:
    #####:  606:      return 4;
        -:  607:    case gardens:
    #####:  608:      return 4;
        -:  609:    case mine:
    #####:  610:      return 5;
        -:  611:    case remodel:
    #####:  612:      return 4;
        -:  613:    case smithy:
    #####:  614:      return 4;
        -:  615:    case village:
    #####:  616:      return 3;
        -:  617:    case baron:
    #####:  618:      return 4;
        -:  619:    case great_hall:
    #####:  620:      return 3;
        -:  621:    case minion:
    #####:  622:      return 5;
        -:  623:    case steward:
    #####:  624:      return 3;
        -:  625:    case tribute:
    #####:  626:      return 5;
        -:  627:    case ambassador:
    #####:  628:      return 3;
        -:  629:    case cutpurse:
    #####:  630:      return 4;
        -:  631:    case embargo: 
    #####:  632:      return 2;
        -:  633:    case outpost:
    #####:  634:      return 5;
        -:  635:    case salvager:
    #####:  636:      return 4;
        -:  637:    case sea_hag:
    #####:  638:      return 4;
        -:  639:    case treasure_map:
    #####:  640:      return 4;
        -:  641:    }
        -:  642:	
    #####:  643:  return -1;
        -:  644:}
        -:  645:
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  646:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  647:{
        -:  648:  int i;
        -:  649:  int j;
        -:  650:  int k;
        -:  651:  int x;
        -:  652:  int index;
    #####:  653:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  654:  int nextPlayer = currentPlayer + 1;
        -:  655:
    #####:  656:  int tributeRevealedCards[2] = {-1, -1};
        -:  657:  int temphand[MAX_HAND];// moved above the if statement
    #####:  658:  int drawntreasure=0;
        -:  659:  int cardDrawn;
    #####:  660:  int z = 0;// this is the counter for the temp hand
    #####:  661:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  662:    nextPlayer = 0;
        -:  663:  }
        -:  664:  
        -:  665:	
        -:  666:  //uses switch to select card and perform actions
    #####:  667:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  668:    {
        -:  669:    case adventurer:
        -:  670:    	//Previous content replaced with call to refactored function
    #####:  671:	return playAdventurer(state, currentPlayer);
call    0 never executed
        -:  672:			
        -:  673:    case council_room:
        -:  674:	//Previous content replaced with call to refactored function 
    #####:  675:	return playCouncil_Room(currentPlayer, state, handPos);
call    0 never executed
        -:  676:	
        -:  677:    case feast:
    #####:  678:	return playFeast(state, choice1);  
call    0 never executed
        -:  679:			
        -:  680:    case gardens:
    #####:  681:      return -1;
        -:  682:			
        -:  683:    case mine:
    #####:  684:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  685:
    #####:  686:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  687:	{
    #####:  688:	  return -1;
        -:  689:	}
        -:  690:		
    #####:  691:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  692:	{
    #####:  693:	  return -1;
        -:  694:	}
        -:  695:
    #####:  696:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  697:	{
    #####:  698:	  return -1;
        -:  699:	}
        -:  700:
    #####:  701:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  702:
        -:  703:      //discard card from hand
    #####:  704:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  705:
        -:  706:      //discard trashed card
    #####:  707:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  708:	{
    #####:  709:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  710:	    {
    #####:  711:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  712:	      break;
        -:  713:	    }
        -:  714:	}
        -:  715:			
    #####:  716:      return 0;
        -:  717:			
        -:  718:    case remodel:
    #####:  719:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  720:
    #####:  721:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  722:	{
    #####:  723:	  return -1;
        -:  724:	}
        -:  725:
    #####:  726:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  727:
        -:  728:      //discard card from hand
    #####:  729:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  730:
        -:  731:      //discard trashed card
    #####:  732:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  733:	{
    #####:  734:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  735:	    {
    #####:  736:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  737:	      break;
        -:  738:	    }
        -:  739:	}
        -:  740:
        -:  741:
    #####:  742:      return 0;
        -:  743:		
        -:  744:    case smithy:
    #####:  745:    	 return playSmithy(currentPlayer, state, handPos);;
call    0 never executed
        -:  746:		
        -:  747:    case village:
    #####:  748:    	return playVillage(currentPlayer, state, handPos);
call    0 never executed
        -:  749:		
        -:  750:    case baron:
    #####:  751:      state->numBuys++;//Increase buys by 1!
    #####:  752:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  753:	int p = 0;//Iterator for hand!
    #####:  754:	int card_not_discarded = 1;//Flag for discard set!
    #####:  755:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####:  756:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  757:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  758:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  759:	    state->discardCount[currentPlayer]++;
    #####:  760:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####:  761:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  762:	    }
    #####:  763:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  764:	    state->handCount[currentPlayer]--;
    #####:  765:	    card_not_discarded = 0;//Exit the loop
        -:  766:	  }
    #####:  767:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -:  768:	    if(DEBUG) {
        -:  769:	      printf("No estate cards in your hand, invalid choice\n");
        -:  770:	      printf("Must gain an estate if there are any\n");
        -:  771:	    }
    #####:  772:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  773:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  774:	      state->supplyCount[estate]--;//Decrement estates
    #####:  775:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  776:		isGameOver(state);
call    0 never executed
        -:  777:	      }
        -:  778:	    }
    #####:  779:	    card_not_discarded = 0;//Exit the loop
        -:  780:	  }
        -:  781:			    
        -:  782:	  else{
    #####:  783:	    p++;//Next card
        -:  784:	  }
        -:  785:	}
        -:  786:      }
        -:  787:			    
        -:  788:      else{
    #####:  789:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  790:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  791:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  792:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  793:	    isGameOver(state);
call    0 never executed
        -:  794:	  }
        -:  795:	}
        -:  796:      }
        -:  797:	    
        -:  798:      
    #####:  799:      return 0;
        -:  800:		
        -:  801:    case great_hall:
        -:  802:      //+1 Card
    #####:  803:      drawCard(currentPlayer, state);
call    0 never executed
        -:  804:			
        -:  805:      //+1 Actions
    #####:  806:      state->numActions++;
        -:  807:			
        -:  808:      //discard card from hand
    #####:  809:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  810:      return 0;
        -:  811:		
        -:  812:    case minion:
        -:  813:      //+1 action
    #####:  814:      state->numActions++;
        -:  815:			
        -:  816:      //discard card from hand
    #####:  817:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  818:			
    #####:  819:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  820:	{
    #####:  821:	  state->coins = state->coins + 2;
        -:  822:	}
        -:  823:			
    #####:  824:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  825:	{
        -:  826:	  //discard hand
    #####:  827:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  828:	    {
    #####:  829:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  830:	    }
        -:  831:				
        -:  832:	  //draw 4
    #####:  833:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  834:	    {
    #####:  835:	      drawCard(currentPlayer, state);
call    0 never executed
        -:  836:	    }
        -:  837:				
        -:  838:	  //other players discard hand and redraw if hand size > 4
    #####:  839:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  840:	    {
    #####:  841:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:  842:		{
    #####:  843:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -:  844:		    {
        -:  845:		      //discard hand
    #####:  846:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -:  847:			{
    #####:  848:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -:  849:			}
        -:  850:							
        -:  851:		      //draw 4
    #####:  852:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -:  853:			{
    #####:  854:			  drawCard(i, state);
call    0 never executed
        -:  855:			}
        -:  856:		    }
        -:  857:		}
        -:  858:	    }
        -:  859:				
        -:  860:	}
    #####:  861:      return 0;
        -:  862:		
        -:  863:    case steward:
    #####:  864:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -:  865:	{
        -:  866:	  //+2 cards
    #####:  867:	  drawCard(currentPlayer, state);
call    0 never executed
    #####:  868:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  869:	}
    #####:  870:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -:  871:	{
        -:  872:	  //+2 coins
    #####:  873:	  state->coins = state->coins + 2;
        -:  874:	}
        -:  875:      else
        -:  876:	{
        -:  877:	  //trash 2 cards in hand
    #####:  878:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####:  879:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -:  880:	}
        -:  881:			
        -:  882:      //discard card from hand
    #####:  883:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  884:      return 0;
        -:  885:		
        -:  886:    case tribute:
    #####:  887:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####:  888:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####:  889:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  890:	  state->deckCount[nextPlayer]--;
        -:  891:	}
    #####:  892:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####:  893:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  894:	  state->discardCount[nextPlayer]--;
        -:  895:	}
        -:  896:	else{
        -:  897:	  //No Card to Reveal
        -:  898:	  if (DEBUG){
        -:  899:	    printf("No cards to reveal\n");
        -:  900:	  }
        -:  901:	}
        -:  902:      }
        -:  903:	    
        -:  904:      else{
    #####:  905:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####:  906:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  907:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  908:	    state->deckCount[nextPlayer]++;
    #####:  909:	    state->discard[nextPlayer][i] = -1;
    #####:  910:	    state->discardCount[nextPlayer]--;
        -:  911:	  }
        -:  912:			    
    #####:  913:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -:  914:	} 
    #####:  915:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  916:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  917:	state->deckCount[nextPlayer]--;
    #####:  918:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  919:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  920:	state->deckCount[nextPlayer]--;
        -:  921:      }    
        -:  922:		       
    #####:  923:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####:  924:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  925:	state->playedCardCount++;
    #####:  926:	tributeRevealedCards[1] = -1;
        -:  927:      }
        -:  928:
    #####:  929:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####:  930:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  931:	  state->coins += 2;
        -:  932:	}
        -:  933:		    
    #####:  934:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:  935:	  drawCard(currentPlayer, state);
call    0 never executed
    #####:  936:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  937:	}
        -:  938:	else{//Action Card
    #####:  939:	  state->numActions = state->numActions + 2;
        -:  940:	}
        -:  941:      }
        -:  942:	    
    #####:  943:      return 0;
        -:  944:		
        -:  945:    case ambassador:
    #####:  946:      j = 0;		//used to check if player has enough cards to discard
        -:  947:
    #####:  948:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  949:	{
    #####:  950:	  return -1;				
        -:  951:	}
        -:  952:
    #####:  953:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -:  954:	{
    #####:  955:	  return -1;
        -:  956:	}
        -:  957:
    #####:  958:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  959:	{
    #####:  960:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  961:	    {
    #####:  962:	      j++;
        -:  963:	    }
        -:  964:	}
    #####:  965:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -:  966:	{
    #####:  967:	  return -1;				
        -:  968:	}
        -:  969:
        -:  970:      if (DEBUG) 
        -:  971:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -:  972:
        -:  973:      //increase supply count for choosen card by amount being discarded
    #####:  974:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -:  975:			
        -:  976:      //each other player gains a copy of revealed card
    #####:  977:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  978:	{
    #####:  979:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:  980:	    {
    #####:  981:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -:  982:	    }
        -:  983:	}
        -:  984:
        -:  985:      //discard played card from hand
    #####:  986:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -:  987:
        -:  988:      //trash copies of cards returned to supply
    #####:  989:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -:  990:	{
    #####:  991:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  992:	    {
    #####:  993:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -:  994:		{
    #####:  995:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####:  996:		  break;
        -:  997:		}
        -:  998:	    }
        -:  999:	}			
        -: 1000:
    #####: 1001:      return 0;
        -: 1002:		
        -: 1003:    case cutpurse:
        -: 1004:
    #####: 1005:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1006:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1007:	{
    #####: 1008:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1009:	    {
    #####: 1010:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1011:		{
    #####: 1012:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1013:		    {
    #####: 1014:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1015:		      break;
        -: 1016:		    }
    #####: 1017:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1018:		    {
    #####: 1019:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1020:			{
        -: 1021:			  if (DEBUG)
        -: 1022:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1023:			}	
    #####: 1024:		      break;
        -: 1025:		    }		
        -: 1026:		}
        -: 1027:					
        -: 1028:	    }
        -: 1029:				
        -: 1030:	}				
        -: 1031:
        -: 1032:      //discard played card from hand
    #####: 1033:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1034:
    #####: 1035:      return 0;
        -: 1036:
        -: 1037:		
        -: 1038:    case embargo: 
        -: 1039:      //+2 Coins
    #####: 1040:      state->coins = state->coins + 2;
        -: 1041:			
        -: 1042:      //see if selected pile is in play
    #####: 1043:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -: 1044:	{
    #####: 1045:	  return -1;
        -: 1046:	}
        -: 1047:			
        -: 1048:      //add embargo token to selected supply pile
    #####: 1049:      state->embargoTokens[choice1]++;
        -: 1050:			
        -: 1051:      //trash card
    #####: 1052:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####: 1053:      return 0;
        -: 1054:		
        -: 1055:    case outpost:
        -: 1056:      //set outpost flag
    #####: 1057:      state->outpostPlayed++;
        -: 1058:			
        -: 1059:      //discard card
    #####: 1060:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1061:      return 0;
        -: 1062:		
        -: 1063:    case salvager:
        -: 1064:      //+1 buy
    #####: 1065:      state->numBuys++;
        -: 1066:			
    #####: 1067:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1068:	{
        -: 1069:	  //gain coins equal to trashed card
    #####: 1070:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1071:	  //trash card
    #####: 1072:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1073:	}
        -: 1074:			
        -: 1075:      //discard card
    #####: 1076:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1077:      return 0;
        -: 1078:		
        -: 1079:    case sea_hag:
    #####: 1080:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1081:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1082:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1083:	  state->discardCount[i]++;
    #####: 1084:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1085:	}
        -: 1086:      }
    #####: 1087:      return 0;
        -: 1088:		
        -: 1089:    case treasure_map:
        -: 1090:      //search hand for another treasure_map
    #####: 1091:      index = -1;
    #####: 1092:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1093:	{
    #####: 1094:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1095:	    {
    #####: 1096:	      index = i;
    #####: 1097:	      break;
        -: 1098:	    }
        -: 1099:	}
    #####: 1100:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1101:	{
        -: 1102:	  //trash both treasure cards
    #####: 1103:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1104:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1105:
        -: 1106:	  //gain 4 Gold cards
    #####: 1107:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1108:	    {
    #####: 1109:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1110:	    }
        -: 1111:				
        -: 1112:	  //return success
    #####: 1113:	  return 1;
        -: 1114:	}
        -: 1115:			
        -: 1116:      //no second treasure_map found in hand
    #####: 1117:      return -1;
        -: 1118:    }
        -: 1119:	
    #####: 1120:  return -1;
        -: 1121:}
        -: 1122:
function discardCard called 1000 returned 100% blocks executed 78%
     1000: 1123:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1124:{
        -: 1125:	
        -: 1126:  //if card is not trashed, added to Played pile 
     1000: 1127:  if (trashFlag < 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1128:    {
        -: 1129:      //add card to played pile
     1000: 1130:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
     1000: 1131:      state->playedCardCount++;
        -: 1132:    }
        -: 1133:	
        -: 1134:  //set played card to -1
     1000: 1135:  state->hand[currentPlayer][handPos] = -1;
        -: 1136:	
        -: 1137:  //remove card from player's hand
     1000: 1138:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1139:    {
        -: 1140:      //reduce number of cards in hand
    #####: 1141:      state->handCount[currentPlayer]--;
        -: 1142:    }
     1000: 1143:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1144:    {
        -: 1145:      //reduce number of cards in hand
    #####: 1146:      state->handCount[currentPlayer]--;
        -: 1147:    }
        -: 1148:  else 	
        -: 1149:    {
        -: 1150:      //replace discarded card with last card in hand
     1000: 1151:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1152:      //set last card to -1
     1000: 1153:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1154:      //reduce number of cards in hand
     1000: 1155:      state->handCount[currentPlayer]--;
        -: 1156:    }
        -: 1157:	
     1000: 1158:  return 0;
        -: 1159:}
        -: 1160:
function gainCard called 0 returned 0% blocks executed 0%
    #####: 1161:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1162:{
        -: 1163:  //Note: supplyPos is enum of choosen card
        -: 1164:	
        -: 1165:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1166:  if ( supplyCount(supplyPos, state) < 1 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1167:    {
    #####: 1168:      return -1;
        -: 1169:    }
        -: 1170:	
        -: 1171:  //added card for [whoseTurn] current player:
        -: 1172:  // toFlag = 0 : add to discard
        -: 1173:  // toFlag = 1 : add to deck
        -: 1174:  // toFlag = 2 : add to hand
        -: 1175:
    #####: 1176:  if (toFlag == 1)
branch  0 never executed
branch  1 never executed
        -: 1177:    {
    #####: 1178:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1179:      state->deckCount[player]++;
        -: 1180:    }
    #####: 1181:  else if (toFlag == 2)
branch  0 never executed
branch  1 never executed
        -: 1182:    {
    #####: 1183:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1184:      state->handCount[player]++;
        -: 1185:    }
        -: 1186:  else
        -: 1187:    {
    #####: 1188:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1189:      state->discardCount[player]++;
        -: 1190:    }
        -: 1191:	
        -: 1192:  //decrease number in supply pile
    #####: 1193:  state->supplyCount[supplyPos]--;
        -: 1194:	 
    #####: 1195:  return 0;
        -: 1196:}
        -: 1197:
function updateCoins called 1000 returned 100% blocks executed 82%
     1000: 1198:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1199:{
        -: 1200:  int i;
        -: 1201:	
        -: 1202:  //reset coin count
     1000: 1203:  state->coins = 0;
        -: 1204:
        -: 1205:  //add coins for each Treasure card in player's hand
     6000: 1206:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -: 1207:    {
     5000: 1208:      if (state->hand[player][i] == copper)
branch  0 taken 70% (fallthrough)
branch  1 taken 30%
        -: 1209:	{
     3484: 1210:	  state->coins += 1;
        -: 1211:	}
     1516: 1212:      else if (state->hand[player][i] == silver)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1213:	{
    #####: 1214:	  state->coins += 2;
        -: 1215:	}
     1516: 1216:      else if (state->hand[player][i] == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1217:	{
    #####: 1218:	  state->coins += 3;
        -: 1219:	}	
        -: 1220:    }	
        -: 1221:
        -: 1222:  //add bonus
     1000: 1223:  state->coins += bonus;
        -: 1224:
     1000: 1225:  return 0;
        -: 1226:}
        -: 1227:
        -: 1228://Below is the refactored portion
function playAdventurer called 0 returned 0% blocks executed 0%
    #####: 1229:int playAdventurer(struct gameState *state, int currentPlayer){
        -: 1230:	//Get the integer of player whose turn it is now	
        -: 1231:	//int currentPlayer = whoseTurn(state);
        -: 1232:	//Create variables for temp hand, last drawn card, and drawn treasure
    #####: 1233:	int z = 0;
        -: 1234:	int cardDrawn;	
        -: 1235:	int temphand[MAX_HAND];
    #####: 1236:	int drawntreasure = 1;
        -: 1237:	//Move the body of adventurer from Card Effects under variable declaration and initialization
    #####: 1238:	while(drawntreasure < 2){
branch  0 never executed
branch  1 never executed
    #####: 1239:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 never executed
branch  1 never executed
    #####: 1240:			shuffle(currentPlayer, state);
call    0 never executed
        -: 1241:		}
    #####: 1242:		drawCard(currentPlayer, state);
call    0 never executed
    #####: 1243:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####: 1244:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1245:			drawntreasure++;
        -: 1246:		else{
    #####: 1247:			temphand[z]=cardDrawn;
    #####: 1248:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1249:			z++;
        -: 1250:		}
        -: 1251:    }
    #####: 1252:    while(z-1>=0){
branch  0 never executed
branch  1 never executed
    #####: 1253:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####: 1254:		z=z-1;
        -: 1255:     }
    #####: 1256:     return 0;
        -: 1257:}
        -: 1258:
function playSmithy called 0 returned 0% blocks executed 0%
    #####: 1259:int playSmithy(int currentPlayer, struct gameState *state, int handPos){
        -: 1260:  //Get the integer of player whose turn it is now
        -: 1261:  //int currentPlayer = whoseTurn(state);
        -: 1262:  int i;
        -: 1263:  //Move the body of smithy from Card Effects under variable declaration and initialization
    #####: 1264:  for (i = 0; i <= 4; i++){
branch  0 never executed
branch  1 never executed
    #####: 1265:      drawCard(currentPlayer, state);
call    0 never executed
        -: 1266:  }
        -: 1267:  
        -: 1268:  //discard card from hand
    #####: 1269:  discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1270:  return 0;
        -: 1271:}
        -: 1272:
        -: 1273:
function playVillage called 1000 returned 100% blocks executed 100%
     1000: 1274:int playVillage(int currentPlayer, struct gameState *state, int handPos){
        -: 1275:	 //Get the integer of player whose turn it is now
        -: 1276:	// int currentPlayer = whoseTurn(state);
        -: 1277:	 //Move the body of village from Card Effects under variable declaration and initialization
        -: 1278:	 //+1 Card
     1000: 1279:     drawCard(currentPlayer, state);
call    0 returned 100%
        -: 1280:	 //+2 Actions
     1000: 1281:     state->numActions = state->numActions + 3;
        -: 1282:	 //discard played card from hand
     1000: 1283:     discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
     1000: 1284:     return 0;
        -: 1285:}
        -: 1286:
function playFeast called 0 returned 0% blocks executed 0%
    #####: 1287:int playFeast(struct gameState *state, int choice1){
        -: 1288:	//Get the integer of player whose turn it is now
    #####: 1289:    int currentPlayer = whoseTurn(state);
call    0 never executed
        -: 1290:	int i, x;
        -: 1291:	int temphand[MAX_HAND];
        -: 1292:	//gain card with cost up to 5
        -: 1293:	//Backup hand
    #####: 1294:	for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1295:		temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####: 1296:		state->hand[currentPlayer][i] = -1;//Set to nothing
        -: 1297:	}
        -: 1298:	//Backup hand
        -: 1299:
        -: 1300:	//Update Coins for Buy
    #####: 1301:	updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####: 1302:	x = 1;//Condition to loop on
    #####: 1303:	while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####: 1304:		if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1305:			if (DEBUG) printf("None of that card left, sorry!\n");
        -: 1306:			if (DEBUG) printf("Cards Left: %d\n", supplyCount(choice1, state));
        -: 1307:		}
    #####: 1308:		else if (state->coins <= getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1309:			printf("That card is too expensive!\n");
call    0 never executed
        -: 1310:			if (DEBUG) printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -: 1311:		}
        -: 1312:		else{
        -: 1313:			if (DEBUG) printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -: 1314:
    #####: 1315:			gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####: 1316:			x = 0;//No more buying cards
        -: 1317:
        -: 1318:			if (DEBUG)printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -: 1319:
        -: 1320:		}
        -: 1321:	}     
        -: 1322:
        -: 1323:	//Reset Hand
    #####: 1324:	for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1325:		state->hand[currentPlayer][i] = temphand[i];
    #####: 1326:		temphand[i] = -1;
        -: 1327:	}
        -: 1328:	//Reset Hand
    #####: 1329:	return 0;
        -: 1330:}
        -: 1331:
function playCouncil_Room called 0 returned 0% blocks executed 0%
    #####: 1332:int playCouncil_Room(int currentPlayer, struct gameState *state, int handPos){
        -: 1333:	//Get the integer of player whose turn it is now
        -: 1334:	int i;
        -: 1335:	//+4 Cards
    #####: 1336:    for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1337:	{
    #####: 1338:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1339:	}
        -: 1340:			
        -: 1341:    //+1 Buy
    #####: 1342:    state->numBuys++;
        -: 1343:			
        -: 1344:    //Each other player draws a card
    #####: 1345:    for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1346:	{
    #####: 1347:	  if ( i == currentPlayer )
branch  0 never executed
branch  1 never executed
        -: 1348:	    {
    #####: 1349:	      drawCard(i, state);
call    0 never executed
        -: 1350:	    }
        -: 1351:	}
        -: 1352:			
        -: 1353:    //put played card in played card pile
    #####: 1354:    discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1355:	
    #####: 1356:	return 0;
        -: 1357:}
        -: 1358:
        -: 1359://end of dominion.c
        -: 1360:
File 'randomtestcard.c'
Lines executed:84.09% of 88
Branches executed:100.00% of 60
Taken at least once:76.67% of 60
Calls executed:100.00% of 18
Creating 'randomtestcard.c.gcov'

        -:    0:Source:randomtestcard.c
        -:    0:Graph:randomtestcard.gcno
        -:    0:Data:randomtestcard.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* Random Test for Village
        -:    2:   Previous game state: playing 2-4 player Dominion game, Village card is played
        -:    3:   Tests will cover:
        -:    4:   - if hand count was unaltered
        -:    5:   - if deck count is decreased by 1
        -:    6:   - if number actions increased by 2
        -:    7:   - if village card is discarded
        -:    8:   - if next card is moved to the hand
        -:    9:   - if village remains in hand after playing
        -:   10:      - other player has no game state change 
        -:   11:		- same deck count
        -:   12:		- same hand count
        -:   13:		- same discard count	
        -:   14:		- same cards in hand
        -:   15:		- same cards in deck
        -:   16:		- same cards in discard
        -:   17:	- no game state change	
        -:   18:		- same players
        -:   19:		- same supply count for each card
        -:   20:		- same embargo token count for each card
        -:   21:		- same outposed played 
        -:   22:		- same outpost turn
        -:   23:		- same whose turn
        -:   24:		- same phase
        -:   25:		- same number of actions
        -:   26:		- same number buys
        -:   27:*/
        -:   28:#include "dominion.h"
        -:   29:#include "dominion_helpers.h"
        -:   30:#include "rngs.h"
        -:   31:#include <math.h>
        -:   32:#include <time.h>
        -:   33:#include <stdio.h>
        -:   34:#include <string.h>
        -:   35:#include <assert.h>
        -:   36:
        -:   37:#define NOISY_TEST 0
        -:   38:
        -:   39:int cardExists(int turn, struct gameState *state, int target);
        -:   40:
function main called 1 returned 100% blocks executed 84%
        1:   41:int main()
        -:   42:{
        -:   43:    int startgame, turn, i, j, r, p, x, pos, card, diff;
        1:   44:    int players = 2;
        1:   45:    int seed = rand();
call    0 returned 100%
        1:   46:    int kingdomCards[10] = { gardens, adventurer, council_room, baron, mine, remodel, feast, smithy, village, great_hall };
        -:   47:	struct gameState previous;
        -:   48:	struct gameState post; 
        1:   49:    int testruns = 1000; 
        1:   50:    int finalfail = 0;
        1:   51:	srand(time(NULL));
call    0 returned 100%
call    1 returned 100%
        -:   52:	/* Looping through amount of test runs */
     1001:   53:    for (i = 0; i < testruns; i++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
     1000:   54:        printf("Test %d\n", i);
call    0 returned 100%
     1000:   55:	    seed = rand();
call    0 returned 100%
     1000:   56:		players = ( rand() % 3 ) + 2;
call    0 returned 100%
        -:   57:		/* Start with a new game */
     1000:   58:		memset(&previous, 23, sizeof(struct gameState));   
     1000:   59:        startgame = initializeGame(players, kingdomCards, seed, &previous); 
call    0 returned 100%
        -:   60:		/* Total number of cards in deck and discard should be less than MAXDECK and hand should be less than MAXHAND from better card draw.c */
     3954:   61:		for (turn = 0; turn < players; turn++){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
     2954:   62:			previous.deckCount[turn] = floor(Random() * MAX_DECK);
call    0 returned 100%
     2954:   63:            previous.discardCount[turn] = floor(Random() * MAX_DECK);
call    0 returned 100%
     2954:   64:            previous.handCount[turn] = floor(Random() * MAX_HAND);
call    0 returned 100%
        -:   65:			/* Select random cards for deck, discard and hand */
   738399:   66:            for ( j = 0; j < previous.deckCount[turn]; j++ ){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
   735445:   67:                previous.deck[turn][j] = floor( Random() *treasure_map );
call    0 returned 100%
        -:   68:            }
   740491:   69:            for ( j = 0; j < previous.discardCount[turn]; j++ ){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
   737537:   70:                previous.discard[turn][j] = floor( Random() *treasure_map );
call    0 returned 100%
        -:   71:            }
   738113:   72:            for ( j = 0; j < previous.handCount[turn]; j++ ){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
   735159:   73:                previous.hand[turn][j] = floor( Random() *treasure_map );
call    0 returned 100%
        -:   74:            }
        -:   75:			/* Make sure village is in the player hand */
     2954:   76:            int villagerexist = -1;
    74713:   77:            for ( j = 0; j < previous.handCount[turn]; j++ ){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
    74545:   78:                card = previous.hand[turn][j];
    74545:   79:                if ( card == village ){
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
     2786:   80:                    villagerexist = j;
     2786:   81:					break;
        -:   82:                }
        -:   83:            }
        -:   84:			/* If its not in the hand put it in the hand in a random position */
     2954:   85:            if ( villagerexist == -1 ){
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
      168:   86:                pos = floor( Random() * previous.handCount[turn] );
call    0 returned 100%
      168:   87:                previous.hand[turn][pos] = village;
        -:   88:            }
        -:   89:		}
        -:   90:		/* Selct random player, make a copy of GS to run test on, player adventure card */
     1000:   91:		turn = rand() % players; 
call    0 returned 100%
     1000:   92:		int tmp2 = previous.deckCount[turn];
     1000:   93:		int tmp4 = previous.handCount[turn];
     1000:   94:		int expNumAct = 0;
     1000:   95:		int newcard = 0;
     1000:   96:        memcpy( &post, &previous, sizeof(struct gameState)); 
     1000:   97:        playVillage(turn, &post, 0);
call    0 returned 100%
        -:   98:#if (NOISY_TEST == 1)			
        -:   99:		printf("\nTesting if hand count was unaltered\n");
        -:  100:#endif
        -:  101:		/* When village is played, it adds a card to the players hand but also discards the village */               
     1000:  102:		if ( tmp4 != post.handCount[turn])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  103:		{
    #####:  104:			finalfail++;
        -:  105:		}
        -:  106:#if (NOISY_TEST == 1)
        -:  107:		if ( tmp4 != post.handCount[turn])
        -:  108:		{
        -:  109:			printf("Test Result: Fail. actual handCount: %d, expected handCount: %d\r\n", tmp4, post.handCount[turn] );	
        -:  110:		}
        -:  111:		printf("\nTesting if deck count is decreased by 1\n");			
        -:  112:#endif   
        -:  113:		/* When village is played, it adds a card to the players hand which is taken off the deck */
     1000:  114:		if( ( tmp2 - 1 ) != post.deckCount[turn] )
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  115:		{
        2:  116:			finalfail++;  
        -:  117:		}
        -:  118:#if (NOISY_TEST == 1)
        -:  119:		if ( ( tmp2 - 1 ) != post.deckCount[turn] )
        -:  120:		{
        -:  121:			printf("Test Result: Fail. actual deckCount: %d, expected deckCount: %d\r\n", post.deckCount[turn], ( tmp2 - 1 ) );
        -:  122:
        -:  123:		}
        -:  124:		printf("\nTesting if number actions increased by 2\n");			
        -:  125:#endif   
        -:  126:        /* When playing village, num of actions should increase by 2 for a pass */
     1000:  127:		expNumAct = previous.numActions + 2;
     1000:  128:		if ( expNumAct != post.numActions )
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  129:		{
     1000:  130:			finalfail++;
        -:  131:		}
        -:  132:#if (NOISY_TEST == 1)
        -:  133:        if ( expNumAct != post.numActions )
        -:  134:		{
        -:  135:			printf("Number actions test failed\n");
        -:  136:			printf("Test Result: actual number actions: %d, expected number actions: %d\r\n", post.numActions, expNumAct );   
        -:  137:		}
        -:  138:		printf("\nTesting if village card is discarded\n");	
        -:  139:#endif
        -:  140:        /* Village card should be discarded after playing so it should be at the top of the discard pile */ 
     1000:  141:        if( post.playedCards[post.playedCardCount - 1] != village )
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
        -:  142:		{
      956:  143:			finalfail++;  
        -:  144:		}
        -:  145:#if (NOISY_TEST == 1)
        -:  146:        if ( post.playedCards[post.playedCardCount - 1] != village )
        -:  147:		{
        -:  148:			printf("Village discard test failed\n");
        -:  149:		}
        -:  150:		printf("\nTesting if village remains in hand after playing\n");
        -:  151:#endif           
        -:  152:		/* When village is played, it should leave hand  */ 
     1000:  153:        r = cardExists(turn, &post, village);
call    0 returned 100%
        -:  154:		/* If village is not in hand then it pass */
     1000:  155:        if ( r != -1 ) 
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:  156:        {
      989:  157:            finalfail++;
        -:  158:        }
        -:  159:#if (NOISY_TEST == 1)
        -:  160:        if (r != -1) 
        -:  161:        {
        -:  162:            printf("Test Result: Fail. Village still in hand after playing\r\n");
        -:  163:        }
        -:  164:		printf("\nTesting other player hasn't had his hand count alterned\n");			
        -:  165:#endif 
        -:  166:/* Current player's adventurer should not affect other play's game state */
     3954:  167:		for ( p = 0; p < players; p++ )
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  168:		{
     2954:  169:			if ( p != turn )
branch  0 taken 66% (fallthrough)
branch  1 taken 34%
        -:  170:			{
     1954:  171:				if( previous.handCount[p] != post.handCount[p] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  172:				{
    #####:  173:					finalfail++;  
        -:  174:				}
        -:  175:#if (NOISY_TEST == 1)
        -:  176:				if ( previous.handCount[p] != post.handCount[p]  )
        -:  177:				{
        -:  178:					printf("Test Result: Fail. Current player's playing Village changed other player's hand count\n");
        -:  179:					printf("Test Result: actual handCount: %d, expected handCount: %d\r\n", post.handCount[p],  previous.handCount[p]  );
        -:  180:				}
        -:  181:				printf("\nTesting other player hasn't had his deck count alterned\n");
        -:  182:#endif
     1954:  183:				if( previous.deckCount[p] != post.deckCount[p] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  184:				{
    #####:  185:					finalfail++;  
        -:  186:				}
        -:  187:#if (NOISY_TEST == 1)
        -:  188:				if ( previous.deckCount[p] != post.deckCount[p] )
        -:  189:				{
        -:  190:					printf("Test Result: Fail. Current player's playing Village changed other player's deck count\n");
        -:  191:					printf("Test Result: actual deckCount: %d, expected deckCount: %d\r\n", post.deckCount[p], previous.deckCount[p] );
        -:  192:				}
        -:  193:				printf("\nTesting other player hasn't had his discard count alterned\n");
        -:  194:#endif
     1954:  195:				if ( post.discardCount[p] != previous.discardCount[p] )            
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  196:				{
    #####:  197:					finalfail++;  
        -:  198:				}
        -:  199:#if (NOISY_TEST == 1)
        -:  200:				if ( post.discardCount[p] != previous.discardCount[p] )
        -:  201:				{
        -:  202:					printf("Test Result: Fail. Current player's playing Village changed other player's discard count\n");
        -:  203:					printf("Test Result: actual discardCount: %d, expected discardCount: %d\r\n", post.discardCount[p], previous.discardCount[p] );
        -:  204:				}
        -:  205:#endif
        -:  206:			}
        -:  207:		}
        -:  208:		/* Check game state hasn't changed */
        -:  209:#if (NOISY_TEST == 1)			
        -:  210:		printf("\nTesting general game state changes\n");
        -:  211:#endif
     1000:  212:		if ( post.numPlayers != previous.numPlayers )            
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  213:		{
    #####:  214:            finalfail++;  
        -:  215:		}
        -:  216:#if (NOISY_TEST == 1)
        -:  217:		if ( post.numPlayers != previous.numPlayers )
        -:  218:		{
        -:  219:			printf("Test Result: Fail. Number of players changed\n");
        -:  220:		}
        -:  221:#endif	
     1000:  222:		if ( post.outpostPlayed != previous.outpostPlayed )            
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  223:		{
    #####:  224:            finalfail++; 
        -:  225:		}				
        -:  226:#if (NOISY_TEST == 1)
        -:  227:		if ( post.outpostPlayed != previous.outpostPlayed )
        -:  228:		{
        -:  229:			printf("Test Result: Fail. Outpost played changed\n");
        -:  230:		}
        -:  231:#endif
     1000:  232:		if ( post.outpostTurn != previous.outpostTurn )            
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  233:		{
    #####:  234:            finalfail++; 
        -:  235:		}				
        -:  236:#if (NOISY_TEST == 1)
        -:  237:		if ( post.outpostTurn != previous.outpostTurn )
        -:  238:		{
        -:  239:			printf("Test Result: Fail. Outpost turn changed\n");
        -:  240:		}
        -:  241:#endif
     1000:  242:		if ( post.whoseTurn != previous.whoseTurn )            
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  243:		{
    #####:  244:            finalfail++;  
        -:  245:		}
        -:  246:#if (NOISY_TEST == 1)
        -:  247:		if ( post.whoseTurn != previous.whoseTurn )
        -:  248:		{
        -:  249:			printf("Test Result: Fail. Whose turn changed\n");
        -:  250:		}
        -:  251:#endif
     1000:  252:		if ( post.phase != previous.phase )            
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  253:		{
    #####:  254:            finalfail++;  
        -:  255:		}
        -:  256:#if (NOISY_TEST == 1)
        -:  257:		if ( post.phase != previous.phase )
        -:  258:		{
        -:  259:			printf("Test Result: Fail. Phase changed\n");
        -:  260:		}
        -:  261:#endif
     1000:  262:		if ( post.numBuys != previous.numBuys )            
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  263:		{
    #####:  264:            finalfail++;  
        -:  265:		}
        -:  266:#if (NOISY_TEST == 1)
        -:  267:		if ( post.numBuys != previous.numBuys )
        -:  268:		{
        -:  269:			printf("Test Result: Fail. Num buys changed\n");
        -:  270:		}
        -:  271:#endif
     1000:  272:		if (post.playedCardCount != previous.playedCardCount + 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  273:        {
    #####:  274:            diff = post.playedCardCount - previous.playedCardCount;
        -:  275:#if (NOISY_TEST == 1)
        -:  276:            printf("Test Result: Fail. playedCardCount did not increase by 1 instead by %d.\n", diff);
        -:  277:#endif
    #####:  278:			finalfail++; 
        -:  279:        }
        -:  280:#if (NOISY_TEST == 1)
        -:  281:		if ( post.numBuys != previous.numBuys )
        -:  282:		{
        -:  283:			printf("Test Result: Fail. Num buys changed\n");
        -:  284:		}
        -:  285:#endif
    28000:  286:		for ( x = 0; x < treasure_map + 1; x++ )    
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  287:		{
    27000:  288:			if ( post.supplyCount[x] != previous.supplyCount[x] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  289:			{
    #####:  290:				finalfail++; 
        -:  291:#if (NOISY_TEST == 1)
        -:  292:				printf("Test Result: Fail. Supply count changed for a card\n");
        -:  293:#endif
        -:  294:			}
    27000:  295:			if ( post.embargoTokens[x] != previous.embargoTokens[x] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  296:			{
    #####:  297:				finalfail++; 
        -:  298:#if (NOISY_TEST == 1)
        -:  299:				printf("Test Result: Fail. Embargo token changed for a card\n");
        -:  300:#endif
        -:  301:			}
        -:  302:		}
        -:  303:	}
        1:  304:    printf("Final tally for Random Test ( Village ):\nFail: %d\r\n", finalfail );
call    0 returned 100%
        1:  305:    return 0;
        -:  306:}
        -:  307:
        -:  308:
function cardExists called 1000 returned 100% blocks executed 100%
     1000:  309:int cardExists(int turn, struct gameState *state, int target){
     1000:  310:    int cardexists = -1;
     1000:  311:    int loopsize = state->handCount[turn];
        -:  312:	int i;
   250239:  313:    for (i = 0; i < loopsize; i++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  314:    {
   249239:  315:        if (state->hand[turn][i] == target)
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        -:  316:        {
     9637:  317:                 cardexists = i;
        -:  318:        }
        -:  319:    }
     1000:  320:    return cardexists;
        -:  321:}
