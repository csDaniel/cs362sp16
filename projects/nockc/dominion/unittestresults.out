
Test Result: Game passed to end when it should have - province empty

Test Result: Gamestate passed while testing for 0 province supply

Test Result: Game passed to end when it should have - 3 supply piles empty

Test Result: Gamestate passed while testing for three 0 supply piles

Test Result: Game passed to end when it should have - 3 supply piles second test

Test Result: Gamestate passed while testing for three 0 province supply

Test Result: Game passed to end when it should have - 3 supply piles second test

Test Result: Gamestate passed while testing for three 0 province supply

Test Result: Game passed to end when it should have - 3 supply piles second test

Test Result: Gamestate passed while testing for three 0 province supply

Test Result: Game passed to end when it should have - 3 supply piles second test

Test Result: Gamestate passed while testing for three 0 province supply

Test Result: Game passed to end when it should have - 3 supply piles second test

Test Result: Gamestate passed while testing for three 0 province supply

Test Result: Game passed to end when it should have - 3 supply piles second test

Test Result: Gamestate passed while testing for three 0 province supply

Test Result: Game passed to end when it should have - 3 supply piles second test

Test Result: Gamestate passed while testing for three 0 province supply

Test Result: Game passed to end when it should have - 3 supply piles second test

Test Result: Gamestate passed while testing for three 0 province supply

Test Result: Game passed to end when it should have - 3 supply piles second test

Test Result: Gamestate passed while testing for three 0 province supply

Test Result: Game passed to end when it should have - 3 supply piles second test

Test Result: Gamestate passed while testing for three 0 province supply

Test Result: Game passed to end when it should have - 3 supply piles second test

Test Result: Gamestate passed while testing for three 0 province supply

Test Result: Game passed to end when it should have - 3 supply piles second test

Test Result: Gamestate passed while testing for three 0 province supply

Test Result: Game passed to end when it should have - 3 supply piles second test

Test Result: Gamestate passed while testing for three 0 province supply

Test Result: Game passed to end when it should have - 3 supply piles second test

Test Result: Gamestate passed while testing for three 0 province supply

Test Result: Game passed to end when it should have - 3 supply piles second test

Test Result: Gamestate passed while testing for three 0 province supply

Test Result: Game passed to end when it should have - 3 supply piles second test

Test Result: Gamestate passed while testing for three 0 province supply

Test Result: Game passed to end when it should have - 3 supply piles second test

Test Result: Gamestate passed while testing for three 0 province supply

Test Result: Game passed to end when it should have - 3 supply piles second test

Test Result: Gamestate passed while testing for three 0 province supply

Test Result: Game passed to end when it should have - 3 supply piles second test

Test Result: Gamestate passed while testing for three 0 province supply

Test Result: Game passed to end when it should have - 3 supply piles second test

Test Result: Gamestate passed while testing for three 0 province supply

Test Result: Game passed to end when it should have - 3 supply piles second test

Test Result: Gamestate passed while testing for three 0 province supply

Test Result: Game passed to end when it should have - 3 supply piles second test

Test Result: Gamestate passed while testing for three 0 province supply

Test Result: Game failed to end when it should have - 3 supply piles including 25 empty

Test Result: Gamestate passed while testing for three 0 province supply

Test Result: Game failed to end when it should have - 3 supply piles including 26 empty

Test Result: Gamestate passed while testing for three 0 province supply
Final tally for Unit Test 1 (Game over):
Pass: 50
Failures: 2
File 'unittest1.c'
Lines executed:65.38% of 104
Branches executed:100.00% of 52
Taken at least once:65.38% of 52
Calls executed:45.45% of 33
Creating 'unittest1.c.gcov'

        -:    0:Source:unittest1.c
        -:    0:Graph:unittest1.gcno
        -:    0:Data:unittest1.gcda
        -:    0:Runs:8
        -:    0:Programs:1
        -:    1:/* Unit Test 1 for isGameOver 
        -:    2:   Tests for:
        -:    3:    - returns 1 if the supply of province becomes empty, 
        -:    4:    - returns 1 if the supply of three other cards becomes empty for all cards, 
        -:    5:    - gamestate remaining unchanged throughout all tests 
        -:    6:*/
        -:    7:#include "dominion.h"
        -:    8:#include "dominion_helpers.h"
        -:    9:#include "rngs.h"
        -:   10:#include <stdio.h>
        -:   11:#include <string.h>
        -:   12:#include <assert.h>
        -:   13:
        -:   14:int gamestatecheck(struct gameState *previous, struct gameState *post);
        -:   15:
function main called 8 returned 100% blocks executed 83%
        8:   16:int main()
        -:   17:{
        -:   18:    int turn;
        8:   19:    int players = 2;
        8:   20:    int seed = 1000;
        8:   21:    int kingdomCards[10] = { tribute, adventurer, council_room, baron, mine, remodel, feast, smithy, village, sea_hag };
        -:   22:	struct gameState previous; 
        -:   23:    struct gameState post; 
        -:   24:    int i;
        -:   25:	int r;
        8:   26:	int gameover1 = 0;
        8:   27:	int gameover2 = 0;
        8:   28:    int testruns = 1; 
        8:   29:    int finalfail = 0;
        8:   30:    int finalpass = 0;
        8:   31:	int supplycnt = 0;
        8:   32:	initializeGame(players, kingdomCards, seed, &post); 
call    0 returned 100%
      224:   33:	for( i = 0; i < treasure_map + 1; i++ )
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:   34:	{
      216:   35:        post.supplyCount[i] = -1;
        -:   36:    }
        -:   37:	/* As long as the provinces supply is > 0 game will not be overt */	
        8:   38:	post.supplyCount[province] = 0;
        8:   39:	memcpy(&previous, &post, sizeof(struct gameState));
        8:   40:	if( isGameOver(&post) != 1 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   41:	{
    #####:   42:        finalfail++;
    #####:   43:		printf("\nTest Result: Game failed to end when it should have - province empty\n");
call    0 never executed
        -:   44:    }
        -:   45:       else
        -:   46:     {
        8:   47:         finalpass++;
        8:   48:                printf("\nTest Result: Game passed to end when it should have - province empty\n");
call    0 returned 100%
        -:   49:     }  
        8:   50:	if ( gamestatecheck( &previous, &post ) == 0 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   51:    {
    #####:   52:        finalfail++;
    #####:   53:		printf("\nTest Result: Gamestate changed while testing for 0 province supply\n");
call    0 never executed
        -:   54:    }
        -:   55:    else
        -:   56:    {
        8:   57:        finalpass++;
        8:   58:        printf("\nTest Result: Gamestate passed while testing for 0 province supply\n");
call    0 returned 100%
        -:   59:    }
        -:   60:	/* Game also can be over if three piles of supplies are empty */
        8:   61:    post.supplyCount[province] = 1;
        8:   62:    post.supplyCount[0] = 0;
        8:   63:    post.supplyCount[1] = 0;
        8:   64:    post.supplyCount[2] = 0;
        8:   65:    memcpy(&previous, &post, sizeof(struct gameState));
        8:   66:    if( isGameOver(&post) != 1 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   67:	{
    #####:   68:        printf("\nTest Result: Game failed to end when it should have - 3 supply piles empty\n");
call    0 never executed
    #####:   69:        finalfail++;
        -:   70:    }
        -:   71:    else
        -:   72:     {
        8:   73:         finalpass++;
        8:   74:         printf("\nTest Result: Game passed to end when it should have - 3 supply piles empty\n");
call    0 returned 100%
        -:   75:     }
        8:   76:      if ( gamestatecheck( &previous, &post ) == 0 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   77:    {
    #####:   78:        finalfail++;
    #####:   79:                printf("\nTest Result: Gamestate changed while testing for three 0 supply piles\n");
call    0 never executed
        -:   80:    }
        -:   81:    else
        -:   82:    {
        8:   83:        finalpass++;
        8:   84:        printf("\nTest Result: Gamestate passed while testing for three 0 supply piles\n");
call    0 returned 100%
        -:   85:    }
        -:   86:
        -:   87:	/* Repeat above test on the other cards */
        8:   88:        post.supplyCount[2] = -1; //reset duchy chard to non empty
        -:   89:	 //then start from the province card
      200:   90:        for( r=province; r < treasure_map + 1; r++ )
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:   91:	{
      192:   92:		post.supplyCount[r] = 0;
      192:   93:		memcpy(&previous, &post, sizeof(struct gameState));
      192:   94:	        if( isGameOver(&post) != 1 )
call    0 returned 100%
branch  1 taken 8% (fallthrough)
branch  2 taken 92%
        -:   95:		{
       16:   96:                        finalfail++;
       16:   97:			printf("\nTest Result: Game failed to end when it should have - 3 supply piles including %d empty\n", r);
call    0 returned 100%
        -:   98:		}
        -:   99:                else
        -:  100:                {
      176:  101:                        finalpass++;
      176:  102:                        printf("\nTest Result: Game passed to end when it should have - 3 supply piles second test\n");
call    0 returned 100%
        -:  103:                }
        -:  104:
      192:  105:                if ( gamestatecheck( &previous, &post ) == 0 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  106:                 {
    #####:  107:			finalfail++;
    #####:  108:			printf("\nTest Result: Gamestate changed while testing for three 0 supply piles\n");
call    0 never executed
        -:  109:		}
        -:  110:                else
        -:  111:                {
      192:  112:                        finalpass++;
      192:  113:                        printf("\nTest Result: Gamestate passed while testing for three 0 province supply\n");
call    0 returned 100%
        -:  114:                }
        -:  115:
      192:  116:        post.supplyCount[r] = -1;
        -:  117:    }
        8:  118:   	printf("Final tally for Unit Test 1 (Game over):\nPass: %d\nFailures: %d\r\n", finalpass, finalfail );
call    0 returned 100%
        8:  119:    return 0;
        -:  120:}
        -:  121:
        -:  122:/* To check if a gamestate has changed, all elements must have the same values in previous and post state. Values tested are:
        -:  123: - treasure map
        -:  124: - embargo tokens
        -:  125: - supply count
        -:  126: - number player
        -:  127: - number actioons
        -:  128: - phase
        -:  129: - coins
        -:  130: - hand cards
        -:  131: - hand count
        -:  132: - deck cards
        -:  133: - deck count
        -:  134: - discard cards
        -:  135: = discard count */ 
function gamestatecheck called 208 returned 100% blocks executed 70%
      208:  136:int gamestatecheck(struct gameState *previous, struct gameState *post)
        -:  137:{
      208:  138:    int r = -1;
        -:  139:    int i, j;
     5616:  140:    for ( i = 0; i < treasure_map; i++ )
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  141:    {
     5408:  142:        if ( previous->supplyCount[i] != post->supplyCount[i] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  143:        {
    #####:  144:            r = 0;
    #####:  145:            printf("\nTest Result: Gamestate changed - supply count\n");
call    0 never executed
        -:  146:        }
        -:  147:    }
     5616:  148:	for ( i = 0; i < treasure_map; i++ )
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  149:    {
     5408:  150:        if ( previous->embargoTokens[i] != post->embargoTokens[i] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  151:        {
    #####:  152:            r = 0;
    #####:  153:            printf("\nTest Result: Gamestate changed - embargo\n");
call    0 never executed
        -:  154:        }
        -:  155:    }
      208:  156:    if ( previous->numPlayers != post->numPlayers )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  157:    {
    #####:  158:        r = 0;
    #####:  159:        printf("\nTest Result: Gamestate changed - player number\n");
call    0 never executed
        -:  160:    }
      208:  161:    if ( previous->numActions != post->numActions )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  162:    {
    #####:  163:        r = 0;
    #####:  164:        printf("\nTest Result: Gamestate changed - action number\n");
call    0 never executed
        -:  165:    }
      208:  166:    if ( previous->outpostPlayed != post->outpostPlayed )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  167:    {
    #####:  168:        r = 0;
    #####:  169:        printf("\nTest Result: Gamestate changed - outpost number\n");
call    0 never executed
        -:  170:    }
      208:  171:    if ( previous->phase != post->phase )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  172:    {
    #####:  173:        r = 0;
    #####:  174:        printf("\nTest Result: Gamestate changed - phase\n"); 
call    0 never executed
        -:  175:    }
      208:  176:    if ( previous->coins != post->coins )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  177:    {
    #####:  178:        r = 0;
    #####:  179:        printf("\nTest Result: Gamestate changed - coin number\n"); 
call    0 never executed
        -:  180:    }
   104208:  181:    for ( j = 0; j < MAX_HAND; j++ )
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  182:    {
   104000:  183:            if ( previous->hand[0][j] != post->hand[0][j] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  184:            {
    #####:  185:                r = 0;
    #####:  186:                printf("\nTest Result: Gamestate changed - hand cards\n"); 
call    0 never executed
        -:  187:            }
        -:  188:    }
      208:  189:    if ( previous->handCount[i] != post->handCount[i] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  190:    {
    #####:  191:        r = 0;
    #####:  192:        printf("\nTest Result: Gamestate changed - hand count\n");
call    0 never executed
        -:  193:      
        -:  194:    }
   104208:  195:    for ( j = 0; j < MAX_DECK; j++ )
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  196:    {
   104000:  197:        if ( previous->deck[0][j] != post->deck[0][j] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  198:        {
    #####:  199:            r = 0;
    #####:  200:            printf("\nTest Result: Gamestate changed - deck cards\n");
call    0 never executed
        -:  201:        }
        -:  202:    }
      208:  203:    if ( previous->deckCount[i] != post->deckCount[i] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  204:    {
    #####:  205:        r = 0;
    #####:  206:        printf("\nTest Result: Gamestate changed - deck count\n");
call    0 never executed
        -:  207:    }
   104208:  208:    for ( j = 0; j < MAX_DECK; j++ )
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  209:    {
   104000:  210:        if ( previous->discard[0][j] != post->discard[0][j] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  211:        {
    #####:  212:            r = 0;
    #####:  213:            printf("\nTest Result: Gamestate changed - discard pile\n");
call    0 never executed
        -:  214:        }
        -:  215:    }
      208:  216:    if ( previous->discardCount[i] != post->discardCount[i] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  217:    {
    #####:  218:        r = 0;
    #####:  219:          printf("\nTest Result: Gamestate changed - discard count\n");
call    0 never executed
        -:  220:    }   
      208:  221:    return r;
        -:  222:}

Player with 0 buys should not be able to buy cards

Test Result: Pass. Function returned -1 in case of player having 0 buys

Test Result: Gamestate passed while testing for player with no buys

Test Result: Pass. Function returned -1 in case of player having 0 buys

Test Result: Gamestate passed while testing for player with no buys

Test Result: Pass. Function returned -1 in case of player having 0 buys

Test Result: Gamestate passed while testing for player with no buys

Test Result: Pass. Function returned -1 in case of player having 0 buys

Test Result: Gamestate passed while testing for player with no buys

Test Result: Pass. Function returned -1 in case of player having 0 buys

Test Result: Gamestate passed while testing for player with no buys

Test Result: Pass. Function returned -1 in case of player having 0 buys

Test Result: Gamestate passed while testing for player with no buys

Test Result: Pass. Function returned -1 in case of player having 0 buys

Test Result: Gamestate passed while testing for player with no buys

Test Result: Pass. Function returned -1 in case of player having 0 buys

Test Result: Gamestate passed while testing for player with no buys

Test Result: Pass. Function returned -1 in case of player having 0 buys

Test Result: Gamestate passed while testing for player with no buys

Player should only be able to buy cards with a supply greater than 0

Test Result: Pass. Player isn't be allowed to buy unavailable card

Test Result: Gamestate passed while testing for buying card with no supply

Test Result: Pass. Player isn't be allowed to buy unavailable card

Test Result: Gamestate passed while testing for buying card with no supply

Test Result: Pass. Player isn't be allowed to buy unavailable card

Test Result: Gamestate passed while testing for buying card with no supply

Test Result: Pass. Player isn't be allowed to buy unavailable card

Test Result: Gamestate passed while testing for buying card with no supply

Test Result: Pass. Player isn't be allowed to buy unavailable card

Test Result: Gamestate passed while testing for buying card with no supply

Test Result: Pass. Player isn't be allowed to buy unavailable card

Test Result: Gamestate passed while testing for buying card with no supply

Test Result: Pass. Player isn't be allowed to buy unavailable card

Test Result: Gamestate passed while testing for buying card with no supply

Test Result: Pass. Player isn't be allowed to buy unavailable card

Test Result: Gamestate passed while testing for buying card with no supply

Test Result: Pass. Player isn't be allowed to buy unavailable card

Test Result: Gamestate passed while testing for buying card with no supply

Test Result: Pass. Player was able to buy an available card

Test Result: Pass. Player was able to buy an available card

Test Result: Pass. Player was able to buy an available card

Test Result: Pass. Player was able to buy an available card

Test Result: Pass. Player was able to buy an available card

Test Result: Pass. Player was able to buy an available card

Test Result: Pass. Player was able to buy an available card

Test Result: Pass. Player was able to buy an available card

Test Result: Pass. Player was able to buy an available card
Final tally for Unit Test 2 ( Buy Card ):
Pass: 45
Failures: 0
File 'unittest2.c'
Lines executed:61.70% of 94
Branches executed:100.00% of 52
Taken at least once:65.38% of 52
Calls executed:43.75% of 32
Creating 'unittest2.c.gcov'

        -:    0:Source:unittest2.c
        -:    0:Graph:unittest2.gcno
        -:    0:Data:unittest2.gcda
        -:    0:Runs:4
        -:    0:Programs:1
        -:    1:/* Unit Test 2 for buy Card
        -:    2:   Tests for:
        -:    3:    - not allowing user to buy a card when they have no buys, 
        -:    4:    - not allowing user to buy a card with 0 supply , 
        -:    5:	- allowing user to buy a available card when they have buys,
        -:    6:	- gamestate remaining unchanged throughout all tests 
        -:    7:*/
        -:    8:#include "dominion.h"
        -:    9:#include "dominion_helpers.h"
        -:   10:#include "rngs.h"
        -:   11:#include <stdio.h>
        -:   12:#include <string.h>
        -:   13:#include <assert.h>
        -:   14:
        -:   15:#define NOISY_TEST 1
        -:   16:
        -:   17:int gamestatecheck(struct gameState *previous, struct gameState *post);
        -:   18:
function main called 4 returned 100% blocks executed 86%
        4:   19:int main()
        -:   20:{
        -:   21:   
        4:   22:    int seed = 1000;
        4:   23:    int kingdomCards[10] = { tribute, adventurer, council_room, baron, mine, remodel, feast, smithy, village, sea_hag };
        -:   24:	struct gameState previous; 
        -:   25:    struct gameState post; 
        -:   26:    int i, j, r, h, p, b, x, z;
        4:   27:	int finalfail = 0;
        4:   28:    int finalpass = 0;
        4:   29:	initializeGame( 2, kingdomCards, seed, &post );
call    0 returned 100%
        4:   30:	memcpy( &previous, &post, sizeof(struct gameState) );
        -:   31:#if (NOISY_TEST)
        4:   32:			printf("\nPlayer with 0 buys should not be able to buy cards\n");
call    0 returned 100%
        -:   33:#endif
        -:   34:	/* If player has no buys, he should not be able to buy anything */
       40:   35:    for ( r = 0; r < 9; r++ )
branch  0 taken 90%
branch  1 taken 10% (fallthrough)
        -:   36:    {
       36:   37:        post.numBuys = 0;
       36:   38:        if (buyCard( kingdomCards[r], &post ) != -1 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   39:		{
    #####:   40:			finalfail++;
        -:   41:#if (NOISY_TEST)
    #####:   42:			printf("\nTest Result: Fail. Function did not return -1 in case of player having 0 buys\n");
call    0 never executed
        -:   43:#endif
        -:   44:		}
        -:   45:		else
        -:   46:		{
       36:   47:			finalpass++;
        -:   48:#if (NOISY_TEST)
       36:   49:			printf("\nTest Result: Pass. Function returned -1 in case of player having 0 buys\n");
call    0 returned 100%
        -:   50:#endif
        -:   51:		}
        -:   52:        /* Revert to previous state and make suer states are unchanged */
       36:   53:        post.numBuys = previous.numBuys;
       36:   54:        if ( gamestatecheck( &previous, &post ) == 0 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   55:		{
    #####:   56:			finalfail++;
        -:   57:#if (NOISY_TEST)		
    #####:   58:			printf("\nTest Result: Gamestate changed while testing for player with no buys\n");
call    0 never executed
        -:   59:#endif
        -:   60:		}
        -:   61:		else
        -:   62:		{
       36:   63:			finalpass++;
        -:   64:#if (NOISY_TEST)
       36:   65:			printf("\nTest Result: Gamestate passed while testing for player with no buys\n");
call    0 returned 100%
        -:   66:#endif
        -:   67:		}
        -:   68:    }
        -:   69:#if (NOISY_TEST)
        4:   70:			printf("\nPlayer should only be able to buy cards with a supply greater than 0\n");
call    0 returned 100%
        -:   71:#endif
        -:   72:	/* As long as a card is available (not empty upply) player should be able to buy it */
       40:   73:    for ( r = 0; r < 9; r++ )
branch  0 taken 90%
branch  1 taken 10% (fallthrough)
        -:   74:    {
       36:   75:        post.supplyCount[kingdomCards[r]] = 0;
       36:   76:        if ( buyCard( kingdomCards[r], &post ) != -1 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   77:        {
    #####:   78:			finalfail++;
        -:   79:#if (NOISY_TEST)
    #####:   80:			printf("\nTest Result: Fail. Player shouldn't be allowed to buy unavailable card\n");
call    0 never executed
        -:   81:#endif
        -:   82:        }
        -:   83:        else
        -:   84:        {
       36:   85:			finalpass++;
        -:   86:#if (NOISY_TEST)
       36:   87:			printf("\nTest Result: Pass. Player isn't be allowed to buy unavailable card\n");
call    0 returned 100%
        -:   88:#endif
        -:   89:        }
        -:   90:        /* Revert to previous state and make suer states are unchanged */
       36:   91:        post.supplyCount[kingdomCards[r]] = previous.supplyCount[kingdomCards[r]];
       36:   92:        if ( gamestatecheck( &previous, &post ) == 0 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   93:		{
    #####:   94:			finalfail++;
        -:   95:#if (NOISY_TEST)		
    #####:   96:			printf("\nTest Result: Gamestate changed while testing for buying card with no supply\n");
call    0 never executed
        -:   97:#endif
        -:   98:		}
        -:   99:		else
        -:  100:		{
       36:  101:			finalpass++;
        -:  102:#if (NOISY_TEST)
       36:  103:			printf("\nTest Result: Gamestate passed while testing for buying card with no supply\n");
call    0 returned 100%
        -:  104:#endif
        -:  105:		}
        -:  106:    }
       40:  107:	for ( x = 0; x < 9; x++ )
branch  0 taken 90%
branch  1 taken 10% (fallthrough)
        -:  108:    {
        -:  109:        //Ensure that player can buy card
       36:  110:        post.coins = 10;
       36:  111:        post.supplyCount[kingdomCards[x]] = 5;
       36:  112:        post.numBuys = 1;
        -:  113:                    
        -:  114:        //Save state of game before call to drawCard for comparison
       36:  115:        memcpy( &previous, &post, sizeof(struct gameState) );
        -:  116:                    
        -:  117:        //Test for general error in call to function
       36:  118:        if ( buyCard(kingdomCards[x], &post) == -1 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  119:        {
    #####:  120:			finalfail++;
        -:  121:#if (NOISY_TEST)
    #####:  122:			printf("\nTest Result: Fail. Player was not able to buy an available card\n");
call    0 never executed
        -:  123:#endif
        -:  124:        }
        -:  125:        else
        -:  126:        {
       36:  127:			finalpass++;
        -:  128:#if (NOISY_TEST)
       36:  129:			printf("\nTest Result: Pass. Player was able to buy an available card\n");
call    0 returned 100%
        -:  130:#endif
        -:  131:        } 
        -:  132:    } 
        4:  133:	printf("Final tally for Unit Test 2 ( Buy Card ):\nPass: %d\nFailures: %d\r\n", finalpass, finalfail );
call    0 returned 100%
        4:  134:    return 0;
        -:  135:}
        -:  136:
        -:  137:/* To check if a gamestate has changed, all elements must have the same values in previous and post state. Values tested are:
        -:  138: - treasure map
        -:  139: - embargo tokens
        -:  140: - supply count
        -:  141: - number player
        -:  142: - number actioons
        -:  143: - phase
        -:  144: - coins
        -:  145: - hand cards
        -:  146: - hand count
        -:  147: - deck cards
        -:  148: - deck count
        -:  149: - discard cards
        -:  150: = discard count */ 
function gamestatecheck called 72 returned 100% blocks executed 70%
       72:  151:int gamestatecheck(struct gameState *previous, struct gameState *post)
        -:  152:{
       72:  153:    int r = -1;
        -:  154:    int i, j;
     1944:  155:    for ( i = 0; i < treasure_map; i++ )
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  156:    {
     1872:  157:        if ( previous->supplyCount[i] != post->supplyCount[i] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  158:        {
    #####:  159:            r = 0;
    #####:  160:            printf("\nTest Result: Gamestate changed - supply count\n");
call    0 never executed
        -:  161:        }
        -:  162:    }
     1944:  163:	for ( i = 0; i < treasure_map; i++ )
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  164:    {
     1872:  165:        if ( previous->embargoTokens[i] != post->embargoTokens[i] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  166:        {
    #####:  167:            r = 0;
    #####:  168:            printf("\nTest Result: Gamestate changed - embargo\n");
call    0 never executed
        -:  169:        }
        -:  170:    }
       72:  171:    if ( previous->numPlayers != post->numPlayers )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  172:    {
    #####:  173:        r = 0;
    #####:  174:        printf("\nTest Result: Gamestate changed - player number\n");
call    0 never executed
        -:  175:    }
       72:  176:    if ( previous->numActions != post->numActions )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  177:    {
    #####:  178:        r = 0;
    #####:  179:        printf("\nTest Result: Gamestate changed - action number\n");
call    0 never executed
        -:  180:    }
       72:  181:    if ( previous->outpostPlayed != post->outpostPlayed )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  182:    {
    #####:  183:        r = 0;
    #####:  184:        printf("\nTest Result: Gamestate changed - outpost number\n");
call    0 never executed
        -:  185:    }
       72:  186:    if ( previous->phase != post->phase )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  187:    {
    #####:  188:        r = 0;
    #####:  189:        printf("\nTest Result: Gamestate changed - phase\n"); 
call    0 never executed
        -:  190:    }
       72:  191:    if ( previous->coins != post->coins )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  192:    {
    #####:  193:        r = 0;
    #####:  194:        printf("\nTest Result: Gamestate changed - coin number\n"); 
call    0 never executed
        -:  195:    }
    36072:  196:    for ( j = 0; j < MAX_HAND; j++ )
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  197:    {
    36000:  198:            if ( previous->hand[0][j] != post->hand[0][j] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  199:            {
    #####:  200:                r = 0;
    #####:  201:                printf("\nTest Result: Gamestate changed - hand cards\n"); 
call    0 never executed
        -:  202:            }
        -:  203:    }
       72:  204:    if ( previous->handCount[i] != post->handCount[i] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  205:    {
    #####:  206:        r = 0;
    #####:  207:        printf("\nTest Result: Gamestate changed - hand count\n");
call    0 never executed
        -:  208:      
        -:  209:    }
    36072:  210:    for ( j = 0; j < MAX_DECK; j++ )
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  211:    {
    36000:  212:        if ( previous->deck[0][j] != post->deck[0][j] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  213:        {
    #####:  214:            r = 0;
    #####:  215:            printf("\nTest Result: Gamestate changed - deck cards\n");
call    0 never executed
        -:  216:        }
        -:  217:    }
       72:  218:    if ( previous->deckCount[i] != post->deckCount[i] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  219:    {
    #####:  220:        r = 0;
    #####:  221:        printf("\nTest Result: Gamestate changed - deck count\n");
call    0 never executed
        -:  222:    }
    36072:  223:    for ( j = 0; j < MAX_DECK; j++ )
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  224:    {
    36000:  225:        if ( previous->discard[0][j] != post->discard[0][j] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  226:        {
    #####:  227:            r = 0;
    #####:  228:            printf("\nTest Result: Gamestate changed - discard pile\n");
call    0 never executed
        -:  229:        }
        -:  230:    }
       72:  231:    if ( previous->discardCount[i] != post->discardCount[i] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  232:    {
    #####:  233:        r = 0;
    #####:  234:          printf("\nTest Result: Gamestate changed - discard count\n");
call    0 never executed
        -:  235:    }   
       72:  236:    return r;
        -:  237:}
Final tally for Unit Test 3 ( Full Deck Count ):
Pass: 71874
Fail: 0
File 'unittest3.c'
Lines executed:95.35% of 43
Branches executed:100.00% of 18
Taken at least once:94.44% of 18
Calls executed:75.00% of 4
Creating 'unittest3.c.gcov'

        -:    0:Source:unittest3.c
        -:    0:Graph:unittest3.gcno
        -:    0:Data:unittest3.gcda
        -:    0:Runs:3
        -:    0:Programs:1
        -:    1:/* Card Test for fullDeckCount
        -:    2:   Previous game state: playing 2 player Dominion game, Council Room card is played
        -:    3:   Tests will cover:
        -:    4:   - count of cards in a player's hand
        -:    5:   - count of cards in a player's discard pile
        -:    6:   - count of cards in a player's deck
        -:    7:   - if sum of above accounts are correctly calculated
        -:    8:*/
        -:    9:#include "dominion.h"
        -:   10:#include "dominion_helpers.h"
        -:   11:#include "rngs.h"
        -:   12:#include <stdio.h>
        -:   13:#include <string.h>
        -:   14:#include <assert.h>
        -:   15:
        -:   16:#define NOISY_TEST 1
        -:   17:
function main called 3 returned 100% blocks executed 97%
        3:   18:int main()
        -:   19:{
        -:   20:    int startgame;
        -:   21:    int turn;
        3:   22:    int players = 2;
        3:   23:    int seed = 1000;
        3:   24:    int kingdomCards[10] = { gardens, adventurer, council_room, baron, mine, remodel, feast, smithy, village, great_hall };
        3:   25:	const char* domCards[] =  {"curse", "estate", "duchy", "province", "copper", "silver", "gold", "adventurer", "council_room", "feast",
        -:   26:        "gardens", "mine", "remodel", "smithy", "village", "baron", "great_hall", "minion", "steward", "tribute",
        -:   27:        "ambassador", "cutpurse", "embargo", "outpost", "salvager", "sea_hag", "treasure_map"};
        -:   28:	struct gameState previous; 
        -:   29:    struct gameState post;
        -:   30:	int i, j, r, h, d, t, td, th, p, b, x, z;
        3:   31:	int finalfail = 0;
        3:   32:    int finalpass = 0;
        -:   33:	int totalCount;
        -:   34:    int deck;
        -:   35:    int hand;
        -:   36:    int discard;
        3:   37:    int maxCards = 10; 
        -:   38:    int result;
        3:   39:    int testruns = 0; 
        3:   40:  	int tmp2 = 0;
        3:   41:	int tmp3 = 0;
        3:   42:	int tmp4 = 0;
        -:   43:	/* Testing fullDeckCount for 2 player with all possible combos of card number (card in deck, card in hand, and card in discard */
        9:   44:	for ( p = 0; p < 2; p++ )
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:   45:    {
        -:   46:        /* Tests cover all dominion cards */
      168:   47:		for ( r = 0; r <= 26; r++ ) 
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:   48:		{
        -:   49:            /* Tests cover discard piles of up to 10 cards */
     1944:   50:			for ( i = 0; i <= 10; i++ )
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
        -:   51:            {
        -:   52:                /* Tests cover hands of up to 10 cards */
    21384:   53:				for ( h = 0; h <= 10; h++ )
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
        -:   54:                {
        -:   55:                    /* Tests cover deck piles of up to 10 cards */
   235224:   56:					for ( d = 0; d <= 10; d++ )
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
        -:   57:                    {
        -:   58:                        /* Get the total number of cards in discard pile, hand pile and deck pile */
   215622:   59:						t = i + h + d;
        -:   60:						/* Make a deck pile for testing consisting of d cards */
   215622:   61:                        int td[d];
  1293732:   62:                        for (j = 0; j < d; j++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:   63:                        {
  1078110:   64:                            td[j] = r;
        -:   65:                        }
        -:   66:						/* Make a hand for testing consisting of h cards */
   215622:   67:                        int th[h];
  1293732:   68:                        for (j = 0; j < h; j++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:   69:                        {
  1078110:   70:                            th[j] = r;
        -:   71:                        }
        -:   72:						/* Make a discard pile for testing consisting of h cards */
   215622:   73:                        int z[i];
  1293732:   74:                        for (j = 0; j < i; j++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:   75:                        {
  1078110:   76:                            z[j] = r;
        -:   77:                        }
        -:   78:                        /* Play dominion with current h, d, i values */
   215622:   79:						memset( &post, 23, sizeof(struct gameState) );  
   215622:   80:                        initializeGame( 2, kingdomCards, seed, &post ); 
call    0 returned 100%
   215622:   81:                        post.handCount[p] = h;        
   215622:   82:                        post.deckCount[p] = d;        
   215622:   83:                        post.discardCount[p] = i;  
   215622:   84:                        memcpy( post.hand[p], th, sizeof(int) * h );
   215622:   85:                        memcpy( post.deck[p], td, sizeof(int) * d );
   215622:   86:                        memcpy( post.discard[p], z, sizeof(int) * i);
   215622:   87:                        result = fullDeckCount( p, r, &post );
call    0 returned 100%
   215622:   88:                        testruns++;
        -:   89:						/* test if the total number of cards is equal to what the full Deck Count returned for current game state */
   215622:   90:                        if ( t == result )
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   91:                        {
   215622:   92:                            finalpass++;
        -:   93:#if (NOISY_TEST == 1)
        -:   94://                              printf("\nTest Result: Pass. Total number of cards is equal to what the full Deck Count returned for %d cards ( %d in the deck, %d in the hand, and %d in the discard pile\r\n", p, t, d, h, i, domCards[r]);                           
        -:   95:#endif
        -:   96:                        }
        -:   97:                        else
        -:   98:                        {
    #####:   99:                            finalfail++;
        -:  100:#if (NOISY_TEST == 1)
    #####:  101:							printf("\nTest Result: Fail. Expected number of cards: % d Actual number of cards: %d\r\n", t, result);
call    0 never executed
        -:  102:#endif                        
        -:  103:						}
        -:  104:                    }
        -:  105:                }
        -:  106:            }
        -:  107:        }
        -:  108:	}
        3:  109:    printf("Final tally for Unit Test 3 ( Full Deck Count ):\nPass: %d\nFail: %d\r\n",finalpass, finalfail );
call    0 returned 100%
        3:  110:    return 0;
        -:  111:} 
Final tally for Unit Test 4 (Update Coins):
Pass: 662
Failures: 0
File 'unittest4.c'
Lines executed:90.74% of 54
Branches executed:100.00% of 18
Taken at least once:72.22% of 18
Calls executed:100.00% of 7
Creating 'unittest4.c.gcov'

        -:    0:Source:unittest4.c
        -:    0:Graph:unittest4.gcno
        -:    0:Data:unittest4.gcda
        -:    0:Runs:6
        -:    0:Programs:1
        -:    1:/* Unit Test 4 for updateCoins 
        -:    2:   Tests for:
        -:    3:    - correctly sums up the coin values for treasure cards and bonus (1 for copper, 2 for silver, 3 for gold), 
        -:    4:    - correctly returns a 0 for a hand with no coins and no bonus, 
        -:    5:	- correctly returns bonus for a hand with no coins and a bonus,
        -:    6:*/
        -:    7:#include "dominion.h"
        -:    8:#include "dominion_helpers.h"
        -:    9:#include "rngs.h"
        -:   10:#include <stdio.h>
        -:   11:#include <string.h>
        -:   12:#include <assert.h>
        -:   13:
        -:   14:#define NOISY_TEST 0
        -:   15:
        -:   16:int gamestatecheck(struct gameState *previous, struct gameState *post, int p);
        -:   17:
function main called 6 returned 100% blocks executed 86%
        6:   18:int main()
        -:   19:{
        -:   20:   
        6:   21:    int seed = 1000;
        6:   22:    int kingdomCards[10] = { tribute, adventurer, council_room, baron, mine, remodel, feast, smithy, village, sea_hag };
        -:   23:	struct gameState previous; 
        -:   24:    struct gameState post; 
        -:   25:    int i, j, r, h, p, b, x, z;
        6:   26:	int finalfail = 0;
        6:   27:    int finalpass = 0;
        -:   28:	int ran;
        -:   29:	int coppers[MAX_HAND];
        -:   30:    int silvers[MAX_HAND];
        -:   31:    int golds[MAX_HAND];
        -:   32:	int cards[MAX_HAND];
     3006:   33:    for ( i = 0; i < MAX_HAND; i++ ) 
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:   34:	{
     3000:   35:        coppers[i] = copper;
     3000:   36:        silvers[i] = silver;
     3000:   37:        golds[i] = gold;
        -:   38:	}
        -:   39:	/* Test every possible combination of players (1 to 2), treasure cards (1 - 10), and bonus values up to 10 */
       18:   40:	for ( p = 0; p < 2; p++ ) 
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:   41:	{
      132:   42:        for ( h = 1; h <= 10; h++ )  
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   43:		{
     1440:   44:            for ( b = 0; b <= 10; b++) 
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
        -:   45:			{
        -:   46:#if (NOISY_TEST == 1)				
        -:   47:				printf("Test player %d with %d treasure card(s) and %d bonus.\n", p, h, b );
        -:   48:#endif				
        -:   49:                /* Reset game state and start a new game for current combination */
     1320:   50:				memset(&post, 23, sizeof(struct gameState));
     1320:   51:                initializeGame( 2, kingdomCards, seed, &post ); 
call    0 returned 100%
        -:   52:				/* First test for a hand of coppers */
     1320:   53:				post.handCount[p] = h;                
     1320:   54:                memcpy( post.hand[p], coppers, sizeof(int) * h ); 
     1320:   55:                updateCoins( p, &post, b );
call    0 returned 100%
     1320:   56:				if ( post.coins != (h + b) )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   57:				{
        -:   58:#if (NOISY_TEST == 1)
        -:   59:					printf("Test Result: Fail. actual coin count: %d, expected coin count: %d\r\n", post.coins, (h + b) );
        -:   60:#endif	
    #####:   61:					finalfail++;
        -:   62:				}
        -:   63:				else 
        -:   64:				{
        -:   65:#if (NOISY_TEST == 1)
        -:   66:					printf("Test Result: Pass. actual coin count: %d, expected coin count: %d\r\n", post.coins, (h + b) );
        -:   67:#endif
     1320:   68:					finalpass++;
        -:   69:				}
        -:   70:				/* Next test for a hand of silvers */
     1320:   71:                memcpy( post.hand[p], silvers, sizeof(int) * h ); 
     1320:   72:                updateCoins( p, &post, b );
call    0 returned 100%
     1320:   73:				if ( post.coins != ( ( 2 * h ) + b) )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   74:				{
        -:   75:#if (NOISY_TEST == 1)
        -:   76:					printf("Test Result: Fail. actual coin count: %d, expected coin count: %d\r\n", post.coins, ( ( 2 * h ) + b) );
        -:   77:#endif	
    #####:   78:					finalfail++;
        -:   79:				}
        -:   80:				else 
        -:   81:				{
        -:   82:#if (NOISY_TEST == 1)
        -:   83:					printf("Test Result: Pass. actual coin count: %d, expected coin count: %d\r\n", post.coins, ( ( 2 * h ) + b) );
        -:   84:#endif
     1320:   85:					finalpass++;
        -:   86:				}
        -:   87:				/* Next test for a hand of golds */
     1320:   88:                memcpy( post.hand[p], golds, sizeof(int) * h ); 
     1320:   89:                updateCoins( p, &post, b );
call    0 returned 100%
     1320:   90:				if ( post.coins != ( ( 3 * h ) + b) )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   91:				{
        -:   92:#if (NOISY_TEST == 1)
        -:   93:					printf("Test Result: Fail. actual coin count: %d, expected coin count: %d\r\n", post.coins, ( ( 3 * h ) + b) );
        -:   94:#endif	
    #####:   95:					finalfail++;
        -:   96:				}
        -:   97:				else 
        -:   98:				{
        -:   99:#if (NOISY_TEST == 1)
        -:  100:					printf("Test Result: Pass. actual coin count: %d, expected coin count: %d\r\n", post.coins, ( ( 3 * h ) + b) );
        -:  101:#endif
     1320:  102:					finalpass++;
        -:  103:				}
        -:  104:			}
        -:  105:        }
        -:  106:    }
        -:  107:#if (NOISY_TEST == 1)	
        -:  108:	/* returns a 0 for a hand with no coins and no bonus */
        -:  109:	printf("Testing for a hand with no treasure cards and no bonus\n");
        -:  110:#endif
        6:  111:	b = 0;
        6:  112:	previous.hand[0][0] = kingdomCards[1];
        6:  113:	previous.hand[0][1] = kingdomCards[2];
        6:  114:	previous.hand[0][2] = kingdomCards[3];
        6:  115:	previous.hand[0][3] = kingdomCards[4];
        6:  116:	previous.hand[0][4] = kingdomCards[5];
        6:  117:	previous.hand[0][5] = kingdomCards[6];
        6:  118:	post.hand[0][0] = kingdomCards[1];
        6:  119:	post.hand[0][1] = kingdomCards[2];
        6:  120:	post.hand[0][2] = kingdomCards[3];
        6:  121:	post.hand[0][3] = kingdomCards[4];
        6:  122:	post.hand[0][4] = kingdomCards[5];
        6:  123:	post.hand[0][5] = kingdomCards[6];
        6:  124:	updateCoins( 0, &post, b ); 
call    0 returned 100%
        6:  125:	if ( post.coins != 0 )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  126:	{
        -:  127:#if (NOISY_TEST == 1)
        -:  128:		printf("Test Result: Fail. actual coin count: %d, expected coin count: 0\r\n", post.coins );
        -:  129:#endif	
    #####:  130:		finalfail++;
        -:  131:	}
        -:  132:	else 
        -:  133:	{
        -:  134:#if (NOISY_TEST == 1)
        -:  135:		printf("Test Result: Pass. actual coin count: %d, expected coin count: 0\r\n", post.coins );
        -:  136:#endif
        6:  137:		finalpass++;
        -:  138:	}	
        -:  139:	#if (NOISY_TEST == 1)	
        -:  140:	/* returns a 0 for a hand with no coins and no bonus */
        -:  141:	printf("Testing for a hand with no treasure cards and a bonus\n");
        -:  142:#endif
        6:  143:	b = 10;
        6:  144:	updateCoins( 0, &post, b ); 
call    0 returned 100%
        6:  145:	if ( post.coins != 10 )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  146:	{
        -:  147:#if (NOISY_TEST == 1)
        -:  148:		printf("Test Result: Fail. actual coin count: %d, expected coin count: 10\r\n", post.coins );
        -:  149:#endif	
    #####:  150:		finalfail++;
        -:  151:	}
        -:  152:	else 
        -:  153:	{
        -:  154:#if (NOISY_TEST == 1)
        -:  155:		printf("Test Result: Pass. actual coin count: %d, expected coin count: 10\r\n", post.coins );
        -:  156:#endif
        6:  157:		finalpass++;
        -:  158:	}
        6:  159:	printf("Final tally for Unit Test 4 (Update Coins):\nPass: %d\nFailures: %d\r\n", finalpass, finalfail );
call    0 returned 100%
        6:  160:    return 0;
        -:  161:}
        -:  162:
        -:  163:
        -:  164:
        -:  165:

Testing if hand count was increased by 2
Test Result: actual handCount: 5, expected handCount: 3

Testing if deck count was decreased by 3
Test Result: actual deckCount: 0, expected deckCount: 2

Testing if played card count was increased by 1
Test Result: actual playedCardCount = 1, expected playedCardCount = 1

Testing if Smithy is in played cards
Test Result: Pass. Smithy in the played cards

Testing if Smithy is still in hand
Test Result: Pass. Smithy not in the player's post state hand
Testing other player hasn't had his hand count alterned
Test Result: Pass. Current player's playing smithy did not affect other player's hand count
Test Result: actual handCount: 0, expected handCount: 0
Testing other player hasn't had his deck count alterned
Test Result: Pass. Current player's playing smithy did not affect other player's deck count
Test Result: actual deckCount: 10, expected deckCount: 10

Testing if hand count was increased by 2
Test Result: actual handCount: 5, expected handCount: 3

Testing if deck count was decreased by 3
Test Result: actual deckCount: 0, expected deckCount: 2

Testing if played card count was increased by 1
Test Result: actual playedCardCount = 1, expected playedCardCount = 1

Testing if Smithy is in played cards
Test Result: Pass. Smithy in the played cards

Testing if Smithy is still in hand
Test Result: Pass. Smithy not in the player's post state hand
Testing other player hasn't had his hand count alterned
Test Result: Pass. Current player's playing smithy did not affect other player's hand count
Test Result: actual handCount: 1, expected handCount: 1
Testing other player hasn't had his deck count alterned
Test Result: Pass. Current player's playing smithy did not affect other player's deck count
Test Result: actual deckCount: 5, expected deckCount: 5
Final tally for Card Test 1 ( Smithy ):
Pass: 10
Fail: 4
File 'cardtest1.c'
Lines executed:84.95% of 93
Branches executed:100.00% of 40
Taken at least once:65.00% of 40
Calls executed:77.78% of 27
Creating 'cardtest1.c.gcov'

        -:    0:Source:cardtest1.c
        -:    0:Graph:cardtest1.gcno
        -:    0:Data:cardtest1.gcda
        -:    0:Runs:8
        -:    0:Programs:1
        -:    1:/* Card Test for Smithy
        -:    2:   Previous game state: playing 2 player Dominion game, Smithy card is drawn
        -:    3:   Tests will cover:
        -:    4:	- if hand count was increased by 2
        -:    5:	- if deck count was decreased by 3
        -:    6:	- if played card count was increased by 1
        -:    7:	- if Smithy is in played cards
        -:    8:	- if Smithy is still in hand
        -:    9:    - other player hasn't had his hand count alterned
        -:   10:    - other player hasn't had his deck count alterned
        -:   11:*/
        -:   12:
        -:   13:#include "dominion.h"
        -:   14:#include "dominion_helpers.h"
        -:   15:#include "rngs.h"
        -:   16:#include <stdio.h>
        -:   17:#include <string.h>
        -:   18:#include <assert.h>
        -:   19:
        -:   20:#define NOISY_TEST 1
        -:   21:
        -:   22:int cardExists(int turn, struct gameState *state, int target, int place);
        -:   23:
function main called 8 returned 100% blocks executed 78%
        8:   24:int main()
        -:   25:{
        -:   26:    int startgame;
        -:   27:    int turn;
        8:   28:    int players = 2;
        8:   29:    int seed = 1000;
        8:   30:    int kingdomCards[10] = { gardens, adventurer, council_room, baron, mine, remodel, feast, smithy, village, great_hall };
        -:   31:	struct gameState previous; 
        -:   32:    struct gameState post; 
        -:   33:    int i;
        -:   34:	int r;
        8:   35:    int testruns = 1; 
        8:   36:    int finalfail = 0;
        8:   37:    int finalpass = 0;
        -:   38:#if (NOISY_TEST == 1)
        8:   39:    const char* domCards[] =  {"curse", "estate", "duchy", "province", "copper", "silver", "gold", "adventurer", "council_room", "feast",
        -:   40:        "gardens", "mine", "remodel", "smithy", "village", "baron", "great_hall", "minion", "steward", "tribute",
        -:   41:        "ambassador", "cutpurse", "embargo", "outpost", "salvager", "sea_hag", "treasure_map"};
        -:   42:#endif
        -:   43:	/* Looping through amount of test runs */
       16:   44:    for (i = 0; i < testruns; i++)
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        -:   45:    {
        -:   46:        /* Start with a new game */
        8:   47:		memset(&previous, 23, sizeof(struct gameState));   
        8:   48:        startgame = initializeGame(players, kingdomCards, seed, &previous); 
call    0 returned 100%
       24:   49:		for (turn = 0; turn < players; turn++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:   50:        {
        -:   51:			/* For current player, initialize the hand and deck */
       16:   52:            previous.handCount[turn] = 1;       
        -:   53:            int inithand[1];
       16:   54:            inithand[0] = smithy;
       16:   55:            memcpy(previous.hand[turn], inithand, sizeof(int));
       16:   56:            previous.deckCount[turn] = 5;       
        -:   57:            int initdeck[5];
       16:   58:            initdeck[0] = copper;
       16:   59:            initdeck[1] = silver;
       16:   60:            initdeck[2] = gold;
       16:   61:            initdeck[3] = gardens;
       16:   62:            initdeck[4] = tribute;
       16:   63:            memcpy(previous.deck[turn], initdeck, sizeof(int) * 5);
        -:   64:			/* The post game state will be a copy of the previous game state with tests ran on it */
       16:   65:            memcpy(&post, &previous, sizeof(struct gameState)); 
       16:   66:            playSmithy(turn, &post, 0);
call    0 returned 100%
        -:   67:#if (NOISY_TEST == 1)			
       16:   68:			printf("\nTesting if hand count was increased by 2\n");
call    0 returned 100%
        -:   69:#endif			
        -:   70:			/* When Smith is played, it adds three cards to the players hand. So post should be 2 more than previous hand count, takiung into account
        -:   71:			Smithy being discarded */               
       16:   72:			r = post.handCount[turn]; 
        -:   73:			/* If hand count of post state is 2 more than previous state, this test is passed */
       16:   74:            if (r == previous.handCount[turn] + 2) 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   75:            {
    #####:   76:                finalpass++;
        -:   77:            }
        -:   78:            else
        -:   79:            {
       16:   80:               finalfail++;
        -:   81:            }
        -:   82:#if (NOISY_TEST == 1)
       16:   83:            printf("Test Result: actual handCount: %d, expected handCount: %d\r\n", r, previous.handCount[turn] + 2);
call    0 returned 100%
       16:   84:			printf("\nTesting if deck count was decreased by 3\n");
call    0 returned 100%
        -:   85:#endif
       16:   86:            r = post.deckCount[turn]; 
        -:   87:			/* If deck count of post state is 3 less than previous state, this test is passed */
       16:   88:            if (r == previous.deckCount[turn] - 3) 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   89:            {
    #####:   90:                finalpass++;
        -:   91:            }
        -:   92:            else
        -:   93:            {
       16:   94:               finalfail++;
        -:   95:            }
        -:   96:#if (NOISY_TEST == 1)
       16:   97:            printf("Test Result: actual deckCount: %d, expected deckCount: %d\r\n", r, previous.deckCount[turn] - 3);   
call    0 returned 100%
       16:   98:			printf("\nTesting if played card count was increased by 1\n");
call    0 returned 100%
        -:   99:#endif
        -:  100:            /* When Smith is played, it should increment the played card count */ 
       16:  101:            r = post.playedCardCount;
        -:  102:			/* If played card count of post state is 1 more than previous state, this test is passed */
       16:  103:            if (r == previous.playedCardCount + 1) 
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  104:            {
       16:  105:                finalpass++;
        -:  106:            }
        -:  107:            else
        -:  108:            {
    #####:  109:                finalfail++;
        -:  110:            }
        -:  111:#if (NOISY_TEST == 1)
       16:  112:            printf("Test Result: actual playedCardCount = %d, expected playedCardCount = %d\r\n", r, previous.playedCardCount + 1);
call    0 returned 100%
       16:  113:			printf("\nTesting if Smithy is in played cards\n");
call    0 returned 100%
        -:  114:#endif           
        -:  115:			/* When Smith is played, it should be added to the played card  */ 
       16:  116:            r = cardExists(turn, &post, smithy, 0);
call    0 returned 100%
        -:  117:			/* If smithy is found in the played cards then it pass */
       16:  118:            if (r == -1) 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  119:            {
    #####:  120:               finalfail++;
        -:  121:            }
        -:  122:            else
        -:  123:            {
       16:  124:                finalpass++;
        -:  125:            }
        -:  126:#if (NOISY_TEST == 1)
       16:  127:            if (r == -1) 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  128:            {
    #####:  129:               printf("Test Result: Fail. Smithy not in the played cards\r\n");
call    0 never executed
        -:  130:            }
        -:  131:            else
        -:  132:            {
       16:  133:                printf("Test Result: Pass. Smithy in the played cards\r\n", r);
call    0 returned 100%
        -:  134:            }
       16:  135:			printf("\nTesting if Smithy is still in hand\n");
call    0 returned 100%
        -:  136:#endif
        -:  137:             /* When Smith is played, it should not still be in player's post state hand  */
       16:  138:            r = cardExists(turn, &post, smithy, 1);
call    0 returned 100%
        -:  139:			/* If smithy is not found in the played cards then it pass */
       16:  140:            if (r == -1) 
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  141:            {
       16:  142:               finalpass++;
        -:  143:            }
        -:  144:            else
        -:  145:            {
    #####:  146:               finalfail++;
        -:  147:            }
        -:  148:
        -:  149:#if (NOISY_TEST == 1)
       16:  150:            if (r == -1) 
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  151:            {
       16:  152:                printf("Test Result: Pass. Smithy not in the player's post state hand\r\n");
call    0 returned 100%
        -:  153:            }
        -:  154:            else
        -:  155:            {
    #####:  156:                printf("Test Result: Fail. Smithy still in the player's post state hand\r\n", r);
call    0 never executed
        -:  157:            }
       16:  158:			printf("Testing other player hasn't had his hand count alterned\n");			
call    0 returned 100%
        -:  159:#endif   
        -:  160:			/* Current player's smithy should not affect other play's game state */
       16:  161:			if( previous.handCount[1 - turn] != post.handCount[1 - turn] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  162:			{
    #####:  163:				finalfail++;  
        -:  164:			}
        -:  165:			else
        -:  166:			{
       16:  167:				finalpass++;
        -:  168:			}
        -:  169:#if (NOISY_TEST == 1)
       16:  170:			if (previous.handCount[1 - turn] != post.handCount[1 - turn]  )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  171:			{
    #####:  172:				printf("Test Result: Fail. Current player's playing smithy changed other player's hand count\n");
call    0 never executed
    #####:  173:				printf("Test Result: actual handCount: %d, expected handCount: %d\r\n", post.handCount[1 - turn],  previous.handCount[1 - turn]  );
call    0 never executed
        -:  174:			}
        -:  175:			else
        -:  176:			{
       16:  177:				printf("Test Result: Pass. Current player's playing smithy did not affect other player's hand count\n");
call    0 returned 100%
       16:  178:				printf("Test Result: actual handCount: %d, expected handCount: %d\r\n", post.handCount[1 - turn],  previous.handCount[1 - turn] );
call    0 returned 100%
        -:  179:			}
       16:  180:			printf("Testing other player hasn't had his deck count alterned\n");
call    0 returned 100%
        -:  181:#endif
        -:  182:			
       16:  183:			if( previous.deckCount[1 - turn] != post.deckCount[1 - turn] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  184:			{
    #####:  185:				finalfail++;  
        -:  186:			}
        -:  187:			else
        -:  188:			{
       16:  189:				finalpass++;
        -:  190:			}
        -:  191:#if (NOISY_TEST == 1)
       16:  192:			if ( previous.deckCount[1 - turn] != post.deckCount[1 - turn] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  193:			{
    #####:  194:				printf("Test Result: Fail. Current player's playing smithy changed other player's deck count\n");
call    0 never executed
    #####:  195:				printf("Test Result: actual deckCount: %d, expected deckCount: %d\r\n", post.deckCount[1 - turn], previous.deckCount[1 - turn] );
call    0 never executed
        -:  196:			}
        -:  197:			else
        -:  198:			{
       16:  199:				printf("Test Result: Pass. Current player's playing smithy did not affect other player's deck count\n");
call    0 returned 100%
       16:  200:				printf("Test Result: actual deckCount: %d, expected deckCount: %d\r\n", post.deckCount[1 - turn], previous.deckCount[1 - turn] );
call    0 returned 100%
        -:  201:			}
        -:  202:#endif
        -:  203:        }
        -:  204:     }
        8:  205:     printf("Final tally for Card Test 1 ( Smithy ):\nPass: %d\nFail: %d\r\n",finalpass, finalfail );
call    0 returned 100%
        8:  206:    return 0;
        -:  207:}
        -:  208:
        -:  209:
function cardExists called 32 returned 100% blocks executed 94%
       32:  210:int cardExists(int turn, struct gameState *state, int target, int place)
        -:  211:{
        -:  212:    /* Initalize flag to doesn't exist */
       32:  213:	int cardexists = -1;
        -:  214:    /* Retrieve size of played cards, hand or deck for checking loop */
       32:  215:	int loopsize = 0;
        -:  216:	/* Find size of loop for played cards, ahnd or deck */
       32:  217:    if (place == 0) 
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
       16:  218:		{ loopsize = state->playedCardCount; };
       32:  219:    if (place == 1) 
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
       16:  220:		{ loopsize = state->handCount[turn]; };
        -:  221:    int i;
      128:  222:    for (i = 0; i < loopsize; i++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  223:    {
        -:  224:        /* If checking played cards for a certain card, use this loop */
       96:  225:		if (place == 0)
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
        -:  226:        {
        -:  227:            /* If target is found in played cards, then it exists */
       16:  228:			if (state->playedCards[i] == target)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  229:            {
       16:  230:                cardexists = i;
        -:  231:            }
        -:  232:        }
        -:  233:		/* If checking player's hand for a certain card, use this loop */
       80:  234:        else if (place == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  235:        {
       80:  236:            if (state->hand[turn][i] == target)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  237:            {
    #####:  238:                 cardexists = i;
        -:  239:            }
        -:  240:        }
        -:  241:    }
       32:  242:    return cardexists;
        -:  243:} 

Testing if hand count was increased by 2
Test Result: actual handCount: 2, expected handCount: 3

Testing if adventurer remains in hand after playing
Test Result: Fail. Adventurer still in hand after playing

Testing if 2 treasure cards were added
Added treasure cards correctly

Testing if Adventurer card is discarcded
Adventurer discard test failed

Testing deck count is decreased by at least 2
Test Result: Pass. Deck count decreased by at least 2
Test Result: actual deckCount: 2, expected deckCount: 3

Testing other player hasn't had his hand count alterned
Test Result: Pass. Current player's playing adventurer did not affect other player's hand count
Test Result: actual handCount: 0, expected handCount: 0

Testing other player hasn't had his deck count alterned
Test Result: Pass. Current player's playing adventurer did not affect other player's deck count
Test Result: actual deckCount: 10, expected deckCount: 10

Testing if hand count was increased by 2
Test Result: actual handCount: 2, expected handCount: 3

Testing if adventurer remains in hand after playing
Test Result: Fail. Adventurer still in hand after playing

Testing if 2 treasure cards were added
Added treasure cards correctly

Testing if Adventurer card is discarcded
Adventurer discard test failed

Testing deck count is decreased by at least 2
Test Result: Pass. Deck count decreased by at least 2
Test Result: actual deckCount: 2, expected deckCount: 3

Testing other player hasn't had his hand count alterned
Test Result: Pass. Current player's playing adventurer did not affect other player's hand count
Test Result: actual handCount: 1, expected handCount: 1

Testing other player hasn't had his deck count alterned
Test Result: Pass. Current player's playing adventurer did not affect other player's deck count
Test Result: actual deckCount: 5, expected deckCount: 5
Final tally for Card Test 2 ( Adventurer ):
Pass: 8
Fail: 6
File 'cardtest2.c'
Lines executed:84.16% of 101
Branches executed:100.00% of 54
Taken at least once:57.41% of 54
Calls executed:70.00% of 30
Creating 'cardtest2.c.gcov'

        -:    0:Source:cardtest2.c
        -:    0:Graph:cardtest2.gcno
        -:    0:Data:cardtest2.gcda
        -:    0:Runs:8
        -:    0:Programs:1
        -:    1:/* Card Test for Adventurer
        -:    2:   Previous game state: playing 2 player Dominion game, Adventurer card is played
        -:    3:   Tests will cover:
        -:    4:   - if hand count was increased by 2
        -:    5:   - if adventurer remains in hand after playing
        -:    6:   - if 2 treasure cards were added
        -:    7:   - if Adventurer card is discarded
        -:    8:   - if deck count is decreased by at least 2
        -:    9:   - other player hasn't had his hand count alterned
        -:   10:   - other player hasn't had his deck count alterned
        -:   11:*/
        -:   12:#include "dominion.h"
        -:   13:#include "dominion_helpers.h"
        -:   14:#include "rngs.h"
        -:   15:#include <stdio.h>
        -:   16:#include <string.h>
        -:   17:#include <assert.h>
        -:   18:
        -:   19:#define NOISY_TEST 1
        -:   20:
        -:   21:int cardExists(int turn, struct gameState *state, int target);
        -:   22:
function main called 8 returned 100% blocks executed 79%
        8:   23:int main()
        -:   24:{
        -:   25:    int startgame;
        -:   26:    int turn;
        8:   27:    int players = 2;
        8:   28:    int seed = 1000;
        8:   29:    int kingdomCards[10] = { gardens, adventurer, council_room, baron, mine, remodel, feast, smithy, village, great_hall };
        -:   30:	struct gameState previous; 
        -:   31:    struct gameState post; 
        -:   32:    int i;
        -:   33:	int r;
        8:   34:    int testruns = 1; 
        8:   35:    int finalfail = 0;
        8:   36:    int finalpass = 0;
        8:   37:	int tmp2 = 0;
        8:   38:	int tmp3 = 0;
        8:   39:	int tmp4 = 0;
        -:   40:#if (NOISY_TEST == 1)
        8:   41:    const char* domCards[] =  {"curse", "estate", "duchy", "province", "copper", "silver", "gold", "adventurer", "council_room", "feast",
        -:   42:        "gardens", "mine", "remodel", "smithy", "village", "baron", "great_hall", "minion", "steward", "tribute",
        -:   43:        "ambassador", "cutpurse", "embargo", "outpost", "salvager", "sea_hag", "treasure_map"};
        -:   44:#endif
        -:   45:	/* Looping through amount of test runs */
       16:   46:    for (i = 0; i < testruns; i++)
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        -:   47:    {
        -:   48:        /* Start with a new game */
        8:   49:		memset(&previous, 23, sizeof(struct gameState));   
        8:   50:        startgame = initializeGame(players, kingdomCards, seed, &previous); 
call    0 returned 100%
       24:   51:		for (turn = 0; turn < players; turn++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:   52:        {
        -:   53:			/* For current player, initialize the hand and deck */
       16:   54:            previous.handCount[turn] = 1;       
        -:   55:            int inithand[1];
       16:   56:            inithand[0] = adventurer;
       16:   57:            memcpy(previous.hand[turn], inithand, sizeof(int));
       16:   58:            previous.deckCount[turn] = 5;       
        -:   59:            int initdeck[5];
       16:   60:            initdeck[0] = copper;
       16:   61:            initdeck[1] = silver;
       16:   62:            initdeck[2] = gold;
       16:   63:            initdeck[3] = gardens;
       16:   64:            initdeck[4] = tribute;
       16:   65:            memcpy(previous.deck[turn], initdeck, sizeof(int) * 5);
        -:   66:			/* The post game state will be a copy of the previous game state with tests ran on it */
       16:   67:            memcpy(&post, &previous, sizeof(struct gameState)); 
       16:   68:            playAdventurer( &post, turn);
call    0 returned 100%
       16:   69:			tmp2 = previous.deckCount[turn];
       16:   70:			tmp3 = previous.discardCount[turn];
       16:   71:			tmp4 = previous.handCount[turn];
       16:   72:			int expNumAct = 0;
       16:   73:			int newcard = 0;
        -:   74:#if (NOISY_TEST == 1)			
       16:   75:			printf("\nTesting if hand count was increased by 2\n");
call    0 returned 100%
        -:   76:#endif
        -:   77:			/* When Adventurer is played, it adds two cards to the players hand. */               
       16:   78:			r = post.handCount[turn]; 
        -:   79:			/* If hand count of post state is 2 more than previous state, this test is passed */
       16:   80:            if (r == previous.handCount[turn] + 2) 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   81:            {
    #####:   82:                finalpass++;
        -:   83:            }
        -:   84:            else
        -:   85:            {
       16:   86:               finalfail++;
        -:   87:            }
        -:   88:#if (NOISY_TEST == 1)
       16:   89:            printf("Test Result: actual handCount: %d, expected handCount: %d\r\n", r, previous.handCount[turn] + 2);
call    0 returned 100%
       16:   90:			printf("\nTesting if adventurer remains in hand after playing\n");
call    0 returned 100%
        -:   91:#endif           
        -:   92:			/* When adventurer is played, it should leave hand  */ 
       16:   93:            r = cardExists(turn, &post, adventurer);
call    0 returned 100%
        -:   94:			/* If adventurer is not in hand then it pass */
       16:   95:            if ( r == -1 ) 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   96:            {
    #####:   97:               finalpass++;
        -:   98:            }
        -:   99:            else
        -:  100:            {
       16:  101:                finalfail++;
        -:  102:            }
        -:  103:#if (NOISY_TEST == 1)
       16:  104:            if (r == -1) 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  105:            {
    #####:  106:               printf("Test Result: Pass. Adventurer not in the hand after playing\r\n");
call    0 never executed
        -:  107:            }
        -:  108:            else
        -:  109:            {
       16:  110:                printf("Test Result: Fail. Adventurer still in hand after playing\r\n");
call    0 returned 100%
        -:  111:            }
       16:  112:			printf("\nTesting if 2 treasure cards were added\n");	
call    0 returned 100%
        -:  113:#endif           
        -:  114:            
        -:  115:			/* When playing Adventurer, 2 treasure cards should be added last */
       32:  116:			if( (( post.hand[turn][post.handCount[turn] - 2] != copper ) && ( post.hand[turn][post.handCount[turn] - 2] != silver ) && 
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
       48:  117:			(post.hand[turn][post.handCount[turn] - 2] != gold )) && (( post.hand[turn][post.handCount[turn] - 1] != copper ) && ( post.hand[turn][post.handCount[turn] - 1] != silver ) && 
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
       16:  118:			(post.hand[turn][post.handCount[turn] - 1] != gold )))
        -:  119:			{
    #####:  120:				finalfail++;
        -:  121:			}
        -:  122:			else
        -:  123:			{
       16:  124:				finalpass++;
        -:  125:			}
        -:  126:#if (NOISY_TEST == 1)
       32:  127:            if( (( post.hand[turn][post.handCount[turn] - 2] != copper ) && ( post.hand[turn][post.handCount[turn] - 2] != silver ) && 
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
       48:  128:			(post.hand[turn][post.handCount[turn] - 2] != gold )) && (( post.hand[turn][post.handCount[turn] - 1] != copper ) && ( post.hand[turn][post.handCount[turn] - 1] != silver ) && 
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
       16:  129:			(post.hand[turn][post.handCount[turn] - 1] != gold )))
        -:  130:			{
    #####:  131:				printf("Added non treasure card instead of treasure cards failed\n"); 
call    0 never executed
        -:  132:			}
        -:  133:			else
        -:  134:			{
       16:  135:				printf("Added treasure cards correctly\n");   
call    0 returned 100%
        -:  136:			}
       16:  137:			printf("\nTesting if Adventurer card is discarcded\n");	
call    0 returned 100%
        -:  138:#endif
        -:  139:            /* Council Room card should be discarded after playing so it should be at the top of the discard pile */ 
       16:  140:            if(post.playedCards[post.playedCardCount - 1] != adventurer )
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  141:			{
       16:  142:				finalfail++;  
        -:  143:			}
        -:  144:			else
        -:  145:			{
    #####:  146:				finalpass++;
        -:  147:			}
        -:  148:#if (NOISY_TEST == 1)
       16:  149:            if ( post.playedCards[post.playedCardCount - 1] != adventurer )
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  150:			{
       16:  151:				printf("Adventurer discard test failed\n");
call    0 returned 100%
        -:  152:			}
        -:  153:			else
        -:  154:			{
    #####:  155:				printf("Test Result: Pass. Adventurer card has been discarded\n");   
call    0 never executed
        -:  156:			}
       16:  157:			printf("\nTesting deck count is decreased by at least 2\n");			
call    0 returned 100%
        -:  158:#endif   
        -:  159:			/* If post state deck count didn't decreasse by 2 its fail */
       16:  160:			r = post.deckCount[turn];
       16:  161:            if ( (tmp2 - 2) < r  ) 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  162:            {
    #####:  163:               finalfail++;
        -:  164:            }
        -:  165:            else
        -:  166:            {
       16:  167:                finalpass++;
        -:  168:            }
        -:  169:#if (NOISY_TEST == 1)
       16:  170:          	if( (tmp2 - 2) < r  )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  171:			{
    #####:  172:				printf("Test Result: Fail. Deck count not decreased by at least 2\r\n");
call    0 never executed
    #####:  173:				printf("Test Result: actual deckCount: %d, expected deckCount: %d\r\n", r, (tmp2 - 2));
call    0 never executed
        -:  174:				
        -:  175:			}
        -:  176:			else
        -:  177:			{
       16:  178:				printf("Test Result: Pass. Deck count decreased by at least 2\r\n");
call    0 returned 100%
       16:  179:				printf("Test Result: actual deckCount: %d, expected deckCount: %d\r\n", r, (tmp2 - 2));
call    0 returned 100%
        -:  180:			}
       16:  181:			printf("\nTesting other player hasn't had his hand count alterned\n");			
call    0 returned 100%
        -:  182:#endif   
        -:  183:			/* Current player's adventurer should not affect other play's game state */
       16:  184:			if( previous.handCount[1 - turn] != post.handCount[1 - turn] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  185:			{
    #####:  186:				finalfail++;  
        -:  187:			}
        -:  188:			else
        -:  189:			{
       16:  190:				finalpass++;
        -:  191:			}
        -:  192:#if (NOISY_TEST == 1)
       16:  193:			if (previous.handCount[1 - turn] != post.handCount[1 - turn]  )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  194:			{
    #####:  195:				printf("Test Result: Fail. Current player's playing adventurer changed other player's hand count\n");
call    0 never executed
    #####:  196:				printf("Test Result: actual handCount: %d, expected handCount: %d\r\n", post.handCount[1 - turn],  previous.handCount[1 - turn]  );
call    0 never executed
        -:  197:			}
        -:  198:			else
        -:  199:			{
       16:  200:				printf("Test Result: Pass. Current player's playing adventurer did not affect other player's hand count\n");
call    0 returned 100%
       16:  201:				printf("Test Result: actual handCount: %d, expected handCount: %d\r\n", post.handCount[1 - turn],  previous.handCount[1 - turn] );
call    0 returned 100%
        -:  202:			}
       16:  203:			printf("\nTesting other player hasn't had his deck count alterned\n");
call    0 returned 100%
        -:  204:#endif
        -:  205:			
       16:  206:			if( previous.deckCount[1 - turn] != post.deckCount[1 - turn] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  207:			{
    #####:  208:				finalfail++;  
        -:  209:			}
        -:  210:			else
        -:  211:			{
       16:  212:				finalpass++;
        -:  213:			}
        -:  214:#if (NOISY_TEST == 1)
       16:  215:			if ( previous.deckCount[1 - turn] != post.deckCount[1 - turn] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  216:			{
    #####:  217:				printf("Test Result: Fail. Current player's playing adventurer changed other player's deck count\n");
call    0 never executed
    #####:  218:				printf("Test Result: actual deckCount: %d, expected deckCount: %d\r\n", post.deckCount[1 - turn], previous.deckCount[1 - turn] );
call    0 never executed
        -:  219:			}
        -:  220:			else
        -:  221:			{
       16:  222:				printf("Test Result: Pass. Current player's playing adventurer did not affect other player's deck count\n");
call    0 returned 100%
       16:  223:				printf("Test Result: actual deckCount: %d, expected deckCount: %d\r\n", post.deckCount[1 - turn], previous.deckCount[1 - turn] );
call    0 returned 100%
        -:  224:			}
        -:  225:			
        -:  226:#endif			
        -:  227:          }
        -:  228:     }
        8:  229:    printf("Final tally for Card Test 2 ( Adventurer ):\nPass: %d\nFail: %d\r\n",finalpass, finalfail );
call    0 returned 100%
        8:  230:    return 0;
        -:  231:}
        -:  232:
        -:  233:
function cardExists called 16 returned 100% blocks executed 100%
       16:  234:int cardExists(int turn, struct gameState *state, int target)
        -:  235:{
        -:  236:    /* Initalize flag to doesn't exist */
       16:  237:	int cardexists = -1;
        -:  238:    /* Retrieve size of played cards, hand or deck for checking loop */
       16:  239:	int loopsize = state->handCount[turn];;
        -:  240:	/* Find size of loop for played cards, ahnd or deck */
        -:  241:    int i;
       48:  242:    for (i = 0; i < loopsize; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  243:    {
        -:  244:        /* If checking player's hand for a certain card, use this loop */
       32:  245:        if (state->hand[turn][i] == target)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  246:        {
       16:  247:                 cardexists = i;
        -:  248:        }
        -:  249:    }
       16:  250:    return cardexists;
        -:  251:} 

Testing if hand count was unaltered
Test Result: actual handCount: 1, expected handCount: 1

Testing if deck count is decreased by 1
Test Result: actual deckCount: 4, expected deckCount: 4

Testing if number actions increased by 2
Number actions test failed
Test Result: actual number actions: 4, expected number actions: 3

Testing if village card is discarded
Test Result: Pass. Village card has been discarded

Testing if next card is moved to the hand
Test Result: Pass. Next card in deck was moved to the hand

Testing if village remains in hand after playing
Test Result: Pass. Village not in the hand after playing

Testing other player hasn't had his hand count alterned
Test Result: Pass. Current player's playing Village did not affect other player's hand count
Test Result: actual handCount: 0, expected handCount: 0

Testing other player hasn't had his deck count alterned
Test Result: Pass. Current player's playing Village did not affect other player's deck count
Test Result: actual deckCount: 10, expected deckCount: 10

Testing if hand count was unaltered
Test Result: actual handCount: 1, expected handCount: 1

Testing if deck count is decreased by 1
Test Result: actual deckCount: 4, expected deckCount: 4

Testing if number actions increased by 2
Number actions test failed
Test Result: actual number actions: 4, expected number actions: 3

Testing if village card is discarded
Test Result: Pass. Village card has been discarded

Testing if next card is moved to the hand
Test Result: Pass. Next card in deck was moved to the hand

Testing if village remains in hand after playing
Test Result: Pass. Village not in the hand after playing

Testing other player hasn't had his hand count alterned
Test Result: Pass. Current player's playing Village did not affect other player's hand count
Test Result: actual handCount: 1, expected handCount: 1

Testing other player hasn't had his deck count alterned
Test Result: Pass. Current player's playing Village did not affect other player's deck count
Test Result: actual deckCount: 5, expected deckCount: 5
Final tally for Card Test 3 ( Village ):
Pass: 14
Fail: 2
File 'cardtest3.c'
Lines executed:81.90% of 105
Branches executed:100.00% of 40
Taken at least once:57.50% of 40
Calls executed:69.70% of 33
Creating 'cardtest3.c.gcov'

        -:    0:Source:cardtest3.c
        -:    0:Graph:cardtest3.gcno
        -:    0:Data:cardtest3.gcda
        -:    0:Runs:8
        -:    0:Programs:1
        -:    1:/* Card Test for Village
        -:    2:   Previous game state: playing 2 player Dominion game, Village card is played
        -:    3:   Tests will cover:
        -:    4:   - if hand count was unaltered
        -:    5:   - if deck count is decreased by 1
        -:    6:   - if number actions increased by 2
        -:    7:   - if village card is discarded
        -:    8:   - if next card is moved to the hand
        -:    9:   - if village remains in hand after playing
        -:   10:   - other player hasn't had his hand count alterned
        -:   11:   - other player hasn't had his deck count alterned
        -:   12:*/
        -:   13:#include "dominion.h"
        -:   14:#include "dominion_helpers.h"
        -:   15:#include "rngs.h"
        -:   16:#include <stdio.h>
        -:   17:#include <string.h>
        -:   18:#include <assert.h>
        -:   19:
        -:   20:#define NOISY_TEST 1
        -:   21:
        -:   22:int cardExists(int turn, struct gameState *state, int target);
        -:   23:
function main called 8 returned 100% blocks executed 75%
        8:   24:int main()
        -:   25:{
        -:   26:    int startgame;
        -:   27:    int turn;
        8:   28:    int players = 2;
        8:   29:    int seed = 1000;
        8:   30:    int kingdomCards[10] = { gardens, adventurer, council_room, baron, mine, remodel, feast, smithy, village, great_hall };
        -:   31:	struct gameState previous; 
        -:   32:    struct gameState post; 
        -:   33:    int i;
        -:   34:	int r;
        8:   35:    int testruns = 1; 
        8:   36:    int finalfail = 0;
        8:   37:    int finalpass = 0;
        8:   38:	int tmp2 = 0;
        8:   39:	int tmp3 = 0;
        8:   40:	int tmp4 = 0;
        -:   41:#if (NOISY_TEST == 1)
        8:   42:    const char* domCards[] =  {"curse", "estate", "duchy", "province", "copper", "silver", "gold", "adventurer", "council_room", "feast",
        -:   43:        "gardens", "mine", "remodel", "smithy", "village", "baron", "great_hall", "minion", "steward", "tribute",
        -:   44:        "ambassador", "cutpurse", "embargo", "outpost", "salvager", "sea_hag", "treasure_map"};
        -:   45:#endif
        -:   46:	/* Looping through amount of test runs */
       16:   47:    for (i = 0; i < testruns; i++)
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        -:   48:    {
        -:   49:        /* Start with a new game */
        8:   50:		memset(&previous, 23, sizeof(struct gameState));   
        8:   51:        startgame = initializeGame(players, kingdomCards, seed, &previous); 
call    0 returned 100%
       24:   52:		for (turn = 0; turn < players; turn++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:   53:        {
        -:   54:			/* For current player, initialize the hand and deck */
       16:   55:            previous.handCount[turn] = 1;       
        -:   56:            int inithand[1];
       16:   57:            inithand[0] = village;
       16:   58:            memcpy(previous.hand[turn], inithand, sizeof(int));
       16:   59:            previous.deckCount[turn] = 5;       
        -:   60:            int initdeck[5];
       16:   61:            initdeck[0] = copper;
       16:   62:            initdeck[1] = silver;
       16:   63:            initdeck[2] = gold;
       16:   64:            initdeck[3] = gardens;
       16:   65:            initdeck[4] = tribute;
       16:   66:            memcpy(previous.deck[turn], initdeck, sizeof(int) * 5);
        -:   67:			/* The post game state will be a copy of the previous game state with tests ran on it */
       16:   68:            memcpy(&post, &previous, sizeof(struct gameState)); 
       16:   69:            playVillage(turn, &post, 0);
call    0 returned 100%
       16:   70:			tmp2 = previous.deckCount[turn];
       16:   71:			tmp3 = previous.discardCount[turn];
       16:   72:			tmp4 = previous.handCount[turn];
       16:   73:			int expNumAct = 0;
       16:   74:			int newcard = 0;
        -:   75:#if (NOISY_TEST == 1)			
       16:   76:			printf("\nTesting if hand count was unaltered\n");
call    0 returned 100%
        -:   77:#endif
        -:   78:			/* When village is played, it adds a card to the players hand but also discards the village */               
       16:   79:			if ( tmp4 != post.handCount[turn])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   80:			{
    #####:   81:				finalfail++;
        -:   82:			}
        -:   83:			else
        -:   84:			{
       16:   85:				finalpass++;
        -:   86:			}
        -:   87:#if (NOISY_TEST == 1)
       16:   88:			if ( tmp4 != post.handCount[turn])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   89:			{
    #####:   90:				printf("Handcount test failed\n");
call    0 never executed
        -:   91:			}
        -:   92:			else
        -:   93:			{
       16:   94:				printf("Test Result: actual handCount: %d, expected handCount: %d\r\n", tmp4, post.handCount[turn] );
call    0 returned 100%
        -:   95:			}
       16:   96:			printf("\nTesting if deck count is decreased by 1\n");			
call    0 returned 100%
        -:   97:#endif   
        -:   98:			/* When village is played, it adds a card to the players hand which is taken off the deck */
       16:   99:			if( ( tmp2 - 1 ) != post.deckCount[turn] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  100:			{
    #####:  101:				finalfail++;  
        -:  102:			}
        -:  103:			else
        -:  104:			{
       16:  105:				finalpass++;
        -:  106:			}
        -:  107:#if (NOISY_TEST == 1)
       16:  108:			if ( ( tmp2 - 1 ) != post.deckCount[turn] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  109:			{
    #####:  110:				printf("Deckcount test failed\n");
call    0 never executed
        -:  111:			}
        -:  112:			else
        -:  113:			{
       16:  114:				printf("Test Result: actual deckCount: %d, expected deckCount: %d\r\n", post.deckCount[turn], ( tmp2 - 1 ) );
call    0 returned 100%
        -:  115:			}
       16:  116:			printf("\nTesting if number actions increased by 2\n");			
call    0 returned 100%
        -:  117:#endif   
        -:  118:            
        -:  119:			/* When playing village, num of actions should increase by 2 for a pass */
       16:  120:			expNumAct = previous.numActions + 2;
       16:  121:			if ( expNumAct != post.numActions )
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  122:			{
       16:  123:				finalfail++;
        -:  124:			}
        -:  125:			else
        -:  126:			{
    #####:  127:				finalpass++;
        -:  128:			}
        -:  129:#if (NOISY_TEST == 1)
       16:  130:            if ( expNumAct != post.numActions )
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  131:			{
       16:  132:				printf("Number actions test failed\n");
call    0 returned 100%
       16:  133:				printf("Test Result: actual number actions: %d, expected number actions: %d\r\n", post.numActions, expNumAct );   
call    0 returned 100%
        -:  134:			}
        -:  135:			else
        -:  136:			{
    #####:  137:				printf("Test Result: actual number actions: %d, expected number actions: %d\r\n", post.numActions, expNumAct );   
call    0 never executed
        -:  138:			}
       16:  139:			printf("\nTesting if village card is discarded\n");	
call    0 returned 100%
        -:  140:#endif
        -:  141:            /* Village card should be discarded after playing so it should be at the top of the discard pile */ 
       16:  142:            if(post.playedCards[post.playedCardCount - 1] != village )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  143:			{
    #####:  144:				finalfail++;  
        -:  145:			}
        -:  146:			else
        -:  147:			{
       16:  148:				finalpass++;
        -:  149:			}
        -:  150:#if (NOISY_TEST == 1)
       16:  151:            if ( post.playedCards[post.playedCardCount - 1] != village )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  152:			{
    #####:  153:				printf("Village discard test failed\n");
call    0 never executed
        -:  154:			}
        -:  155:			else
        -:  156:			{
       16:  157:				printf("Test Result: Pass. Village card has been discarded\n");   
call    0 returned 100%
        -:  158:			}
       16:  159:			printf("\nTesting if next card is moved to the hand\n");	
call    0 returned 100%
        -:  160:#endif
       16:  161:			newcard = previous.deck[ turn ][ tmp2 -1 ];
       16:  162:			if ( newcard != post.hand[ turn ][ previous.handCount[ turn ] - 1 ])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  163:			{
    #####:  164:				finalfail++;
        -:  165:			}
        -:  166:			else
        -:  167:			{
       16:  168:				finalpass++;
        -:  169:			}
        -:  170:#if (NOISY_TEST == 1)
       16:  171:			if ( newcard != post.hand[ turn ][ previous.handCount[ turn ] - 1 ])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  172:			{
    #####:  173:				printf("Next card was not moved to the hand\n");
call    0 never executed
        -:  174:			}
        -:  175:			else
        -:  176:			{
       16:  177:				printf("Test Result: Pass. Next card in deck was moved to the hand\n");   
call    0 returned 100%
        -:  178:			}
       16:  179:			printf("\nTesting if village remains in hand after playing\n");
call    0 returned 100%
        -:  180:#endif           
        -:  181:			/* When village is played, it should leave hand  */ 
       16:  182:            r = cardExists(turn, &post, village);
call    0 returned 100%
        -:  183:			/* If village is not in hand then it pass */
       16:  184:            if ( r == -1 ) 
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  185:            {
       16:  186:               finalpass++;
        -:  187:            }
        -:  188:            else
        -:  189:            {
    #####:  190:                finalfail++;
        -:  191:            }
        -:  192:#if (NOISY_TEST == 1)
       16:  193:            if (r == -1) 
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  194:            {
       16:  195:               printf("Test Result: Pass. Village not in the hand after playing\r\n");
call    0 returned 100%
        -:  196:            }
        -:  197:            else
        -:  198:            {
    #####:  199:                printf("Test Result: Fail. Village still in hand after playing\r\n");
call    0 never executed
        -:  200:            }
       16:  201:			printf("\nTesting other player hasn't had his hand count alterned\n");			
call    0 returned 100%
        -:  202:#endif 
        -:  203:/* Current player's Village should not affect other play's game state */
       16:  204:			if( previous.handCount[1 - turn] != post.handCount[1 - turn] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  205:			{
    #####:  206:				finalfail++;  
        -:  207:			}
        -:  208:			else
        -:  209:			{
       16:  210:				finalpass++;
        -:  211:			}
        -:  212:#if (NOISY_TEST == 1)
       16:  213:			if (previous.handCount[1 - turn] != post.handCount[1 - turn]  )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  214:			{
    #####:  215:				printf("Test Result: Fail. Current player's playing Village changed other player's hand count\n");
call    0 never executed
    #####:  216:				printf("Test Result: actual handCount: %d, expected handCount: %d\r\n", post.handCount[1 - turn],  previous.handCount[1 - turn]  );
call    0 never executed
        -:  217:			}
        -:  218:			else
        -:  219:			{
       16:  220:				printf("Test Result: Pass. Current player's playing Village did not affect other player's hand count\n");
call    0 returned 100%
       16:  221:				printf("Test Result: actual handCount: %d, expected handCount: %d\r\n", post.handCount[1 - turn],  previous.handCount[1 - turn] );
call    0 returned 100%
        -:  222:			}
       16:  223:			printf("\nTesting other player hasn't had his deck count alterned\n");
call    0 returned 100%
        -:  224:#endif
        -:  225:			
       16:  226:			if( previous.deckCount[1 - turn] != post.deckCount[1 - turn] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  227:			{
    #####:  228:				finalfail++;  
        -:  229:			}
        -:  230:			else
        -:  231:			{
       16:  232:				finalpass++;
        -:  233:			}
        -:  234:#if (NOISY_TEST == 1)
       16:  235:			if ( previous.deckCount[1 - turn] != post.deckCount[1 - turn] )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  236:			{
    #####:  237:				printf("Test Result: Fail. Current player's playing Village changed other player's deck count\n");
call    0 never executed
    #####:  238:				printf("Test Result: actual deckCount: %d, expected deckCount: %d\r\n", post.deckCount[1 - turn], previous.deckCount[1 - turn] );
call    0 never executed
        -:  239:			}
        -:  240:			else
        -:  241:			{
       16:  242:				printf("Test Result: Pass. Current player's playing Village did not affect other player's deck count\n");
call    0 returned 100%
       16:  243:				printf("Test Result: actual deckCount: %d, expected deckCount: %d\r\n", post.deckCount[1 - turn], previous.deckCount[1 - turn] );
call    0 returned 100%
        -:  244:			}
        -:  245:			
        -:  246:#endif			           
        -:  247:          }
        -:  248:     }
        8:  249:    printf("Final tally for Card Test 3 ( Village ):\nPass: %d\nFail: %d\r\n",finalpass, finalfail );
call    0 returned 100%
        8:  250:    return 0;
        -:  251:}
        -:  252:
        -:  253:
function cardExists called 16 returned 100% blocks executed 86%
       16:  254:int cardExists(int turn, struct gameState *state, int target)
        -:  255:{
        -:  256:    /* Initalize flag to doesn't exist */
       16:  257:	int cardexists = -1;
        -:  258:    /* Retrieve size of played cards, hand or deck for checking loop */
       16:  259:	int loopsize = state->handCount[turn];;
        -:  260:	/* Find size of loop for played cards, ahnd or deck */
        -:  261:    int i;
       32:  262:    for (i = 0; i < loopsize; i++)
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        -:  263:    {
        -:  264:        /* If checking player's hand for a certain card, use this loop */
       16:  265:        if (state->hand[turn][i] == target)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  266:        {
    #####:  267:                 cardexists = i;
        -:  268:        }
        -:  269:    }
       16:  270:    return cardexists;
        -:  271:} 

Testing if hand count was increased by 3
Handcount test failed
Test Result: actual handCount: 5, expected handCount: 4

Testing if council_room remains in hand after playing
Test Result: Pass. Council Room not in the hand after playing

Testing if number of buys increased by 1
Test Result: actual number buys: 2, expected number buys: 2

Testing if Council Room card is discarded
Test Result: Pass. Council Room card has been discarded

Testing deck count is decreased by 4
Deckcount test failed
Test Result: actual deckCount: 0, expected deckCount: 1

Testing other player has drawn a card hand increase by 1
Test Result: Fail. Other player hand did not increase by 1
Test Result: actual handCount: 0, expected handCount: 1

Testing other player has drawn a card deck decrease by 1
Test Result: Fail. Other player deck did not decreased by 1
Test Result: actual deckCount: 10, expected deckCount: 9

Testing if hand count was increased by 3
Handcount test failed
Test Result: actual handCount: 5, expected handCount: 4

Testing if council_room remains in hand after playing
Test Result: Pass. Council Room not in the hand after playing

Testing if number of buys increased by 1
Test Result: actual number buys: 2, expected number buys: 2

Testing if Council Room card is discarded
Test Result: Pass. Council Room card has been discarded

Testing deck count is decreased by 4
Deckcount test failed
Test Result: actual deckCount: 0, expected deckCount: 1

Testing other player has drawn a card hand increase by 1
Test Result: Fail. Other player hand did not increase by 1
Test Result: actual handCount: 1, expected handCount: 2

Testing other player has drawn a card deck decrease by 1
Test Result: Fail. Other player deck did not decreased by 1
Test Result: actual deckCount: 5, expected deckCount: 4
Final tally for Card Test 4 ( Council Room ):
Pass: 6
Fail: 8
File 'cardtest4.c'
Lines executed:82.00% of 100
Branches executed:100.00% of 36
Taken at least once:58.33% of 36
Calls executed:68.75% of 32
Creating 'cardtest4.c.gcov'

        -:    0:Source:cardtest4.c
        -:    0:Graph:cardtest4.gcno
        -:    0:Data:cardtest4.gcda
        -:    0:Runs:8
        -:    0:Programs:1
        -:    1:/* Card Test for Council Room
        -:    2:   Previous game state: playing 2 player Dominion game, Council Room card is played
        -:    3:   Tests will cover:
        -:    4:   - if hand count was increased by 3
        -:    5:   - if council_room remains in hand after playing
        -:    6:   - if number of buys increased by 1
        -:    7:   - if Council Room card is discarded
        -:    8:   - if deck count is decreased by 4
        -:    9:   - other player has drawn a card hand increase by 1
        -:   10:   - other player has drawn a card deck decrease by 1
        -:   11:*/
        -:   12:#include "dominion.h"
        -:   13:#include "dominion_helpers.h"
        -:   14:#include "rngs.h"
        -:   15:#include <stdio.h>
        -:   16:#include <string.h>
        -:   17:#include <assert.h>
        -:   18:
        -:   19:#define NOISY_TEST 1
        -:   20:
        -:   21:int cardExists(int turn, struct gameState *state, int target);
        -:   22:
function main called 8 returned 100% blocks executed 75%
        8:   23:int main()
        -:   24:{
        -:   25:    int startgame;
        -:   26:    int turn;
        8:   27:    int players = 2;
        8:   28:    int seed = 1000;
        8:   29:    int kingdomCards[10] = { gardens, adventurer, council_room, baron, mine, remodel, feast, smithy, village, great_hall };
        -:   30:	struct gameState previous; 
        -:   31:    struct gameState post; 
        -:   32:    int i;
        -:   33:	int r;
        8:   34:    int testruns = 1; 
        8:   35:    int finalfail = 0;
        8:   36:    int finalpass = 0;
        8:   37:	int tmp2 = 0;
        8:   38:	int tmp3 = 0;
        8:   39:	int tmp4 = 0;
        -:   40:#if (NOISY_TEST == 1)
        8:   41:    const char* domCards[] =  {"curse", "estate", "duchy", "province", "copper", "silver", "gold", "adventurer", "council_room", "feast",
        -:   42:        "gardens", "mine", "remodel", "smithy", "village", "baron", "great_hall", "minion", "steward", "tribute",
        -:   43:        "ambassador", "cutpurse", "embargo", "outpost", "salvager", "sea_hag", "treasure_map"};
        -:   44:#endif
        -:   45:	/* Looping through amount of test runs */
       16:   46:    for (i = 0; i < testruns; i++)
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        -:   47:    {
        -:   48:        /* Start with a new game */
        8:   49:		memset(&previous, 23, sizeof(struct gameState));   
        8:   50:        startgame = initializeGame(players, kingdomCards, seed, &previous); 
call    0 returned 100%
       24:   51:		for (turn = 0; turn < players; turn++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:   52:        {
        -:   53:			/* For current player, initialize the hand and deck */
       16:   54:            previous.handCount[turn] = 1;       
        -:   55:            int inithand[1];
       16:   56:            inithand[0] = council_room;
       16:   57:            memcpy(previous.hand[turn], inithand, sizeof(int));
       16:   58:            previous.deckCount[turn] = 5;       
        -:   59:            int initdeck[5];
       16:   60:            initdeck[0] = copper;
       16:   61:            initdeck[1] = silver;
       16:   62:            initdeck[2] = gold;
       16:   63:            initdeck[3] = gardens;
       16:   64:            initdeck[4] = tribute;
       16:   65:            memcpy(previous.deck[turn], initdeck, sizeof(int) * 5);
        -:   66:			/* The post game state will be a copy of the previous game state with tests ran on it */
       16:   67:            memcpy(&post, &previous, sizeof(struct gameState)); 
       16:   68:            playCouncil_Room(turn, &post, 0);
call    0 returned 100%
       16:   69:			tmp2 = previous.deckCount[turn];
       16:   70:			tmp3 = previous.discardCount[turn];
       16:   71:			tmp4 = previous.handCount[turn];
       16:   72:			int expNumAct = 0;
       16:   73:			int newcard = 0;
        -:   74:#if (NOISY_TEST == 1)			
       16:   75:			printf("\nTesting if hand count was increased by 3\n");
call    0 returned 100%
        -:   76:#endif			
        -:   77:			/* When council_room is played, it adds 4 cards to the players hand but also discards the council room */               
       16:   78:			if ( (tmp4 + 3) != post.handCount[turn] )
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   79:			{
       16:   80:				finalfail++;
        -:   81:			}
        -:   82:			else
        -:   83:			{
    #####:   84:				finalpass++;
        -:   85:			}
        -:   86:#if (NOISY_TEST == 1)
       16:   87:			if ( (tmp4 + 3) != post.handCount[turn] )
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   88:			{
       16:   89:				printf("Handcount test failed\n");
call    0 returned 100%
       16:   90:				printf("Test Result: actual handCount: %d, expected handCount: %d\r\n", post.handCount[turn], (tmp4 + 3) );
call    0 returned 100%
        -:   91:			}
        -:   92:			else
        -:   93:			{
    #####:   94:				printf("Test Result: actual handCount: %d, expected handCount: %d\r\n", post.handCount[turn], (tmp4 + 3) );
call    0 never executed
        -:   95:			}
       16:   96:			printf("\nTesting if council_room remains in hand after playing\n");
call    0 returned 100%
        -:   97:#endif           
        -:   98:			/* When council_room is played, it should leave hand  */ 
       16:   99:            r = cardExists(turn, &post, council_room);
call    0 returned 100%
        -:  100:			/* If council_room is not in hand then it pass */
       16:  101:            if ( r == -1 ) 
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  102:            {
       16:  103:               finalpass++;
        -:  104:            }
        -:  105:            else
        -:  106:            {
    #####:  107:                finalfail++;
        -:  108:            }
        -:  109:#if (NOISY_TEST == 1)
       16:  110:            if (r == -1) 
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  111:            {
       16:  112:               printf("Test Result: Pass. Council Room not in the hand after playing\r\n");
call    0 returned 100%
        -:  113:            }
        -:  114:            else
        -:  115:            {
    #####:  116:                printf("Test Result: Fail. Council Room still in hand after playing\r\n");
call    0 never executed
        -:  117:            }
       16:  118:			printf("\nTesting if number of buys increased by 1\n");
call    0 returned 100%
        -:  119:#endif           
        -:  120:            
        -:  121:			/* When playing Council Room, num of buys should increase by 1 for a pass */
       16:  122:			expNumAct = previous.numBuys + 1;
       16:  123:			if ( expNumAct != post.numBuys )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  124:			{
    #####:  125:				finalfail++;
        -:  126:			}
        -:  127:			else
        -:  128:			{
       16:  129:				finalpass++;
        -:  130:			}
        -:  131:#if (NOISY_TEST == 1)
       16:  132:            if ( expNumAct != post.numBuys )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  133:			{
    #####:  134:				printf("Number buys test failed\n");
call    0 never executed
    #####:  135:				printf("Test Result: actual number buys: %d, expected number buys: %d\r\n", post.numBuys, expNumAct );   
call    0 never executed
        -:  136:			}
        -:  137:			else
        -:  138:			{
       16:  139:				printf("Test Result: actual number buys: %d, expected number buys: %d\r\n", post.numBuys, expNumAct );   
call    0 returned 100%
        -:  140:			}
       16:  141:			printf("\nTesting if Council Room card is discarded\n");	
call    0 returned 100%
        -:  142:#endif
        -:  143:            /* Council Room card should be discarded after playing so it should be at the top of the discard pile */ 
       16:  144:            if(post.playedCards[post.playedCardCount - 1] != council_room )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  145:			{
    #####:  146:				finalfail++;  
        -:  147:			}
        -:  148:			else
        -:  149:			{
       16:  150:				finalpass++;
        -:  151:			}
        -:  152:#if (NOISY_TEST == 1)
       16:  153:            if ( post.playedCards[post.playedCardCount - 1] != council_room )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  154:			{
    #####:  155:				printf("Council Room discard test failed\n");
call    0 never executed
        -:  156:			}
        -:  157:			else
        -:  158:			{
       16:  159:				printf("Test Result: Pass. Council Room card has been discarded\n");   
call    0 returned 100%
        -:  160:			}
       16:  161:			printf("\nTesting deck count is decreased by 4\n");			
call    0 returned 100%
        -:  162:#endif   
        -:  163:			/* When Council Room is played, it takes four cards off the players deck (4 cards + 1 buy card - 1 council room) */
       16:  164:			expNumAct = tmp2 - 4;
       16:  165:			if( expNumAct != post.deckCount[turn] )
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  166:			{
       16:  167:				finalfail++;  
        -:  168:			}
        -:  169:			else
        -:  170:			{
    #####:  171:				finalpass++;
        -:  172:			}
        -:  173:#if (NOISY_TEST == 1)
       16:  174:			if ( expNumAct != post.deckCount[turn] )
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  175:			{
       16:  176:				printf("Deckcount test failed\n");
call    0 returned 100%
       16:  177:				printf("Test Result: actual deckCount: %d, expected deckCount: %d\r\n", post.deckCount[turn], expNumAct );
call    0 returned 100%
        -:  178:			}
        -:  179:			else
        -:  180:			{
    #####:  181:				printf("Test Result: actual deckCount: %d, expected deckCount: %d\r\n", post.deckCount[turn], expNumAct );
call    0 never executed
        -:  182:			}
       16:  183:			printf("\nTesting other player has drawn a card hand increase by 1\n");			
call    0 returned 100%
        -:  184:#endif   
        -:  185:			/* When Council Room is played, other player draw a card from deck /hand increase by 1*/
       16:  186:			if( (previous.handCount[1 - turn] + 1) != post.handCount[1 - turn] )
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  187:			{
       16:  188:				finalfail++;  
        -:  189:			}
        -:  190:			else
        -:  191:			{
    #####:  192:				finalpass++;
        -:  193:			}
        -:  194:#if (NOISY_TEST == 1)
       16:  195:			if ( (previous.handCount[1 - turn] + 1) != post.handCount[1 - turn] )
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  196:			{
       16:  197:				printf("Test Result: Fail. Other player hand did not increase by 1\n");
call    0 returned 100%
       16:  198:				printf("Test Result: actual handCount: %d, expected handCount: %d\r\n", post.handCount[1 - turn],  (previous.handCount[1 - turn] + 1) );
call    0 returned 100%
        -:  199:			}
        -:  200:			else
        -:  201:			{
    #####:  202:				printf("Test Result: Pass. Other player hand increased by 1\n");
call    0 never executed
    #####:  203:				printf("Test Result: actual handCount: %d, expected handCount: %d\r\n", post.handCount[1 - turn],  (previous.handCount[1 - turn] + 1) );
call    0 never executed
        -:  204:			}
       16:  205:			printf("\nTesting other player has drawn a card deck decrease by 1\n");
call    0 returned 100%
        -:  206:#endif
        -:  207:/* When Council Room is played, other player draw a card from hand */
       16:  208:			if( (previous.deckCount[1 - turn] - 1) != post.deckCount[1 - turn] )
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  209:			{
       16:  210:				finalfail++;  
        -:  211:			}
        -:  212:			else
        -:  213:			{
    #####:  214:				finalpass++;
        -:  215:			}
        -:  216:#if (NOISY_TEST == 1)
       16:  217:			if ( (previous.deckCount[1 - turn] - 1) != post.deckCount[1 - turn] )
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  218:			{
       16:  219:				printf("Test Result: Fail. Other player deck did not decreased by 1\n");
call    0 returned 100%
       16:  220:				printf("Test Result: actual deckCount: %d, expected deckCount: %d\r\n", post.deckCount[1 - turn], (previous.deckCount[1 - turn] - 1) );
call    0 returned 100%
        -:  221:			}
        -:  222:			else
        -:  223:			{
    #####:  224:				printf("Test Result: Pass. Other player deck decreased by 1\n");
call    0 never executed
    #####:  225:				printf("Test Result: actual deckCount: %d, expected deckCount: %d\r\n", post.deckCount[1 - turn], (previous.deckCount[1 - turn] - 1) );
call    0 never executed
        -:  226:			}
        -:  227:#endif			
        -:  228:          }
        -:  229:     }
        8:  230:    printf("Final tally for Card Test 4 ( Council Room ):\nPass: %d\nFail: %d\r\n",finalpass, finalfail );
call    0 returned 100%
        8:  231:    return 0;
        -:  232:}
        -:  233:
        -:  234:
function cardExists called 16 returned 100% blocks executed 86%
       16:  235:int cardExists(int turn, struct gameState *state, int target)
        -:  236:{
        -:  237:    /* Initalize flag to doesn't exist */
       16:  238:	int cardexists = -1;
        -:  239:    /* Retrieve size of played cards, hand or deck for checking loop */
       16:  240:	int loopsize = state->handCount[turn];;
        -:  241:	/* Find size of loop for played cards, ahnd or deck */
        -:  242:    int i;
       96:  243:    for (i = 0; i < loopsize; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:  244:    {
        -:  245:        /* If checking player's hand for a certain card, use this loop */
       80:  246:        if (state->hand[turn][i] == target)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  247:        {
    #####:  248:                 cardexists = i;
        -:  249:        }
        -:  250:    }
       16:  251:    return cardexists;
        -:  252:} 
File 'dominion.c'
Lines executed:33.69% of 561
Branches executed:36.45% of 417
Taken at least once:26.38% of 417
Calls executed:20.83% of 96
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:64
        -:    0:Programs:14
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 17304000 returned 100% blocks executed 83%
 17304000:    8:int compare(const void* a, const void* b) {
 17304000:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   10:    return 1;
 17304000:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
  4614400:   12:    return -1;
 12689600:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 576800 returned 100% blocks executed 88%
   576800:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
   576800:   44:  SelectStream(1);
call    0 returned 100%
   576800:   45:  PutSeed((long)randomSeed);
call    0 returned 100%
        -:   46:  
        -:   47:  //check number of players
   576800:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
   576800:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
  6344800:   57:  for (i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   58:    {
 63448000:   59:      for (j = 0; j < 10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   60:        {
 57680000:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
   576800:   73:  if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   74:    {
   576800:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
    #####:   77:  else if (numPlayers == 3)
branch  0 never executed
branch  1 never executed
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
   576800:   87:  if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   88:    {
   576800:   89:      state->supplyCount[estate] = 8;
   576800:   90:      state->supplyCount[duchy] = 8;
   576800:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
   576800:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
   576800:  102:  state->supplyCount[silver] = 40;
   576800:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
 12112800:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  107:    {
 95172000:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  109:	{
 89404000:  110:	  if (kingdomCards[j] == i)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
  5768000:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 11% (fallthrough)
branch  3 taken 89%
        -:  114:		{
  2300096:  115:		  if (numPlayers == 2){ 
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  1150048:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
  4617952:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
  5768000:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
 83636000:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
  1730400:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  139:    {
  1153600:  140:      state->deckCount[i] = 0;
  4614400:  141:      for (j = 0; j < 3; j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  142:	{
  3460800:  143:	  state->deck[i][j] = estate;
  3460800:  144:	  state->deckCount[i]++;
        -:  145:	}
  9228800:  146:      for (j = 3; j < 10; j++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -:  147:	{
  8075200:  148:	  state->deck[i][j] = copper;
  8075200:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
  1730400:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  155:    {
  1153600:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
  1730400:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
  1153600:  166:      state->handCount[i] = 0;
  1153600:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
 16150400:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  177:    {
 15573600:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
   576800:  182:  state->outpostPlayed = 0;
   576800:  183:  state->phase = 0;
   576800:  184:  state->numActions = 1;
   576800:  185:  state->numBuys = 1;
   576800:  186:  state->playedCardCount = 0;
   576800:  187:  state->whoseTurn = 0;
   576800:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
  3460800:  192:  for (it = 0; it < 5; it++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
  2884000:  193:    drawCard(state->whoseTurn, state);
call    0 returned 100%
        -:  194:  }
        -:  195:
   576800:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 100%
        -:  197:
   576800:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 1153600 returned 100% blocks executed 94%
  1153600:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
  1153600:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
  1153600:  209:  if (state->deckCount[player] < 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  210:    return -1;
  1153600:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 100%
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
 13843200:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
 11536000:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 100%
 11536000:  216:    newDeck[newDeckPos] = state->deck[player][card];
 11536000:  217:    newDeckPos++;
 40376000:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 71%
branch  1 taken 29% (fallthrough)
 28840000:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
 11536000:  221:    state->deckCount[player]--;
        -:  222:  }
 12689600:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
 11536000:  224:    state->deck[player][i] = newDeck[i];
 11536000:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
  1153600:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 216 returned 100% blocks executed 93%
      216:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
      216:  280:  who = state->whoseTurn;
        -:  281:
      216:  282:  if (state->numBuys < 1){
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
       72:  285:    return -1;
      144:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
       72:  289:    return -1;
       72:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
       72:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
       72:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 returned 100%
        -:  298:  
       72:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 returned 100%
       72:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
       72:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 216 returned 100% blocks executed 100%
      216:  320:int supplyCount(int card, struct gameState *state) {
      216:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 574992 returned 100% blocks executed 100%
   574992:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
   574992:  326:  int count = 0;
        -:  327:
  3449952:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:  329:    {
  2874960:  330:      if (state->deck[player][i] == card) count++;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  331:    }
        -:  332:
  3449952:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:  334:    {
  2874960:  335:      if (state->hand[player][i] == card) count++;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  336:    }
        -:  337:
  3449952:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:  339:    {
  2874960:  340:      if (state->discard[player][i] == card) count++;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  341:    }
        -:  342:
   574992:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 0 returned 0% blocks executed 0%
    #####:  346:int whoseTurn(struct gameState *state) {
    #####:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
    #####:  353:  int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  354:  
        -:  355:  //Discard hand
    #####:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
    #####:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
    #####:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 never executed
branch  1 never executed
    #####:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
    #####:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
    #####:  370:  state->outpostPlayed = 0;
    #####:  371:  state->phase = 0;
    #####:  372:  state->numActions = 1;
    #####:  373:  state->coins = 0;
    #####:  374:  state->numBuys = 1;
    #####:  375:  state->playedCardCount = 0;
    #####:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    #####:  380:  for (k = 0; k < 5; k++){
branch  0 never executed
branch  1 never executed
    #####:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  382:  }
        -:  383:
        -:  384:  //Update money
    #####:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 never executed
        -:  386:
    #####:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 208 returned 100% blocks executed 100%
      208:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
      208:  395:  if (state->supplyCount[province] == 0)
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
        -:  396:    {
       16:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
      192:  401:  j = 0;
     4992:  402:  for (i = 0; i < 25; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  403:    {
     4800:  404:      if (state->supplyCount[i] == 0)
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
        -:  405:	{
      560:  406:	  j++;
        -:  407:	}
        -:  408:    }
      192:  409:  if ( j >= 3)
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
        -:  410:    {
      176:  411:      return 1;
        -:  412:    }
        -:  413:
       16:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 2884224 returned 100% blocks executed 38%
  2884224:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
  2884224:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
    #####:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 never executed
branch  1 never executed
    #####:  534:      state->deck[player][i] = state->discard[player][i];
    #####:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
    #####:  538:    state->deckCount[player] = state->discardCount[player];
    #####:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
    #####:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 never executed
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
    #####:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
    #####:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
    #####:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
    #####:  559:    if (deckCounter == 0)
branch  0 never executed
branch  1 never executed
    #####:  560:      return -1;
        -:  561:
    #####:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  563:    state->deckCount[player]--;
    #####:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
  2884224:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
  2884224:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
  2884224:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
  2884224:  576:    state->deckCount[player]--;
  2884224:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
  2884224:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 144 returned 100% blocks executed 37%
      144:  583:int getCost(int cardNumber)
        -:  584:{
      144:  585:  switch( cardNumber ) 
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 0%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 11%
branch  8 taken 11%
branch  9 taken 11%
branch 10 taken 0%
branch 11 taken 11%
branch 12 taken 11%
branch 13 taken 11%
branch 14 taken 11%
branch 15 taken 11%
branch 16 taken 0%
branch 17 taken 0%
branch 18 taken 0%
branch 19 taken 11%
branch 20 taken 0%
branch 21 taken 0%
branch 22 taken 0%
branch 23 taken 0%
branch 24 taken 0%
branch 25 taken 0%
branch 26 taken 0%
branch 27 taken 0%
        -:  586:    {
        -:  587:    case curse:
    #####:  588:      return 0;
        -:  589:    case estate:
    #####:  590:      return 2;
        -:  591:    case duchy:
    #####:  592:      return 5;
        -:  593:    case province:
    #####:  594:      return 8;
        -:  595:    case copper:
    #####:  596:      return 0;
        -:  597:    case silver:
    #####:  598:      return 3;
        -:  599:    case gold:
    #####:  600:      return 6;
        -:  601:    case adventurer:
       16:  602:      return 6;
        -:  603:    case council_room:
       16:  604:      return 5;
        -:  605:    case feast:
       16:  606:      return 4;
        -:  607:    case gardens:
    #####:  608:      return 4;
        -:  609:    case mine:
       16:  610:      return 5;
        -:  611:    case remodel:
       16:  612:      return 4;
        -:  613:    case smithy:
       16:  614:      return 4;
        -:  615:    case village:
       16:  616:      return 3;
        -:  617:    case baron:
       16:  618:      return 4;
        -:  619:    case great_hall:
    #####:  620:      return 3;
        -:  621:    case minion:
    #####:  622:      return 5;
        -:  623:    case steward:
    #####:  624:      return 3;
        -:  625:    case tribute:
       16:  626:      return 5;
        -:  627:    case ambassador:
    #####:  628:      return 3;
        -:  629:    case cutpurse:
    #####:  630:      return 4;
        -:  631:    case embargo: 
    #####:  632:      return 2;
        -:  633:    case outpost:
    #####:  634:      return 5;
        -:  635:    case salvager:
    #####:  636:      return 4;
        -:  637:    case sea_hag:
    #####:  638:      return 4;
        -:  639:    case treasure_map:
    #####:  640:      return 4;
        -:  641:    }
        -:  642:	
    #####:  643:  return -1;
        -:  644:}
        -:  645:
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  646:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  647:{
        -:  648:  int i;
        -:  649:  int j;
        -:  650:  int k;
        -:  651:  int x;
        -:  652:  int index;
    #####:  653:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  654:  int nextPlayer = currentPlayer + 1;
        -:  655:
    #####:  656:  int tributeRevealedCards[2] = {-1, -1};
        -:  657:  int temphand[MAX_HAND];// moved above the if statement
    #####:  658:  int drawntreasure=0;
        -:  659:  int cardDrawn;
    #####:  660:  int z = 0;// this is the counter for the temp hand
    #####:  661:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  662:    nextPlayer = 0;
        -:  663:  }
        -:  664:  
        -:  665:	
        -:  666:  //uses switch to select card and perform actions
    #####:  667:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  668:    {
        -:  669:    case adventurer:
        -:  670:    	//Previous content replaced with call to refactored function
    #####:  671:	return playAdventurer(state, currentPlayer);
call    0 never executed
        -:  672:			
        -:  673:    case council_room:
        -:  674:	//Previous content replaced with call to refactored function 
    #####:  675:	return playCouncil_Room(currentPlayer, state, handPos);
call    0 never executed
        -:  676:	
        -:  677:    case feast:
    #####:  678:	return playFeast(state, choice1);  
call    0 never executed
        -:  679:			
        -:  680:    case gardens:
    #####:  681:      return -1;
        -:  682:			
        -:  683:    case mine:
    #####:  684:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  685:
    #####:  686:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  687:	{
    #####:  688:	  return -1;
        -:  689:	}
        -:  690:		
    #####:  691:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  692:	{
    #####:  693:	  return -1;
        -:  694:	}
        -:  695:
    #####:  696:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  697:	{
    #####:  698:	  return -1;
        -:  699:	}
        -:  700:
    #####:  701:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  702:
        -:  703:      //discard card from hand
    #####:  704:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  705:
        -:  706:      //discard trashed card
    #####:  707:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  708:	{
    #####:  709:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  710:	    {
    #####:  711:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  712:	      break;
        -:  713:	    }
        -:  714:	}
        -:  715:			
    #####:  716:      return 0;
        -:  717:			
        -:  718:    case remodel:
    #####:  719:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  720:
    #####:  721:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  722:	{
    #####:  723:	  return -1;
        -:  724:	}
        -:  725:
    #####:  726:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  727:
        -:  728:      //discard card from hand
    #####:  729:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  730:
        -:  731:      //discard trashed card
    #####:  732:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  733:	{
    #####:  734:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  735:	    {
    #####:  736:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  737:	      break;
        -:  738:	    }
        -:  739:	}
        -:  740:
        -:  741:
    #####:  742:      return 0;
        -:  743:		
        -:  744:    case smithy:
    #####:  745:    	 return playSmithy(currentPlayer, state, handPos);;
call    0 never executed
        -:  746:		
        -:  747:    case village:
    #####:  748:    	return playVillage(currentPlayer, state, handPos);
call    0 never executed
        -:  749:		
        -:  750:    case baron:
    #####:  751:      state->numBuys++;//Increase buys by 1!
    #####:  752:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  753:	int p = 0;//Iterator for hand!
    #####:  754:	int card_not_discarded = 1;//Flag for discard set!
    #####:  755:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####:  756:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  757:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  758:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  759:	    state->discardCount[currentPlayer]++;
    #####:  760:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####:  761:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  762:	    }
    #####:  763:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  764:	    state->handCount[currentPlayer]--;
    #####:  765:	    card_not_discarded = 0;//Exit the loop
        -:  766:	  }
    #####:  767:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -:  768:	    if(DEBUG) {
        -:  769:	      printf("No estate cards in your hand, invalid choice\n");
        -:  770:	      printf("Must gain an estate if there are any\n");
        -:  771:	    }
    #####:  772:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  773:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  774:	      state->supplyCount[estate]--;//Decrement estates
    #####:  775:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  776:		isGameOver(state);
call    0 never executed
        -:  777:	      }
        -:  778:	    }
    #####:  779:	    card_not_discarded = 0;//Exit the loop
        -:  780:	  }
        -:  781:			    
        -:  782:	  else{
    #####:  783:	    p++;//Next card
        -:  784:	  }
        -:  785:	}
        -:  786:      }
        -:  787:			    
        -:  788:      else{
    #####:  789:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  790:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  791:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  792:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  793:	    isGameOver(state);
call    0 never executed
        -:  794:	  }
        -:  795:	}
        -:  796:      }
        -:  797:	    
        -:  798:      
    #####:  799:      return 0;
        -:  800:		
        -:  801:    case great_hall:
        -:  802:      //+1 Card
    #####:  803:      drawCard(currentPlayer, state);
call    0 never executed
        -:  804:			
        -:  805:      //+1 Actions
    #####:  806:      state->numActions++;
        -:  807:			
        -:  808:      //discard card from hand
    #####:  809:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  810:      return 0;
        -:  811:		
        -:  812:    case minion:
        -:  813:      //+1 action
    #####:  814:      state->numActions++;
        -:  815:			
        -:  816:      //discard card from hand
    #####:  817:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  818:			
    #####:  819:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  820:	{
    #####:  821:	  state->coins = state->coins + 2;
        -:  822:	}
        -:  823:			
    #####:  824:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  825:	{
        -:  826:	  //discard hand
    #####:  827:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  828:	    {
    #####:  829:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  830:	    }
        -:  831:				
        -:  832:	  //draw 4
    #####:  833:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  834:	    {
    #####:  835:	      drawCard(currentPlayer, state);
call    0 never executed
        -:  836:	    }
        -:  837:				
        -:  838:	  //other players discard hand and redraw if hand size > 4
    #####:  839:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  840:	    {
    #####:  841:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:  842:		{
    #####:  843:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -:  844:		    {
        -:  845:		      //discard hand
    #####:  846:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -:  847:			{
    #####:  848:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -:  849:			}
        -:  850:							
        -:  851:		      //draw 4
    #####:  852:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -:  853:			{
    #####:  854:			  drawCard(i, state);
call    0 never executed
        -:  855:			}
        -:  856:		    }
        -:  857:		}
        -:  858:	    }
        -:  859:				
        -:  860:	}
    #####:  861:      return 0;
        -:  862:		
        -:  863:    case steward:
    #####:  864:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -:  865:	{
        -:  866:	  //+2 cards
    #####:  867:	  drawCard(currentPlayer, state);
call    0 never executed
    #####:  868:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  869:	}
    #####:  870:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -:  871:	{
        -:  872:	  //+2 coins
    #####:  873:	  state->coins = state->coins + 2;
        -:  874:	}
        -:  875:      else
        -:  876:	{
        -:  877:	  //trash 2 cards in hand
    #####:  878:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####:  879:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -:  880:	}
        -:  881:			
        -:  882:      //discard card from hand
    #####:  883:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  884:      return 0;
        -:  885:		
        -:  886:    case tribute:
    #####:  887:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####:  888:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####:  889:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  890:	  state->deckCount[nextPlayer]--;
        -:  891:	}
    #####:  892:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####:  893:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  894:	  state->discardCount[nextPlayer]--;
        -:  895:	}
        -:  896:	else{
        -:  897:	  //No Card to Reveal
        -:  898:	  if (DEBUG){
        -:  899:	    printf("No cards to reveal\n");
        -:  900:	  }
        -:  901:	}
        -:  902:      }
        -:  903:	    
        -:  904:      else{
    #####:  905:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####:  906:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  907:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  908:	    state->deckCount[nextPlayer]++;
    #####:  909:	    state->discard[nextPlayer][i] = -1;
    #####:  910:	    state->discardCount[nextPlayer]--;
        -:  911:	  }
        -:  912:			    
    #####:  913:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -:  914:	} 
    #####:  915:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  916:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  917:	state->deckCount[nextPlayer]--;
    #####:  918:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  919:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  920:	state->deckCount[nextPlayer]--;
        -:  921:      }    
        -:  922:		       
    #####:  923:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####:  924:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  925:	state->playedCardCount++;
    #####:  926:	tributeRevealedCards[1] = -1;
        -:  927:      }
        -:  928:
    #####:  929:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####:  930:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  931:	  state->coins += 2;
        -:  932:	}
        -:  933:		    
    #####:  934:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:  935:	  drawCard(currentPlayer, state);
call    0 never executed
    #####:  936:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  937:	}
        -:  938:	else{//Action Card
    #####:  939:	  state->numActions = state->numActions + 2;
        -:  940:	}
        -:  941:      }
        -:  942:	    
    #####:  943:      return 0;
        -:  944:		
        -:  945:    case ambassador:
    #####:  946:      j = 0;		//used to check if player has enough cards to discard
        -:  947:
    #####:  948:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  949:	{
    #####:  950:	  return -1;				
        -:  951:	}
        -:  952:
    #####:  953:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -:  954:	{
    #####:  955:	  return -1;
        -:  956:	}
        -:  957:
    #####:  958:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  959:	{
    #####:  960:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  961:	    {
    #####:  962:	      j++;
        -:  963:	    }
        -:  964:	}
    #####:  965:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -:  966:	{
    #####:  967:	  return -1;				
        -:  968:	}
        -:  969:
        -:  970:      if (DEBUG) 
        -:  971:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -:  972:
        -:  973:      //increase supply count for choosen card by amount being discarded
    #####:  974:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -:  975:			
        -:  976:      //each other player gains a copy of revealed card
    #####:  977:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  978:	{
    #####:  979:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:  980:	    {
    #####:  981:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -:  982:	    }
        -:  983:	}
        -:  984:
        -:  985:      //discard played card from hand
    #####:  986:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -:  987:
        -:  988:      //trash copies of cards returned to supply
    #####:  989:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -:  990:	{
    #####:  991:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  992:	    {
    #####:  993:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -:  994:		{
    #####:  995:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####:  996:		  break;
        -:  997:		}
        -:  998:	    }
        -:  999:	}			
        -: 1000:
    #####: 1001:      return 0;
        -: 1002:		
        -: 1003:    case cutpurse:
        -: 1004:
    #####: 1005:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1006:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1007:	{
    #####: 1008:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1009:	    {
    #####: 1010:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1011:		{
    #####: 1012:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1013:		    {
    #####: 1014:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1015:		      break;
        -: 1016:		    }
    #####: 1017:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1018:		    {
    #####: 1019:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1020:			{
        -: 1021:			  if (DEBUG)
        -: 1022:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1023:			}	
    #####: 1024:		      break;
        -: 1025:		    }		
        -: 1026:		}
        -: 1027:					
        -: 1028:	    }
        -: 1029:				
        -: 1030:	}				
        -: 1031:
        -: 1032:      //discard played card from hand
    #####: 1033:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1034:
    #####: 1035:      return 0;
        -: 1036:
        -: 1037:		
        -: 1038:    case embargo: 
        -: 1039:      //+2 Coins
    #####: 1040:      state->coins = state->coins + 2;
        -: 1041:			
        -: 1042:      //see if selected pile is in play
    #####: 1043:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -: 1044:	{
    #####: 1045:	  return -1;
        -: 1046:	}
        -: 1047:			
        -: 1048:      //add embargo token to selected supply pile
    #####: 1049:      state->embargoTokens[choice1]++;
        -: 1050:			
        -: 1051:      //trash card
    #####: 1052:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####: 1053:      return 0;
        -: 1054:		
        -: 1055:    case outpost:
        -: 1056:      //set outpost flag
    #####: 1057:      state->outpostPlayed++;
        -: 1058:			
        -: 1059:      //discard card
    #####: 1060:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1061:      return 0;
        -: 1062:		
        -: 1063:    case salvager:
        -: 1064:      //+1 buy
    #####: 1065:      state->numBuys++;
        -: 1066:			
    #####: 1067:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1068:	{
        -: 1069:	  //gain coins equal to trashed card
    #####: 1070:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1071:	  //trash card
    #####: 1072:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1073:	}
        -: 1074:			
        -: 1075:      //discard card
    #####: 1076:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1077:      return 0;
        -: 1078:		
        -: 1079:    case sea_hag:
    #####: 1080:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1081:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1082:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1083:	  state->discardCount[i]++;
    #####: 1084:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1085:	}
        -: 1086:      }
    #####: 1087:      return 0;
        -: 1088:		
        -: 1089:    case treasure_map:
        -: 1090:      //search hand for another treasure_map
    #####: 1091:      index = -1;
    #####: 1092:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1093:	{
    #####: 1094:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1095:	    {
    #####: 1096:	      index = i;
    #####: 1097:	      break;
        -: 1098:	    }
        -: 1099:	}
    #####: 1100:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1101:	{
        -: 1102:	  //trash both treasure cards
    #####: 1103:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1104:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1105:
        -: 1106:	  //gain 4 Gold cards
    #####: 1107:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1108:	    {
    #####: 1109:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1110:	    }
        -: 1111:				
        -: 1112:	  //return success
    #####: 1113:	  return 1;
        -: 1114:	}
        -: 1115:			
        -: 1116:      //no second treasure_map found in hand
    #####: 1117:      return -1;
        -: 1118:    }
        -: 1119:	
    #####: 1120:  return -1;
        -: 1121:}
        -: 1122:
function discardCard called 48 returned 100% blocks executed 78%
       48: 1123:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1124:{
        -: 1125:	
        -: 1126:  //if card is not trashed, added to Played pile 
       48: 1127:  if (trashFlag < 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1128:    {
        -: 1129:      //add card to played pile
       48: 1130:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
       48: 1131:      state->playedCardCount++;
        -: 1132:    }
        -: 1133:	
        -: 1134:  //set played card to -1
       48: 1135:  state->hand[currentPlayer][handPos] = -1;
        -: 1136:	
        -: 1137:  //remove card from player's hand
       48: 1138:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1139:    {
        -: 1140:      //reduce number of cards in hand
    #####: 1141:      state->handCount[currentPlayer]--;
        -: 1142:    }
       48: 1143:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1144:    {
        -: 1145:      //reduce number of cards in hand
    #####: 1146:      state->handCount[currentPlayer]--;
        -: 1147:    }
        -: 1148:  else 	
        -: 1149:    {
        -: 1150:      //replace discarded card with last card in hand
       48: 1151:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1152:      //set last card to -1
       48: 1153:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1154:      //reduce number of cards in hand
       48: 1155:      state->handCount[currentPlayer]--;
        -: 1156:    }
        -: 1157:	
       48: 1158:  return 0;
        -: 1159:}
        -: 1160:
function gainCard called 72 returned 100% blocks executed 70%
       72: 1161:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1162:{
        -: 1163:  //Note: supplyPos is enum of choosen card
        -: 1164:	
        -: 1165:  //check if supply pile is empty (0) or card is not used in game (-1)
       72: 1166:  if ( supplyCount(supplyPos, state) < 1 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1167:    {
    #####: 1168:      return -1;
        -: 1169:    }
        -: 1170:	
        -: 1171:  //added card for [whoseTurn] current player:
        -: 1172:  // toFlag = 0 : add to discard
        -: 1173:  // toFlag = 1 : add to deck
        -: 1174:  // toFlag = 2 : add to hand
        -: 1175:
       72: 1176:  if (toFlag == 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1177:    {
    #####: 1178:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1179:      state->deckCount[player]++;
        -: 1180:    }
       72: 1181:  else if (toFlag == 2)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1182:    {
    #####: 1183:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1184:      state->handCount[player]++;
        -: 1185:    }
        -: 1186:  else
        -: 1187:    {
       72: 1188:      state->discard[player][ state->discardCount[player] ] = supplyPos;
       72: 1189:      state->discardCount[player]++;
        -: 1190:    }
        -: 1191:	
        -: 1192:  //decrease number in supply pile
       72: 1193:  state->supplyCount[supplyPos]--;
        -: 1194:	 
       72: 1195:  return 0;
        -: 1196:}
        -: 1197:
function updateCoins called 582096 returned 100% blocks executed 100%
   582096: 1198:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1199:{
        -: 1200:  int i;
        -: 1201:	
        -: 1202:  //reset coin count
   582096: 1203:  state->coins = 0;
        -: 1204:
        -: 1205:  //add coins for each Treasure card in player's hand
  3495216: 1206:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -: 1207:    {
  2913120: 1208:      if (state->hand[player][i] == copper)
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -: 1209:	{
  2316880: 1210:	  state->coins += 1;
        -: 1211:	}
   596240: 1212:      else if (state->hand[player][i] == silver)
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
        -: 1213:	{
     9680: 1214:	  state->coins += 2;
        -: 1215:	}
   586560: 1216:      else if (state->hand[player][i] == gold)
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
        -: 1217:	{
     9680: 1218:	  state->coins += 3;
        -: 1219:	}	
        -: 1220:    }	
        -: 1221:
        -: 1222:  //add bonus
   582096: 1223:  state->coins += bonus;
        -: 1224:
   582096: 1225:  return 0;
        -: 1226:}
        -: 1227:
        -: 1228://Below is the refactored portion
function playAdventurer called 16 returned 100% blocks executed 93%
       16: 1229:int playAdventurer(struct gameState *state, int currentPlayer){
        -: 1230:	//Get the integer of player whose turn it is now	
        -: 1231:	//int currentPlayer = whoseTurn(state);
        -: 1232:	//Create variables for temp hand, last drawn card, and drawn treasure
       16: 1233:	int z = 0;
        -: 1234:	int cardDrawn;	
        -: 1235:	int temphand[MAX_HAND];
       16: 1236:	int drawntreasure = 1;
        -: 1237:	//Move the body of adventurer from Card Effects under variable declaration and initialization
       80: 1238:	while(drawntreasure < 2){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
       48: 1239:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1240:			shuffle(currentPlayer, state);
call    0 never executed
        -: 1241:		}
       48: 1242:		drawCard(currentPlayer, state);
call    0 returned 100%
       48: 1243:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
       48: 1244:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 33% (fallthrough)
branch  5 taken 67%
       16: 1245:			drawntreasure++;
        -: 1246:		else{
       32: 1247:			temphand[z]=cardDrawn;
       32: 1248:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
       32: 1249:			z++;
        -: 1250:		}
        -: 1251:    }
       64: 1252:    while(z-1>=0){
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
       32: 1253:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
       32: 1254:		z=z-1;
        -: 1255:     }
       16: 1256:     return 0;
        -: 1257:}
        -: 1258:
function playSmithy called 16 returned 100% blocks executed 100%
       16: 1259:int playSmithy(int currentPlayer, struct gameState *state, int handPos){
        -: 1260:  //Get the integer of player whose turn it is now
        -: 1261:  //int currentPlayer = whoseTurn(state);
        -: 1262:  int i;
        -: 1263:  //Move the body of smithy from Card Effects under variable declaration and initialization
       96: 1264:  for (i = 0; i <= 4; i++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
       80: 1265:      drawCard(currentPlayer, state);
call    0 returned 100%
        -: 1266:  }
        -: 1267:  
        -: 1268:  //discard card from hand
       16: 1269:  discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       16: 1270:  return 0;
        -: 1271:}
        -: 1272:
        -: 1273:
function playVillage called 16 returned 100% blocks executed 100%
       16: 1274:int playVillage(int currentPlayer, struct gameState *state, int handPos){
        -: 1275:	 //Get the integer of player whose turn it is now
        -: 1276:	// int currentPlayer = whoseTurn(state);
        -: 1277:	 //Move the body of village from Card Effects under variable declaration and initialization
        -: 1278:	 //+1 Card
       16: 1279:     drawCard(currentPlayer, state);
call    0 returned 100%
        -: 1280:	 //+2 Actions
       16: 1281:     state->numActions = state->numActions + 3;
        -: 1282:	 //discard played card from hand
       16: 1283:     discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       16: 1284:     return 0;
        -: 1285:}
        -: 1286:
function playFeast called 0 returned 0% blocks executed 0%
    #####: 1287:int playFeast(struct gameState *state, int choice1){
        -: 1288:	//Get the integer of player whose turn it is now
    #####: 1289:    int currentPlayer = whoseTurn(state);
call    0 never executed
        -: 1290:	int i, x;
        -: 1291:	int temphand[MAX_HAND];
        -: 1292:	//gain card with cost up to 5
        -: 1293:	//Backup hand
    #####: 1294:	for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1295:		temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####: 1296:		state->hand[currentPlayer][i] = -1;//Set to nothing
        -: 1297:	}
        -: 1298:	//Backup hand
        -: 1299:
        -: 1300:	//Update Coins for Buy
    #####: 1301:	updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####: 1302:	x = 1;//Condition to loop on
    #####: 1303:	while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####: 1304:		if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1305:			if (DEBUG) printf("None of that card left, sorry!\n");
        -: 1306:			if (DEBUG) printf("Cards Left: %d\n", supplyCount(choice1, state));
        -: 1307:		}
    #####: 1308:		else if (state->coins <= getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1309:			printf("That card is too expensive!\n");
call    0 never executed
        -: 1310:			if (DEBUG) printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -: 1311:		}
        -: 1312:		else{
        -: 1313:			if (DEBUG) printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -: 1314:
    #####: 1315:			gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####: 1316:			x = 0;//No more buying cards
        -: 1317:
        -: 1318:			if (DEBUG)printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -: 1319:
        -: 1320:		}
        -: 1321:	}     
        -: 1322:
        -: 1323:	//Reset Hand
    #####: 1324:	for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1325:		state->hand[currentPlayer][i] = temphand[i];
    #####: 1326:		temphand[i] = -1;
        -: 1327:	}
        -: 1328:	//Reset Hand
    #####: 1329:	return 0;
        -: 1330:}
        -: 1331:
function playCouncil_Room called 16 returned 100% blocks executed 100%
       16: 1332:int playCouncil_Room(int currentPlayer, struct gameState *state, int handPos){
        -: 1333:	//Get the integer of player whose turn it is now
        -: 1334:	int i;
        -: 1335:	//+4 Cards
       80: 1336:    for (i = 0; i < 4; i++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -: 1337:	{
       64: 1338:	  drawCard(currentPlayer, state);
call    0 returned 100%
        -: 1339:	}
        -: 1340:			
        -: 1341:    //+1 Buy
       16: 1342:    state->numBuys++;
        -: 1343:			
        -: 1344:    //Each other player draws a card
       48: 1345:    for (i = 0; i < state->numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -: 1346:	{
       32: 1347:	  if ( i == currentPlayer )
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -: 1348:	    {
       16: 1349:	      drawCard(i, state);
call    0 returned 100%
        -: 1350:	    }
        -: 1351:	}
        -: 1352:			
        -: 1353:    //put played card in played card pile
       16: 1354:    discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -: 1355:	
       16: 1356:	return 0;
        -: 1357:}
        -: 1358:
        -: 1359://end of dominion.c
        -: 1360:
