----------------- Testing scoreFor() ----------------

****FAIL Deck score = 0, expected = 1
****FAIL Deck score = 0, expected = 2
****FAIL Deck score = 0, expected = 3
****FAIL Deck score = 0, expected = 4
****FAIL Deck score = 0, expected = 5
****FAIL Deck score = 0, expected = 6
****FAIL Deck score = 0, expected = 7
****FAIL Deck score = 0, expected = 8
****FAIL Deck score = 0, expected = 1
****FAIL Deck score = 0, expected = 2
****FAIL Deck score = 0, expected = 3
****FAIL Deck score = 0, expected = 4
****FAIL Deck score = 0, expected = 5
****FAIL Deck score = 0, expected = 6
****FAIL Deck score = 0, expected = 7
****FAIL Deck score = 0, expected = 8
****FAIL Deck score = 0, expected = 3
****FAIL Deck score = 0, expected = 6
****FAIL Deck score = 0, expected = 9
****FAIL Deck score = 0, expected = 12
****FAIL Deck score = 0, expected = 15
****FAIL Deck score = 0, expected = 18
****FAIL Deck score = 0, expected = 21
****FAIL Deck score = 0, expected = 24
****FAIL Deck score = 0, expected = 3
****FAIL Deck score = 0, expected = 6
****FAIL Deck score = 0, expected = 9
****FAIL Deck score = 0, expected = 12
****FAIL Deck score = 0, expected = 15
****FAIL Deck score = 0, expected = 18
****FAIL Deck score = 0, expected = 21
****FAIL Deck score = 0, expected = 24
****FAIL Deck score = 0, expected = 6
****FAIL Deck score = 0, expected = 12
****FAIL Deck score = 0, expected = 18
****FAIL Deck score = 0, expected = 24
****FAIL Deck score = 0, expected = 30
****FAIL Deck score = 0, expected = 36
****FAIL Deck score = 0, expected = 42
****FAIL Deck score = 0, expected = 48
****FAIL Deck score = 0, expected = 6
****FAIL Deck score = 0, expected = 12
****FAIL Deck score = 0, expected = 18
****FAIL Deck score = 0, expected = 24
****FAIL Deck score = 0, expected = 30
****FAIL Deck score = 0, expected = 36
****FAIL Deck score = 0, expected = 42
****FAIL Deck score = 0, expected = 48
****FAIL Deck score = 0, expected = 1
****FAIL Deck score = 0, expected = 2
****FAIL Deck score = 0, expected = 3
****FAIL Deck score = 0, expected = 4
****FAIL Deck score = 0, expected = 5
****FAIL Deck score = 0, expected = 6
****FAIL Deck score = 0, expected = 7
****FAIL Deck score = 0, expected = 8
****FAIL Deck score = 0, expected = 1
****FAIL Deck score = 0, expected = 2
****FAIL Deck score = 0, expected = 3
****FAIL Deck score = 0, expected = 4
****FAIL Deck score = 0, expected = 5
****FAIL Deck score = 0, expected = 6
****FAIL Deck score = 0, expected = 7
****FAIL Deck score = 0, expected = 8
FAIL: There are 64 errors in scoreFor().
File 'unittest1.c'
Lines executed:64.62% of 212
Creating 'unittest1.c.gcov'

File 'unittest1.c'
Lines executed:64.62% of 212
Branches executed:75.86% of 116
Taken at least once:68.10% of 116
Calls executed:70.00% of 30
Creating 'unittest1.c.gcov'

        -:    0:Source:unittest1.c
        -:    0:Graph:unittest1.gcno
        -:    0:Data:unittest1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* -----------------------------------------------------------------------
        -:    2: * Name: Alex Marsh
        -:    3: * CS362
        -:    4: * unittest1.c
        -:    5: * This tests the function scoreFor() function in dominion.c
        -:    6: * Include the following lines in your makefile:
        -:    7: *
        -:    8: * unittest1: unittest1.c dominion.o rngs.o
        -:    9: *      gcc -o unittest1 -g  unittest1.c dominion.o rngs.o $(CFLAGS)
        -:   10: * -----------------------------------------------------------------------
        -:   11: */
        -:   12:
        -:   13:
        -:   14:#include <string.h>
        -:   15:#include <stdio.h>
        -:   16:#include <assert.h>
        -:   17:#include <math.h>
        -:   18:#include "dominion.h"
        -:   19:#include "dominion_helpers.h"
        -:   20:#include "interface.h"
        -:   21:#include "rngs.h"
        -:   22:
        -:   23:// set NOISY_TEST to 0 to remove printfs from output
        -:   24://to include printfs set to 1
        -:   25:#define NOISY_TEST 0
        -:   26:
        -:   27:
function main called 1 returned 100% blocks executed 88%
        1:   28:int main(){
        1:   29:    int seed = 1000;
        1:   30:    int numPlayer = 2;
        -:   31:    int p, r, score;
        -:   32:    int errors;
        -:   33:    int numOfCards, handIndex;
        -:   34:    int expected, vType;
        -:   35:    int discardIndex, deckIndex;
        1:   36:    int k[10] = {adventurer, council_room, feast, gardens, mine
        -:   37:               , remodel, smithy, village, baron, great_hall};
        -:   38:    //this will hold some of the victory cards. The numbers are taken from 
        -:   39:    //the enumeration in dominion.h
        -:   40:    //curse and gardens are not included since they are special cases
        -:   41:    //1=estate, 2=duchy, 3=province, 16= greathall
        1:   42:    int victoryCardsArr[4] = {1, 2, 3, 16}; 
        1:   43:    char cardName[4][20] = {"estate", "duchy", "province", "great hall"}; 
        -:   44:    struct gameState G;
        -:   45:    
        1:   46:    int maxHandCount = 8;
        1:   47:    printf("----------------- Testing scoreFor() ----------------\n");
call    0 returned 100%
        1:   48:    printf("\n");
call    0 returned 100%
        -:   49:    
        -:   50://    printf("Test players hand\n");
        -:   51:    
        -:   52:    //loop through the victory cards in the victoryCardsArr
        -:   53:    //specifically estate, duchy, province, great hall
        5:   54:    for(vType=0; vType < 4; vType++){
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:   55:        //loop over the players
       12:   56:        for (p = 0; p <numPlayer; p++){
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:   57:            //with two players there are 8 of each card
       80:   58:            for(numOfCards = 0; numOfCards <= 8; numOfCards++){
branch  0 taken 90%
branch  1 taken 10% (fallthrough)
        -:   59: //               printf("Test player %d Hand with %d %s victory card(s).\n", p, numOfCards, cardName[vType]);
        -:   60:
       72:   61:                memset(&G, 23, sizeof(struct gameState)); // clear the game state  
        -:   62:
       72:   63:                r = initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
        -:   64:
       72:   65:                G.handCount[p] = numOfCards;        //set the number of cards on hand
        -:   66:                //G.discardCount[p] = numOfCards;     //set the number of card in discard
        -:   67:                //G.deckCount[p] = numOfCards;             //set the number of card in the deck
        -:   68:                
        -:   69:                //set all the cards in players hand to the appropriate card
        -:   70:                int cardNum;
      720:   71:                for(cardNum = 0; cardNum <= maxHandCount; cardNum++){
branch  0 taken 90%
branch  1 taken 10% (fallthrough)
      648:   72:                    G.hand[p][cardNum] = victoryCardsArr[vType]; 
        -:   73:                    //G.discard[p][cardNum] = estate;     
        -:   74:                    //G.deck[p][cardNum] = estate;    
        -:   75:                }
        -:   76:
       72:   77:                int handCount = G.handCount[p];  //get current num of cards in hand
        -:   78: #if (NOISY_TEST == 1)
        -:   79:                printf("HandCount is %d\n", handCount);
        -:   80:                
        -:   81:                //print players hand for error checking. 
        -:   82:                printf("Player %d's hand:\n", p);
        -:   83:                if(handCount > 0) printf("#  Card\n");
        -:   84:                for(handIndex = 0; handIndex < handCount; handIndex++) {
        -:   85:                    int card = G.hand[p][handIndex];
        -:   86:                    char name[MAX_STRING_LENGTH];
        -:   87:                    cardNumToName(card, name);
        -:   88:                    printf("%-2d %-13s\n", handIndex, name);
        -:   89:                }
        -:   90:                printf("\n");
        -:   91: #endif               
        -:   92:                
       72:   93:                score = scoreFor(p, &G);   //call scoreFor
call    0 returned 100%
        -:   94:                //find the expected score accourding to the card
       72:   95:                if(vType == 0)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
       18:   96:                    {expected = numOfCards * 1;}    //estate
       72:   97:                if(vType == 1)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
       18:   98:                    {expected = numOfCards * 3;}    //duchy
       72:   99:                if(vType == 2)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
       18:  100:                    {expected = numOfCards * 6;}    //province
       72:  101:                if(vType == 3)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
       18:  102:                    {expected = numOfCards * 1;}   //great hall
        -:  103:                 
        -:  104:
       72:  105:                if(score != expected){//check if score is correct
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  106:                    printf("****FAIL Hand score = %d, expected = %d\n", score, expected);
call    0 never executed
    #####:  107:                    errors++;
        -:  108:                }  
        -:  109:#if (NOISY_TEST == 1)
        -:  110:                else{
        -:  111:                    printf("PASS Hand score = %d, expected = %d\n", score, expected);}
        -:  112:#endif                
        -:  113:            }
        -:  114:        }
        -:  115:        
        -:  116:    }
        -:  117:    
        -:  118:    
        -:  119://    printf("Testing Discard Deck\n");
        -:  120:    
        -:  121:    //loop through the victory cards in the victoryCardsArr
        -:  122:    //specifically estate, duchy, province, great hall
        5:  123:    for(vType = 0; vType < 4; vType++){
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:  124:        //loop over the players
       12:  125:        for (p = 0; p < numPlayer; p++){
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  126:            //with two players there are 8 of each card
       80:  127:            for(numOfCards = 0; numOfCards <= 8; numOfCards++){
branch  0 taken 90%
branch  1 taken 10% (fallthrough)
        -:  128:  //              printf("Test player %d Discard with %d %s victory card(s).\n", p, numOfCards, cardName[vType]);
        -:  129:
       72:  130:                memset(&G, 23, sizeof(struct gameState)); // clear the game state  
        -:  131:
       72:  132:                r = initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
        -:  133:
        -:  134:                //G.handCount[p] = numOfCards;        //set the number of cards on hand
       72:  135:                G.discardCount[p] = numOfCards;     //set the number of card in discard
        -:  136:                //G.deckCount[p] = numOfCards;             //set the number of card in the deck
        -:  137:                
        -:  138:                //set all the cards in players hand to the appropriate card
        -:  139:                //fill deck and hand with copper so there are no random victory
        -:  140:                //cards inserted. 
        -:  141:                int cardNum;
      720:  142:                for(cardNum = 0; cardNum <= maxHandCount; cardNum++){
branch  0 taken 90%
branch  1 taken 10% (fallthrough)
      648:  143:                    G.hand[p][cardNum] = copper; 
      648:  144:                    G.discard[p][cardNum] = victoryCardsArr[vType];     
      648:  145:                    G.deck[p][cardNum] = copper;    
        -:  146:                }
        -:  147:
       72:  148:                int discardCount = G.discardCount[p];  //get current num of cards in hand
        -:  149:#if (NOISY_TEST == 1)
        -:  150:                printf("DiscardCount is %d\n", discardCount);
        -:  151:                
        -:  152:                //print players discard for error checking. 
        -:  153:                printf("Player %d's discard hand:\n", p);
        -:  154:                if(discardCount > 0) printf("#  Card\n");
        -:  155:                for(discardIndex = 0; discardIndex < discardCount; discardIndex++) {
        -:  156:                    int card = G.discard[p][discardIndex];
        -:  157:                    char name[MAX_STRING_LENGTH];
        -:  158:                    cardNumToName(card, name);
        -:  159:                    printf("%-2d %-13s\n", discardIndex, name);
        -:  160:                }
        -:  161:                printf("\n");
        -:  162:#endif                    
        -:  163:                
       72:  164:                score = scoreFor(p, &G);   //call scoreFor
call    0 returned 100%
        -:  165:                //find the expected score accourding to the card
       72:  166:                if(vType == 0)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
       18:  167:                    {expected = numOfCards * 1;}    //estate
       72:  168:                if(vType == 1)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
       18:  169:                    {expected = numOfCards * 3;}    //duchy
       72:  170:                if(vType == 2)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
       18:  171:                    {expected = numOfCards * 6;}    //province
       72:  172:                if(vType == 3)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
       18:  173:                    {expected = numOfCards * 1;}   //great hall
        -:  174:                 
        -:  175:
       72:  176:                if(score != expected){//check if score is correct
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  177:                    printf("****FAIL Discard score = %d, expected = %d\n", score, expected); 
call    0 never executed
    #####:  178:                    errors++;
        -:  179:                }  
        -:  180:#if (NOISY_TEST == 1)   
        -:  181:                else{
        -:  182:                    printf("PASS Discard score = %d, expected = %d\n", score, expected);}
        -:  183:#endif
        -:  184:            }
        -:  185:        }
        -:  186:        
        -:  187:    }
        -:  188:    
        -:  189:    
        -:  190://     printf("Testing Deck\n");
        -:  191:    
        -:  192:    //loop through the victory cards in the victoryCardsArr
        -:  193:    //specifically estate, duchy, province, great hall
        5:  194:    for(vType = 0; vType < 4; vType++){
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:  195:        //loop over the players
       12:  196:        for (p = 0; p < numPlayer; p++){
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  197:            //with two players there are 8 of each card
       80:  198:            for(numOfCards = 0; numOfCards <= 8; numOfCards++){
branch  0 taken 90%
branch  1 taken 10% (fallthrough)
        -:  199://                printf("Test player %d Deck with %d %s victory card(s).\n", p, numOfCards, cardName[vType]);
        -:  200:
       72:  201:                memset(&G, 23, sizeof(struct gameState)); // clear the game state  
        -:  202:
       72:  203:                r = initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
        -:  204:
        -:  205:                //G.handCount[p] = numOfCards;        //set the number of cards on hand
        -:  206:                //G.discardCount[p] = numOfCards;     //set the number of card in discard
       72:  207:                G.deckCount[p] = numOfCards;             //set the number of card in the deck
        -:  208:                
        -:  209:                //set all the cards in players hand to the appropriate card
        -:  210:                //fill discard and hand with copper so there are no random victory
        -:  211:                //cards inserted. 
        -:  212:                int cardNum;
      720:  213:                for(cardNum = 0; cardNum <= maxHandCount; cardNum++){
branch  0 taken 90%
branch  1 taken 10% (fallthrough)
      648:  214:                    G.hand[p][cardNum] = copper; 
      648:  215:                    G.discard[p][cardNum] = copper;    
      648:  216:                    G.deck[p][cardNum] = victoryCardsArr[vType];    
        -:  217:                }
        -:  218:
       72:  219:                int deckCount = G.deckCount[p];  //get current num of cards in hand
        -:  220: #if (NOISY_TEST == 1)
        -:  221:                printf("DeckCount is %d\n", deckCount);
        -:  222:                
        -:  223:                //print players deck for error checking. 
        -:  224:                printf("Player %d's deck:\n", p);
        -:  225:                if(deckCount > 0) printf("#  Card\n");
        -:  226:                for(deckIndex = 0; deckIndex < deckCount; deckIndex++) {
        -:  227:                    int card = G.deck[p][deckIndex];
        -:  228:                    char name[MAX_STRING_LENGTH];
        -:  229:                    cardNumToName(card, name);
        -:  230:                    printf("%-2d %-13s\n", deckIndex, name);
        -:  231:                }
        -:  232:                printf("\n");
        -:  233: #endif                   
        -:  234:                
       72:  235:                score = scoreFor(p, &G);   //call scoreFor
call    0 returned 100%
        -:  236:                //find the expected score accourding to the card
       72:  237:                if(vType == 0)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
       18:  238:                    {expected = numOfCards * 1;}    //estate
       72:  239:                if(vType == 1)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
       18:  240:                    {expected = numOfCards * 3;}    //duchy
       72:  241:                if(vType == 2)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
       18:  242:                    {expected = numOfCards * 6;}    //province
       72:  243:                if(vType == 3)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
       18:  244:                    {expected = numOfCards * 1;}   //great hall
        -:  245:                 
        -:  246:
       72:  247:                if(score != expected){//check if score is correct
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
       64:  248:                    printf("****FAIL Deck score = %d, expected = %d\n", score, expected); 
call    0 returned 100%
       64:  249:                    errors++;
        -:  250:                }  
        -:  251:#if (NOISY_TEST == 1) 
        -:  252:                else{
        -:  253:                    printf("PASS Deck score = %d, expected = %d\n", score, expected);}
        -:  254:#endif
        -:  255:            }
        -:  256:        }
        -:  257:        
        -:  258:    }
        -:  259:    
        -:  260: //   printf("Testing for curse victory card\n");
        3:  261:    for (p = 0; p < numPlayer; p++){
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  262:      
       20:  263:      for(numOfCards = 0; numOfCards <= 8; numOfCards++){
branch  0 taken 90%
branch  1 taken 10% (fallthrough)
       18:  264:        memset(&G, 23, sizeof(struct gameState)); // clear the game state  
       18:  265:        r = initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
        -:  266:         
       18:  267:        G.handCount[p] = numOfCards;        //set the number of cards on hand
       18:  268:        G.discardCount[p] = numOfCards;     //set the number of card in discard
       18:  269:        G.deckCount[p] = numOfCards;             //set the number of card in the deck
        -:  270:
        -:  271:        //set all the cards in players hand to the appropriate card
        -:  272:        int cardNum;
      180:  273:        for(cardNum = 0; cardNum <= maxHandCount; cardNum++){
branch  0 taken 90%
branch  1 taken 10% (fallthrough)
      162:  274:            G.hand[p][cardNum] = curse; 
      162:  275:            G.discard[p][cardNum] = copper;     
      162:  276:            G.deck[p][cardNum] = copper;    
        -:  277:        }
        -:  278:  //      printf("Test player %d Deck with %d curse card(s).\n", p, numOfCards);   
       18:  279:        int handCount = G.handCount[p];  //get current num of cards in hand
        -:  280:#if (NOISY_TEST == 1)
        -:  281:        printf("HandCount is %d\n", handCount);
        -:  282:
        -:  283:        //print players hand for error checking. 
        -:  284:        printf("Player %d's hand:\n", p);
        -:  285:        if(handCount > 0) printf("#  Card\n");
        -:  286:        for(handIndex = 0; handIndex < handCount; handIndex++) {
        -:  287:            int card = G.hand[p][handIndex];
        -:  288:            char name[MAX_STRING_LENGTH];
        -:  289:            cardNumToName(card, name);
        -:  290:            printf("%-2d %-13s\n", handIndex, name);
        -:  291:        }
        -:  292:        printf("\n");
        -:  293:#endif
        -:  294:
       18:  295:        score = scoreFor(p, &G);   //call scoreFor
call    0 returned 100%
        -:  296:        //find the expected score accourding to the card
       18:  297:        expected = -(1 * numOfCards);
        -:  298:
        -:  299:
       18:  300:        if(score != expected){//check if score is correct
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  301:            printf("****FAIL Hand score = %d, expected = %d\n", score, expected);
call    0 never executed
    #####:  302:            errors++;
        -:  303:        }  
        -:  304:#if (NOISY_TEST == 1) 
        -:  305:          else{
        -:  306:            printf("PASS Hand score = %d, expected = %d\n", score, expected);}
        -:  307:#endif          
        -:  308:          
        -:  309: //       printf("Test player %d Discard with %d curse card(s).\n", p, numOfCards);   
        -:  310:        
      180:  311:        for(cardNum = 0; cardNum <= maxHandCount; cardNum++){
branch  0 taken 90%
branch  1 taken 10% (fallthrough)
      162:  312:            G.hand[p][cardNum] = copper; 
      162:  313:            G.discard[p][cardNum] = curse;     
      162:  314:            G.deck[p][cardNum] = copper;    
        -:  315:        }
       18:  316:        int discardCount = G.discardCount[p];  //get current num of cards in hand
        -:  317: #if (NOISY_TEST == 1)
        -:  318:          printf("DiscardCount is %d\n", discardCount);
        -:  319:
        -:  320:        //print players discard for error checking. 
        -:  321:        printf("Player %d's discard hand:\n", p);
        -:  322:        if(discardCount > 0) printf("#  Card\n");
        -:  323:        for(discardIndex = 0; discardIndex < discardCount; discardIndex++) {
        -:  324:            int card = G.discard[p][discardIndex];
        -:  325:            char name[MAX_STRING_LENGTH];
        -:  326:            cardNumToName(card, name);
        -:  327:            printf("%-2d %-13s\n", discardIndex, name);
        -:  328:        }
        -:  329:        printf("\n");  
        -:  330:#endif          
       18:  331:        score = scoreFor(p, &G);   //call scoreFor
call    0 returned 100%
        -:  332:        //find the expected score accourding to the card
       18:  333:        expected = -(1 * numOfCards);
        -:  334:
        -:  335:
       18:  336:        if(score != expected){//check if score is correct
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  337:            printf("****FAIL Discard score = %d, expected = %d\n", score, expected);
call    0 never executed
    #####:  338:            errors++;
        -:  339:        }  
        -:  340:#if (NOISY_TEST == 1)   
        -:  341:          else{
        -:  342:            printf("PASS Discard score = %d, expected = %d\n", score, expected);}
        -:  343:          
        -:  344:        printf("Test player %d Deck with %d curse card(s).\n", p, numOfCards);   
        -:  345:#endif      
      180:  346:        for(cardNum = 0; cardNum <= maxHandCount; cardNum++){
branch  0 taken 90%
branch  1 taken 10% (fallthrough)
      162:  347:            G.hand[p][cardNum] = copper; 
      162:  348:            G.discard[p][cardNum] = copper;     
      162:  349:            G.deck[p][cardNum] = curse;    
        -:  350:        }
        -:  351:        
       18:  352:        int deckCount = G.deckCount[p];  //get current num of cards in hand
        -:  353: #if (NOISY_TEST == 1)
        -:  354:        printf("DeckCount is %d\n", deckCount);
        -:  355:
        -:  356:        //print players deck for error checking. 
        -:  357:        printf("Player %d's deck:\n", p);
        -:  358:        if(deckCount > 0) printf("#  Card\n");
        -:  359:        for(deckIndex = 0; deckIndex < deckCount; deckIndex++) {
        -:  360:            int card = G.deck[p][deckIndex];
        -:  361:            char name[MAX_STRING_LENGTH];
        -:  362:            cardNumToName(card, name);
        -:  363:            printf("%-2d %-13s\n", deckIndex, name);
        -:  364:        }
        -:  365:        printf("\n");  
        -:  366: #endif
       18:  367:          score = scoreFor(p, &G);   //call scoreFor
call    0 returned 100%
        -:  368:        //find the expected score accourding to the card
       18:  369:        expected = -(1 * numOfCards);
        -:  370:
        -:  371:
       18:  372:        if(score != expected){//check if score is correct
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  373:            printf("****FAIL Deck score = %d, expected = %d\n", score, expected);
call    0 never executed
    #####:  374:            errors++;
        -:  375:        }  
        -:  376:#if (NOISY_TEST == 1)
        -:  377:          else{
        -:  378:            printf("PASS Deck score = %d, expected = %d\n", score, expected);}  
        -:  379:#endif
        -:  380:      }
        -:  381:        
        -:  382:    }
        -:  383:    
        -:  384://   printf("Testing for gardens victory card\n");
        3:  385:    for (p = 0; p < numPlayer; p++){
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
       20:  386:      for(numOfCards = 0; numOfCards <= 8; numOfCards++){ 
branch  0 taken 90%
branch  1 taken 10% (fallthrough)
       18:  387:      memset(&G, 23, sizeof(struct gameState)); // clear the game state  
       18:  388:        r = initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
       18:  389:        G.handCount[p] = numOfCards;        //set the number of cards on hand
       18:  390:        G.discardCount[p] = numOfCards;     //set the number of card in discard
       18:  391:        G.deckCount[p]=numOfCards;  
        -:  392:        //set all the cards in players hand to the appropriate card
        -:  393:        int cardNum;
      180:  394:        for(cardNum = 0; cardNum <= maxHandCount; cardNum++){
branch  0 taken 90%
branch  1 taken 10% (fallthrough)
      162:  395:            G.hand[p][cardNum] = gardens; 
      162:  396:            G.discard[p][cardNum] = copper;     
      162:  397:            G.deck[p][cardNum] = copper;    
        -:  398:        }
        -:  399: //       printf("Test player %d Deck with %d gardens card(s).\n", p, numOfCards);   
       18:  400:        int handCount = G.handCount[p];  //get current num of cards in hand
        -:  401:#if (NOISY_TEST == 1)
        -:  402:        printf("HandCount is %d\n", handCount);
        -:  403:
        -:  404:        //print players hand for error checking. 
        -:  405:        printf("Player %d's hand:\n", p);
        -:  406:        if(handCount > 0) printf("#  Card\n");
        -:  407:        for(handIndex = 0; handIndex < handCount; handIndex++) {
        -:  408:            int card = G.hand[p][handIndex];
        -:  409:            char name[MAX_STRING_LENGTH];
        -:  410:            cardNumToName(card, name);
        -:  411:            printf("%-2d %-13s\n", handIndex, name);
        -:  412:        }
        -:  413:        printf("\n");
        -:  414:#endif
        -:  415:
       18:  416:        score = scoreFor(p, &G);   //call scoreFor
call    0 returned 100%
        -:  417:        //gardens victory card is worth 1 estate for every 10 cards
        -:  418:        // the score is then added on, but since we don't have an 
        -:  419:        // additional score now, the division is enough  
       18:  420:        expected = (fullDeckCount(p, 0, &G)/10); 
call    0 returned 100%
       18:  421:        if(score != expected){//check if score is correct
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  422:            printf("****FAIL Deck score = %d, expected = %d\n", score, expected); 
call    0 never executed
    #####:  423:            errors++;
        -:  424:        }  
        -:  425:#if (NOISY_TEST == 1)    
        -:  426:          else{
        -:  427:            printf("PASS Deck score = %d, expected = %d\n", score, expected);}  
        -:  428:          
        -:  429:        printf("Test player %d Discard with %d gardens card(s).\n", p, numOfCards);   
        -:  430:#endif        
      180:  431:        for(cardNum = 0; cardNum <= maxHandCount; cardNum++){
branch  0 taken 90%
branch  1 taken 10% (fallthrough)
      162:  432:            G.hand[p][cardNum] = copper; 
      162:  433:            G.discard[p][cardNum] = gardens;     
      162:  434:            G.deck[p][cardNum] = copper;    
        -:  435:        }
       18:  436:        int discardCount = G.discardCount[p];  //get current num of cards in hand
        -:  437: #if (NOISY_TEST == 1)
        -:  438:          printf("DiscardCount is %d\n", discardCount);
        -:  439:
        -:  440:        //print players discard for error checking. 
        -:  441:        printf("Player %d's discard hand:\n", p);
        -:  442:        if(discardCount > 0) printf("#  Card\n");
        -:  443:        for(discardIndex = 0; discardIndex < discardCount; discardIndex++) {
        -:  444:            int card = G.discard[p][discardIndex];
        -:  445:            char name[MAX_STRING_LENGTH];
        -:  446:            cardNumToName(card, name);
        -:  447:            printf("%-2d %-13s\n", discardIndex, name);
        -:  448:        }
        -:  449:        printf("\n");  
        -:  450:#endif          
       18:  451:        score = scoreFor(p, &G);   //call scoreFor
call    0 returned 100%
        -:  452:        //find the expected score accourding to the card
       18:  453:        expected = (fullDeckCount(p, 0, &G)/10); 
call    0 returned 100%
        -:  454:
       18:  455:        if(score != expected){//check if score is correct
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  456:            printf("****FAIL Discard score = %d, expected = %d\n", score, expected); 
call    0 never executed
    #####:  457:            errors++;
        -:  458:        }  
        -:  459:#if (NOISY_TEST == 1)  
        -:  460:          else{
        -:  461:            printf("PASS Discard score = %d, expected = %d\n", score, expected);}
        -:  462:          
        -:  463:        printf("Test player %d Deck with %d gardens card(s).\n", p, numOfCards);   
        -:  464:#endif        
      180:  465:        for(cardNum = 0; cardNum <= maxHandCount; cardNum++){
branch  0 taken 90%
branch  1 taken 10% (fallthrough)
      162:  466:            G.hand[p][cardNum] = copper; 
      162:  467:            G.discard[p][cardNum] = copper;     
      162:  468:            G.deck[p][cardNum] = gardens;    
        -:  469:        }
        -:  470:        
       18:  471:        int deckCount = G.deckCount[p];  //get current num of cards in hand
        -:  472: #if (NOISY_TEST == 1)
        -:  473:        printf("DeckCount is %d\n", deckCount);
        -:  474:
        -:  475:        //print players deck for error checking. 
        -:  476:        printf("Player %d's deck:\n", p);
        -:  477:        if(deckCount > 0) printf("#  Card\n");
        -:  478:        for(deckIndex = 0; deckIndex < deckCount; deckIndex++) {
        -:  479:            int card = G.deck[p][deckIndex];
        -:  480:            char name[MAX_STRING_LENGTH];
        -:  481:            cardNumToName(card, name);
        -:  482:            printf("%-2d %-13s\n", deckIndex, name);
        -:  483:        }
        -:  484:        printf("\n");  
        -:  485: #endif
       18:  486:          score = scoreFor(p, &G);   //call scoreFor
call    0 returned 100%
        -:  487:        //find the expected score accourding to the card
       18:  488:        expected = (fullDeckCount(p, 0, &G)/10); 
call    0 returned 100%
        -:  489:
       18:  490:        if(score != expected){//check if score is correct
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  491:            printf("****FAIL Deck score = %d, expected = %d\n", score, expected); 
call    0 never executed
    #####:  492:            errors++;
        -:  493:        }  
        -:  494:#if (NOISY_TEST == 1) 
        -:  495:          else{
        -:  496:            printf("PASS Deck score = %d, expected = %d\n", score, expected);}  
        -:  497:#endif          
        -:  498:      }
        -:  499:    }
        -:  500:    
        1:  501:    if(errors == 0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  502:     printf("ALL TESTS PASS for whoseTurn().\n");   
call    0 never executed
        -:  503:    }
        -:  504:    else{
        1:  505:     printf("FAIL: There are %d errors in scoreFor().\n", errors);   
call    0 returned 100%
        -:  506:    }
        -:  507:    
        1:  508:    return 0;
        -:  509:}
        -:  510:
        -:  511:
        -:  512:
        -:  513:
        -:  514:
function cardNumToName called 0 returned 0% blocks executed 0%
    #####:  515:void cardNumToName(int card, char *name){
    #####:  516:  switch(card){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
    #####:  517:  case curse: strcpy(name,"Curse");
    #####:  518:    break;
    #####:  519:  case estate: strcpy(name,"Estate");
    #####:  520:    break;
    #####:  521:  case duchy: strcpy(name,"Duchy");
    #####:  522:    break;
    #####:  523:  case province: strcpy(name,"Province");
    #####:  524:    break;
    #####:  525:  case copper: strcpy(name,"Copper");
    #####:  526:    break;
    #####:  527:  case silver: strcpy(name,"Silver");
    #####:  528:    break;
    #####:  529:  case gold: strcpy(name,"Gold");
    #####:  530:    break;
    #####:  531:  case adventurer: strcpy(name,"Adventurer");
    #####:  532:    break;
    #####:  533:  case council_room: strcpy(name,"Council Room");
    #####:  534:    break;
    #####:  535:  case feast: strcpy(name,"Feast");
    #####:  536:    break;
    #####:  537:  case gardens: strcpy(name,"Gardens");
    #####:  538:    break;
    #####:  539:  case mine: strcpy(name,"Mine");
    #####:  540:    break;
    #####:  541:  case remodel: strcpy(name,"Remodel");
    #####:  542:    break;
    #####:  543:  case smithy: strcpy(name,"Smithy");
    #####:  544:    break;
    #####:  545:  case village: strcpy(name,"Village");
    #####:  546:    break;
    #####:  547:  case baron: strcpy(name,"Baron");
    #####:  548:    break;
    #####:  549:  case great_hall: strcpy(name,"Great Hall");
    #####:  550:    break;
    #####:  551:  case minion: strcpy(name,"Minion");
    #####:  552:    break;
    #####:  553:  case steward: strcpy(name,"Steward");
    #####:  554:    break;
    #####:  555:  case tribute: strcpy(name,"Tribute");
    #####:  556:    break;
    #####:  557:  case ambassador: strcpy(name,"Ambassador");
    #####:  558:    break;
    #####:  559:  case cutpurse: strcpy(name,"Cutpurse");
    #####:  560:    break;
    #####:  561:  case embargo: strcpy(name,"Embargo");
    #####:  562:    break;
    #####:  563:  case outpost: strcpy(name,"Outpost");
    #####:  564:    break;
    #####:  565:  case salvager: strcpy(name,"Salvager");
    #####:  566:    break;
    #####:  567:  case sea_hag: strcpy(name,"Sea Hag");
    #####:  568:    break;
    #####:  569:  case treasure_map: strcpy(name,"Treasure Map");
    #####:  570:    break;
        -:  571:
    #####:  572:  default: strcpy(name,"?");
        -:  573:  }
        -:  574:
    #####:  575:}
----------------- Testing getCost() ----------------

ALL TESTS PASSED FOR getCost()
File 'unittest2.c'
Lines executed:38.20% of 89
Creating 'unittest2.c.gcov'

File 'unittest2.c'
Lines executed:38.20% of 89
Branches executed:100.00% of 56
Taken at least once:50.00% of 56
Calls executed:51.72% of 58
Creating 'unittest2.c.gcov'

        -:    0:Source:unittest2.c
        -:    0:Graph:unittest2.gcno
        -:    0:Data:unittest2.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* -----------------------------------------------------------------------
        -:    2: * Name: Alex Marsh
        -:    3: * CS362
        -:    4: * unittest2.c
        -:    5: * This tests the function getCost() function in dominion.c
        -:    6: * Include the following lines in your makefile:
        -:    7: *
        -:    8: * unittest2: unittest2.c dominion.o rngs.o
        -:    9: *      gcc -o unittest2 -g  unittest2.c dominion.o rngs.o $(CFLAGS)
        -:   10: * -----------------------------------------------------------------------
        -:   11: */
        -:   12:
        -:   13:
        -:   14:#include "dominion.h"
        -:   15:#include "dominion_helpers.h"
        -:   16:#include <string.h>
        -:   17:#include <stdio.h>
        -:   18:#include <assert.h>
        -:   19:#include "rngs.h"
        -:   20:
function main called 1 returned 100% blocks executed 52%
        1:   21:int main(){
        1:   22:    int error = 0; 
        1:   23:    printf("----------------- Testing getCost() ----------------\n");
call    0 returned 100%
        -:   24:
        1:   25:    printf("\n");
call    0 returned 100%
        -:   26:    
        1:   27:    if(getCost(copper)!= 0){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   28:        printf("FAIL: copper incorrect\n");
call    0 never executed
    #####:   29:        error++;
        -:   30:    }
        -:   31:    
        1:   32:    if(getCost(silver)!= 3){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   33:        printf("FAIL: silver incorrect\n");
call    0 never executed
    #####:   34:        error++;
        -:   35:    }
        -:   36:    
        1:   37:    if(getCost(gold)!= 6){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   38:        printf("FAIL: gold incorrect\n");
call    0 never executed
    #####:   39:        error++;
        -:   40:    }
        -:   41:    
        1:   42:    if(getCost(estate)!= 2){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   43:        printf("FAIL: estate incorrect\n");
call    0 never executed
    #####:   44:        error++;
        -:   45:    }
        -:   46:    
        1:   47:    if(getCost(duchy)!= 5){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   48:        printf("FAIL: duchy incorrect\n");
call    0 never executed
    #####:   49:        error++;
        -:   50:    }
        -:   51:    
        1:   52:    if(getCost(province)!= 8){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   53:        printf("FAIL: province incorrect\n");
call    0 never executed
    #####:   54:        error++;
        -:   55:    }
        -:   56:    
        1:   57:    if(getCost(curse)!= 0){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   58:        printf("FAIL: curse incorrect\n");
call    0 never executed
    #####:   59:        error++;
        -:   60:    }
        -:   61:    
        1:   62:    if(getCost(adventurer)!= 6){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   63:        printf("FAIL: adventurer incorrect\n");
call    0 never executed
    #####:   64:        error++;
        -:   65:    }
        -:   66:    
        1:   67:    if(getCost(council_room)!= 5){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   68:        printf("FAIL: council_room incorrect\n");
call    0 never executed
    #####:   69:        error++;
        -:   70:    }
        -:   71:    
        1:   72:    if(getCost(feast)!= 4){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   73:        printf("FAIL: feast incorrect\n");
call    0 never executed
    #####:   74:        error++;
        -:   75:    }
        -:   76:    
        1:   77:    if(getCost(gardens)!= 4){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   78:        printf("FAIL: garden incorrect\n");
call    0 never executed
    #####:   79:        error++;
        -:   80:    }
        -:   81:    
        1:   82:    if(getCost(mine)!= 5){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   83:        printf("FAIL: mine incorrect\n");
call    0 never executed
    #####:   84:        error++;
        -:   85:    }
        -:   86:    
        -:   87: /**   if(getCost(moneylender)!= 4){
        -:   88:        printf("FAIL: moneylender incorrect\n");
        -:   89:        error++;
        -:   90:    }**/
        -:   91:    
        1:   92:    if(getCost(remodel)!= 4){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   93:        printf("FAIL: remodel incorrect\n");
call    0 never executed
    #####:   94:        error++;
        -:   95:    }
        -:   96:    
        1:   97:    if(getCost(smithy)!= 4){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   98:        printf("FAIL: smithy incorrect\n");
call    0 never executed
    #####:   99:        error++;
        -:  100:    }
        -:  101:    
        1:  102:    if(getCost(village)!= 3){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  103:        printf("FAIL: village incorrect\n");
call    0 never executed
    #####:  104:        error++;
        -:  105:    }
        -:  106:    
        -:  107:/**    if(getCost(woodcutter)!= 3){
        -:  108:        printf("FAIL: woodcutter incorrect\n");
        -:  109:        error++;
        -:  110:    }**/
        -:  111:    
        1:  112:    if(getCost(baron)!= 4){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  113:        printf("FAIL: baron incorrect\n");
call    0 never executed
    #####:  114:        error++;
        -:  115:    }
        -:  116:    
        1:  117:    if(getCost(great_hall)!= 3){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  118:        printf("FAIL: great_hall incorrect\n");
call    0 never executed
    #####:  119:        error++;
        -:  120:    }
        -:  121:    
        1:  122:    if(getCost(minion)!= 5){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  123:        printf("FAIL: minion incorrect\n");
call    0 never executed
    #####:  124:        error++;
        -:  125:    }
        -:  126:    
        -:  127:/**    if(getCost(shanty_town)!= 3){
        -:  128:        printf("FAIL: shanty_town incorrect\n");
        -:  129:        error++;
        -:  130:    }**/
        -:  131:    
        1:  132:    if(getCost(steward)!= 3){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  133:        printf("FAIL: steward incorrect\n");
call    0 never executed
    #####:  134:        error++;
        -:  135:    }
        -:  136:    
        1:  137:    if(getCost(tribute)!= 5){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  138:        printf("FAIL: tribute incorrect\n");
call    0 never executed
    #####:  139:        error++;
        -:  140:    }
        -:  141:    
        -:  142: /**   if(getCost(wishing_well)!= 3){
        -:  143:        printf("FAIL: wishing_well incorrect\n");
        -:  144:        error++;
        -:  145:    }**/
        -:  146:    
        1:  147:    if(getCost(ambassador)!= 3){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  148:        printf("FAIL: ambassador incorrect\n");
call    0 never executed
    #####:  149:        error++;
        -:  150:    }
        -:  151:    
        1:  152:    if(getCost(cutpurse)!= 4){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  153:        printf("FAIL: cutpurse incorrect\n");
call    0 never executed
    #####:  154:        error++;
        -:  155:    }
        -:  156:    
        1:  157:    if(getCost(embargo)!= 2){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  158:        printf("FAIL: embargo incorrect\n");
call    0 never executed
    #####:  159:        error++;
        -:  160:    }
        -:  161:    
        1:  162:    if(getCost(outpost)!= 5){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  163:        printf("FAIL: outpost incorrect\n");
call    0 never executed
    #####:  164:        error++;
        -:  165:    }
        -:  166:    
        1:  167:    if(getCost(salvager)!= 4){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  168:        printf("FAIL: salvager incorrect\n");
call    0 never executed
    #####:  169:        error++;
        -:  170:    }
        -:  171:    
        1:  172:    if(getCost(sea_hag)!= 4){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  173:        printf("FAIL: sea_hag incorrect\n");
call    0 never executed
    #####:  174:        error++;
        -:  175:    }
        -:  176:    
        1:  177:    if(getCost(treasure_map)!= 4){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  178:        printf("FAIL: treasure_map incorrect\n");
call    0 never executed
    #####:  179:        error++;
        -:  180:    }
        -:  181:    
        1:  182:    if(error == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  183:        printf("ALL TESTS PASSED FOR getCost()\n");
call    0 returned 100%
        -:  184:    else
    #####:  185:        printf("There are %d errors\n", error);
call    0 never executed
        -:  186:    
        1:  187:    return 0;
        -:  188:}
----------------- Testing fullDeckCount() ----------------

ALL TESTS PASS for fullDeckCount().
File 'unittest3.c'
Lines executed:88.16% of 76
Creating 'unittest3.c.gcov'

File 'unittest3.c'
Lines executed:88.16% of 76
Branches executed:100.00% of 34
Taken at least once:85.29% of 34
Calls executed:68.75% of 16
Creating 'unittest3.c.gcov'

        -:    0:Source:unittest3.c
        -:    0:Graph:unittest3.gcno
        -:    0:Data:unittest3.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* -----------------------------------------------------------------------
        -:    2: * Name: Alex Marsh
        -:    3: * CS362
        -:    4: * unittest3.c
        -:    5: * This tests the function fullDeckCount() function in dominion.c
        -:    6: * Include the following lines in your makefile:
        -:    7: *
        -:    8: * unittest3: unittest3.c dominion.o rngs.o
        -:    9: *      gcc -o unittest3 -g  unittest3.c dominion.o rngs.o $(CFLAGS)
        -:   10: * -----------------------------------------------------------------------
        -:   11: */
        -:   12:
        -:   13:
        -:   14:#include <string.h>
        -:   15:#include <stdio.h>
        -:   16:#include <assert.h>
        -:   17:#include <math.h>
        -:   18:#include "dominion.h"
        -:   19:#include "dominion_helpers.h"
        -:   20:#include "interface.h"
        -:   21:#include "rngs.h"
        -:   22:
        -:   23:// set NOISY_TEST to 0 to remove printfs from output
        -:   24://to include printfs set to 1
        -:   25:#define NOISY_TEST 0
        -:   26:
function main called 1 returned 100% blocks executed 86%
        1:   27:int main(){
        1:   28:    int numPlayer = 2;
        1:   29:    int seed = 1000;
        -:   30:    int expected, returnedCount;
        -:   31:    int i, p, r;
        -:   32:    int numOfCards;
        1:   33:    int errors = 0;
        -:   34:    //to test the function adds correctly we add the same
        -:   35:    //amount of cards to each hand, deck, or discard.
        -:   36:    //MAX_HAND = 500 and divided by 3 is 166
        1:   37:    int equalDivCards = 166;
        1:   38:    int k[10] = {adventurer, council_room, feast, gardens, mine
        -:   39:               , remodel, smithy, village, baron, great_hall};
        -:   40:    struct gameState G;
        1:   41:    printf("----------------- Testing fullDeckCount() ----------------\n");
call    0 returned 100%
        -:   42:
        1:   43:    printf("\n");
call    0 returned 100%
        -:   44:    
        -:   45: //   printf("Testing for cards in hand, deck, and discard:\n");
        3:   46:    for (p = 0; p <numPlayer; p++){
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
      336:   47:        for(numOfCards = 0; numOfCards <= equalDivCards; numOfCards++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:   48://        printf("Test player %d with %d card(s).\n", p, numOfCards);
      334:   49:        memset(&G, 23, sizeof(struct gameState));   // clear the game state
      334:   50:        r = initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
        -:   51:        
        -:   52:        //set the amount of cards in each pile    
      334:   53:        G.handCount[p] = numOfCards;
      334:   54:        G.deckCount[p] = numOfCards;
      334:   55:        G.discardCount[p] = numOfCards;    
        -:   56:        
        -:   57:        //set all the cards in players hand to the appropriate card
        -:   58:        int cardNum;
    28390:   59:        for(cardNum = 0; cardNum <= numOfCards; cardNum++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
    28056:   60:            G.hand[p][cardNum] = copper; 
    28056:   61:            G.discard[p][cardNum] = copper;     
    28056:   62:            G.deck[p][cardNum] = copper;    
        -:   63:        }    
        -:   64:            
      334:   65:        returnedCount = fullDeckCount(p, copper, &G);    
call    0 returned 100%
        -:   66:        
      334:   67:        expected =  numOfCards * 3; 
      334:   68:        if(returnedCount != expected){//check if score is correct
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   69:            printf("****FAIL Returned Count = %d, expected = %d\n", returnedCount, expected); 
call    0 never executed
    #####:   70:            errors++;
        -:   71:        }  
        -:   72:#if (NOISY_TEST == 1)
        -:   73:        else{
        -:   74:            printf("PASS Returned Count = %d, expected = %d\n", returnedCount, expected);}    
        -:   75:#endif            
        -:   76:        }
        -:   77:    }
        -:   78:    
        -:   79: //   printf("Testing for cards only in hand:\n");
        3:   80:    for (p = 0; p <numPlayer; p++){
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
      336:   81:        for(numOfCards = 0; numOfCards <= equalDivCards; numOfCards++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:   82://        printf("Test player %d with %d card(s).\n", p, numOfCards);
      334:   83:        memset(&G, 23, sizeof(struct gameState));   // clear the game state
      334:   84:        r = initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
        -:   85:        
        -:   86:        //set the amount of cards in each pile    
      334:   87:        G.handCount[p] = numOfCards;
      334:   88:        G.deckCount[p] = numOfCards;
      334:   89:        G.discardCount[p] = numOfCards;    
        -:   90:        
        -:   91:        //set all the cards in players hand to the appropriate card
        -:   92:        int cardNum;
    28390:   93:        for(cardNum = 0; cardNum <= numOfCards; cardNum++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
    28056:   94:            G.hand[p][cardNum] = copper; 
    28056:   95:            G.discard[p][cardNum] = estate;     
    28056:   96:            G.deck[p][cardNum] = estate;    
        -:   97:        }    
        -:   98:            
      334:   99:        returnedCount = fullDeckCount(p, copper, &G);    
call    0 returned 100%
        -:  100:        
      334:  101:        expected =  numOfCards; 
      334:  102:        if(returnedCount != expected){//check if score is correct
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  103:            printf("****FAIL Returned Count = %d, expected = %d\n", returnedCount, expected); 
call    0 never executed
    #####:  104:            errors++;
        -:  105:        }  
        -:  106:#if (NOISY_TEST == 1) 
        -:  107:        else{
        -:  108:            printf("PASS Returned Count = %d, expected = %d\n", returnedCount, expected);}    
        -:  109:#endif            
        -:  110:        }
        -:  111:    }
        -:  112:    
        -:  113: //   printf("Testing for cards only in deck:\n");
        3:  114:    for (p = 0; p <numPlayer; p++){
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
      336:  115:        for(numOfCards = 0; numOfCards <= equalDivCards; numOfCards++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  116://        printf("Test player %d with %d card(s).\n", p, numOfCards);
      334:  117:        memset(&G, 23, sizeof(struct gameState));   // clear the game state
      334:  118:        r = initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
        -:  119:        
        -:  120:        //set the amount of cards in each pile    
      334:  121:        G.handCount[p] = numOfCards;
      334:  122:        G.deckCount[p] = numOfCards;
      334:  123:        G.discardCount[p] = numOfCards;    
        -:  124:        
        -:  125:        //set all the cards in players hand to the appropriate card
        -:  126:        int cardNum;
    28390:  127:        for(cardNum = 0; cardNum <= numOfCards; cardNum++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
    28056:  128:            G.hand[p][cardNum] = estate; 
    28056:  129:            G.discard[p][cardNum] = estate;     
    28056:  130:            G.deck[p][cardNum] = copper;    
        -:  131:        }    
        -:  132:            
      334:  133:        returnedCount = fullDeckCount(p, copper, &G);    
call    0 returned 100%
        -:  134:        
      334:  135:        expected =  numOfCards; 
      334:  136:        if(returnedCount != expected){//check if score is correct
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  137:            printf("****FAIL Returned Count = %d, expected = %d\n", returnedCount, expected); 
call    0 never executed
    #####:  138:            errors++;
        -:  139:        }  
        -:  140:#if (NOISY_TEST == 1) 
        -:  141:        else{
        -:  142:            printf("PASS Returned Count = %d, expected = %d\n", returnedCount, expected);}    
        -:  143:#endif            
        -:  144:        }
        -:  145:    }
        -:  146:    
        -:  147: //   printf("Testing for cards only in discard:\n");
        3:  148:    for (p = 0; p <numPlayer; p++){
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
      336:  149:        for(numOfCards = 0; numOfCards <= equalDivCards; numOfCards++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  150: //       printf("Test player %d with %d card(s).\n", p, numOfCards);
      334:  151:        memset(&G, 23, sizeof(struct gameState));   // clear the game state
      334:  152:        r = initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
        -:  153:        
        -:  154:        //set the amount of cards in each pile    
      334:  155:        G.handCount[p] = numOfCards;
      334:  156:        G.deckCount[p] = numOfCards;
      334:  157:        G.discardCount[p] = numOfCards;    
        -:  158:        
        -:  159:        //set all the cards in players hand to the appropriate card
        -:  160:        int cardNum;
    28390:  161:        for(cardNum = 0; cardNum <= numOfCards; cardNum++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
    28056:  162:            G.hand[p][cardNum] = estate; 
    28056:  163:            G.discard[p][cardNum] = copper;     
    28056:  164:            G.deck[p][cardNum] = estate;    
        -:  165:        }    
        -:  166:            
      334:  167:        returnedCount = fullDeckCount(p, copper, &G);    
call    0 returned 100%
        -:  168:        
      334:  169:        expected =  numOfCards; 
      334:  170:        if(returnedCount != expected){//check if score is correct
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  171:            printf("****FAIL Returned Count = %d, expected = %d\n", returnedCount, expected); 
call    0 never executed
    #####:  172:            errors++;
        -:  173:        }  
        -:  174:#if (NOISY_TEST == 1) 
        -:  175:        else{
        -:  176:            printf("PASS Returned Count = %d, expected = %d\n", returnedCount, expected);}    
        -:  177:#endif            
        -:  178:        }
        -:  179:    }
        -:  180:
        1:  181:    if(errors == 0){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  182:     printf("ALL TESTS PASS for fullDeckCount().\n");   
call    0 returned 100%
        -:  183:    }
        -:  184:    else{
    #####:  185:     printf("FAIL: There are %d errors.\n",errors);   
call    0 never executed
        -:  186:    }
        -:  187:    
        1:  188: return 0;   
        -:  189:}
----------------- Testing whoseTurn() ----------------

ALL TESTS PASS for whoseTurn().
File 'unittest4.c'
Lines executed:82.76% of 29
Creating 'unittest4.c.gcov'

File 'unittest4.c'
Lines executed:82.76% of 29
Branches executed:100.00% of 12
Taken at least once:75.00% of 12
Calls executed:70.00% of 10
Creating 'unittest4.c.gcov'

        -:    0:Source:unittest4.c
        -:    0:Graph:unittest4.gcno
        -:    0:Data:unittest4.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* -----------------------------------------------------------------------
        -:    2: * Name: Alex Marsh
        -:    3: * CS362
        -:    4: * unittest4.c
        -:    5: * This tests the function whoseTurn() function in dominion.c
        -:    6: * Include the following lines in your makefile:
        -:    7: *
        -:    8: * unittest4: unittest4.c dominion.o rngs.o
        -:    9: *      gcc -o unittest4 -g  unittest4.c dominion.o rngs.o $(CFLAGS)
        -:   10: * -----------------------------------------------------------------------
        -:   11: */
        -:   12:
        -:   13:#include <string.h>
        -:   14:#include <stdio.h>
        -:   15:#include <assert.h>
        -:   16:#include <math.h>
        -:   17:#include "dominion.h"
        -:   18:#include "dominion_helpers.h"
        -:   19:#include "interface.h"
        -:   20:#include "rngs.h"
        -:   21:
        -:   22:// set NOISY_TEST to 0 to remove printfs from output
        -:   23://to include printfs set to 1
        -:   24:#define NOISY_TEST 0
        -:   25:
function main called 1 returned 100% blocks executed 81%
        1:   26:int main(){
        1:   27:    int numPlayer = 4;
        1:   28:    int seed = 1000;
        -:   29:    int r;
        -:   30:    int expected, returnedPlayer;
        -:   31:    int numOfGames, players;
        1:   32:    int errors = 0;
        1:   33:    int totalGames = 11; //test for 10 games
        1:   34:    int k[10] = {adventurer, council_room, feast, gardens, mine
        -:   35:               , remodel, smithy, village, baron, great_hall};
        -:   36:    struct gameState G;
        1:   37:    printf("----------------- Testing whoseTurn() ----------------\n");
call    0 returned 100%
        1:   38:    printf("\n"); 
call    0 returned 100%
        -:   39:    
       11:   40:    for(numOfGames = 1; numOfGames < totalGames; numOfGames++){     
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
       10:   41:        memset(&G, 23, sizeof(struct gameState));   // clear the game state
       10:   42:        r = initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
        -:   43: //       printf("Game %d\n", numOfGames);
        -:   44:        
       10:   45:        returnedPlayer = whoseTurn(&G);  //get current player
call    0 returned 100%
        -:   46://        printf("returnedPlayer is %d\n", returnedPlayer);
        -:   47://        printf("r is %d\n", r);  //printCurrent player
        -:   48: 
       10:   49:        expected = r; //expected player is 
       10:   50:        if(returnedPlayer != expected){//check if score is correct
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   51:            printf("****FAIL Returned Player = %d, expected = %d\n", returnedPlayer, expected); 
call    0 never executed
    #####:   52:            errors++;
        -:   53:        }  
        -:   54:#if (NOISY_TEST == 1)
        -:   55: 
        -:   56:        else{
        -:   57:            printf("PASS Returned Player = %d, expected = %d\n", returnedPlayer, expected);}  
        -:   58:#endif        
        -:   59:        //loop through the players. Once all of the players have had
        -:   60:        //a turn, whoseTurn() should loop around to the first player
       50:   61:        for(players=0; players < numPlayer; players++){
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
       40:   62:            endTurn(&G); //end current players turn and change players
call    0 returned 100%
       40:   63:            returnedPlayer = whoseTurn(&G);
call    0 returned 100%
       40:   64:            if(players < numPlayer - 1){
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
       30:   65:                expected= expected + 1; 
        -:   66:    //        printf("returnedPlayer after endTurn is %d\n", returnedPlayer);
        -:   67:            }
        -:   68:            else{  //whoseTurn should loop back to 0
       10:   69:              expected = 0;    
        -:   70:            }
       40:   71:            if(returnedPlayer != expected){//check if score is correct
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   72:                printf("****FAIL Returned Player after endTurn = %d, expected = %d\n", returnedPlayer, expected); 
call    0 never executed
    #####:   73:                errors++;
        -:   74:            }  
        -:   75:
        -:   76:#if (NOISY_TEST == 1)
        -:   77:     
        -:   78:            else{
        -:   79:                printf("PASS Returned Player after endTurn = %d, expected = %d\n", returnedPlayer, expected);} 
        -:   80:#endif
        -:   81:        }
        -:   82:    
        -:   83:    }
        -:   84:    
        1:   85:    if(errors == 0){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   86:     printf("ALL TESTS PASS for whoseTurn().\n");   
call    0 returned 100%
        -:   87:    }
        -:   88:    else{
    #####:   89:     printf("FAIL: There are %d errors in whoseTurn.\n", errors);   
call    0 never executed
        -:   90:    }
        -:   91:    
        1:   92: return 0;   
        -:   93:}
----------------- Testing Card: smithy ----------------
****FAIL Returned Hand Count = 8, expected = 7
****FAIL Returned Deck Count for Player 0 = 0, expected = 2
****FAIL Estate Count for Player 0 = 6, expected = 8
FAIL: There are 3 errors for playing smithy card.
File 'cardtest1.c'
Lines executed:73.58% of 53
Creating 'cardtest1.c.gcov'

File 'cardtest1.c'
Lines executed:73.58% of 53
Branches executed:100.00% of 22
Taken at least once:54.55% of 22
Calls executed:46.67% of 15
Creating 'cardtest1.c.gcov'

        -:    0:Source:cardtest1.c
        -:    0:Graph:cardtest1.gcno
        -:    0:Data:cardtest1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2: * cardtest1.c
        -:    3: *
        -:    4: 
        -:    5: */
        -:    6:
        -:    7:/*
        -:    8: * Include the following lines in your makefile:
        -:    9: *
        -:   10: * cardtest1: cardtest1.c dominion.o rngs.o
        -:   11: *      gcc -o cardtest1 -g  cardtest1.c dominion.o rngs.o $(CFLAGS)
        -:   12: */
        -:   13:
        -:   14:
        -:   15:#include "dominion.h"
        -:   16:#include "dominion_helpers.h"
        -:   17:#include <string.h>
        -:   18:#include <stdio.h>
        -:   19:#include <assert.h>
        -:   20:#include "rngs.h"
        -:   21:#include <stdlib.h>
        -:   22:
        -:   23:#define TESTCARD "smithy"
        -:   24:
function main called 1 returned 100% blocks executed 66%
        1:   25:int main() {
        1:   26:    int numPlayers = 2;
        1:   27:    int choice1 = 0, choice2 = 0, choice3 = 0;
        1:   28:    int handpos = 0, bonus = 0;
        1:   29:    int thisPlayer = 0, otherPlayer = 1;
        1:   30:    int shuffledCards = 0;
        1:   31:    int seed = 1000;
        1:   32:    int newCards = 3;
        1:   33:    int discarded = 1;
        1:   34:    int errors = 0;
        -:   35:    int recievedResult, expected;
        -:   36:    struct gameState G, testG;
        1:   37:	int k[10] = {adventurer, embargo, village, minion, mine, cutpurse,
        -:   38:			sea_hag, tribute, smithy, council_room};
        -:   39:    
        -:   40:    // initialize a game state and player cards
        1:   41:	initializeGame(numPlayers, k, seed, &G);
call    0 returned 100%
        -:   42:    //insert a smithy card in players hand for testing
        1:   43:    G.hand[thisPlayer][0] = smithy; 
        -:   44://    printf("What is deckCount of game: %d\n", G.deckCount[thisPlayer]);
        1:   45:	printf("----------------- Testing Card: %s ----------------\n", TESTCARD);
call    0 returned 100%
        -:   46:    
        -:   47:    // copy the game state to a test case
        1:   48:	memcpy(&testG, &G, sizeof(struct gameState));
        -:   49:    //call cardEffect
        1:   50:    cardEffect(smithy, choice1, choice2, choice3, &testG, handpos, &bonus);
call    0 returned 100%
        -:   51:    
        -:   52:    //test to make sure play is recieving 3 cards
        1:   53:    recievedResult = testG.handCount[thisPlayer];
        1:   54:    expected = G.handCount[thisPlayer] + newCards - discarded;
        -:   55: //   printf("Player %d hand count = %d, expected = %d\n", thisPlayer, recievedResult, expected);
        1:   56:    if(recievedResult != expected){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   57:        //check if hand is correct
        1:   58:            printf("****FAIL Returned Hand Count = %d, expected = %d\n", recievedResult, expected); 
call    0 returned 100%
        1:   59:            errors++;
        -:   60:    }
        -:   61:    
        -:   62:    //test to make sure player is drawing from their own pile
        -:   63: //   printf("Player %d deck count = %d, expected = %d\n", thisPlayer, testG.deckCount[thisPlayer], G.deckCount[thisPlayer] - newCards + shuffledCards);
        1:   64:    if(testG.deckCount[thisPlayer] != G.deckCount[thisPlayer] - newCards + shuffledCards){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   65:        //check if deck is correct
        1:   66:            printf("****FAIL Returned Deck Count for Player %d = %d, expected = %d\n", thisPlayer, testG.deckCount[thisPlayer], G.deckCount[thisPlayer] - newCards + shuffledCards); 
call    0 returned 100%
        1:   67:            errors++;
        -:   68:    }
        -:   69:    
        -:   70:    
        -:   71:    //test to make sure other players game state has not changed
        -:   72:    //test to make sure other players hand is not changed
        1:   73:    recievedResult = testG.handCount[otherPlayer];
        1:   74:    expected = G.handCount[otherPlayer];
        -:   75://    printf("Player %d hand count = %d, expected = %d\n", otherPlayer, recievedResult, expected);
        1:   76:    if(recievedResult != expected){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   77:        //check if hand is correct
    #####:   78:            printf("****FAIL Returned Hand Count for Player %d = %d, expected = %d\n", otherPlayer, recievedResult, expected); 
call    0 never executed
    #####:   79:            errors++;
        -:   80:    }
        -:   81:    
        -:   82:    //test to make sure other player deck is same and first player did not draw
        -:   83:    //from other players pile
        -:   84: //   printf("Player %d deck count = %d, expected = %d\n", otherPlayer, testG.deckCount[otherPlayer], G.deckCount[otherPlayer]);
        1:   85:    if(testG.deckCount[otherPlayer] != G.deckCount[otherPlayer]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   86:        //check if deck is correct
    #####:   87:            printf("****FAIL Returned Deck Count for Player %d = %d, expected = %d\n", otherPlayer, testG.deckCount[thisPlayer], G.deckCount[thisPlayer]); 
call    0 never executed
    #####:   88:            errors++;
        -:   89:    }
        -:   90:    
        -:   91:    //test to make sure victory card piles where untouched.
        -:   92:    //check curse
        1:   93:    if(testG.supplyCount[curse] != G.supplyCount[curse]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   94:         printf("****FAIL Curse Count for Player %d = %d, expected = %d\n", thisPlayer, testG.supplyCount[curse], G.supplyCount[curse]); 
call    0 never executed
    #####:   95:            errors++;
        -:   96:    }
        -:   97:    //check estate
        1:   98:    if(testG.supplyCount[estate] != G.supplyCount[estate]){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   99:         printf("****FAIL Estate Count for Player %d = %d, expected = %d\n", thisPlayer, testG.supplyCount[estate], G.supplyCount[estate]); 
call    0 returned 100%
        1:  100:            errors++;
        -:  101:    }
        -:  102:    //check duchy
        1:  103:    if(testG.supplyCount[duchy] != G.supplyCount[duchy]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  104:         printf("****FAIL Duchy Count for Player %d = %d, expected = %d\n", thisPlayer, testG.supplyCount[duchy], G.supplyCount[duchy]); 
call    0 never executed
    #####:  105:            errors++;
        -:  106:    }
        -:  107:    //check province
        1:  108:    if(testG.supplyCount[province] != G.supplyCount[province]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  109:         printf("****FAIL Province Count for Player %d = %d, expected = %d\n", thisPlayer, testG.supplyCount[province], G.supplyCount[province]); 
call    0 never executed
    #####:  110:            errors++;
        -:  111:    }
        -:  112:    
        -:  113:    //test to make sure the kingdom cards count have not been altered
        -:  114:    int i;
       11:  115:    for(i=0; i < 10; i++){
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
       10:  116:        if(testG.supplyCount[k[i]] != G.supplyCount[k[i]]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  117:         printf("****FAIL Count for Player %d = %d, expected = %d\n", thisPlayer, testG.supplyCount[k[i]], G.supplyCount[k[i]]); 
call    0 never executed
    #####:  118:            errors++;
    #####:  119:         printf("%d is incorrect\n", k[i]);    
call    0 never executed
        -:  120:        }
        -:  121:    }
        -:  122:    
        -:  123:    
        -:  124:    
        1:  125:  if(errors == 0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  126:     printf("ALL TESTS PASS for smithy card.\n");   
call    0 never executed
        -:  127:    }
        -:  128:    else{
        1:  129:     printf("FAIL: There are %d errors for playing smithy card.\n", errors);   
call    0 returned 100%
        -:  130:    }
        -:  131:    
        1:  132: return 0;    
        -:  133:}
----------------- Testing Card: adventurer ----------------
****FAIL Player 0 Returned Hand Count = 8, expected = 6
****FAIL Returned Deck Count for Player 0 = 0, expected = 3
****FAIL Estate Count for Player 0 = 6, expected = 8
FAIL: There are 3 errors for playing adventurer card.
File 'cardtest2.c'
Lines executed:75.00% of 64
Creating 'cardtest2.c.gcov'

File 'cardtest2.c'
Lines executed:75.00% of 64
Branches executed:100.00% of 40
Taken at least once:62.50% of 40
Calls executed:43.75% of 16
Creating 'cardtest2.c.gcov'

        -:    0:Source:cardtest2.c
        -:    0:Graph:cardtest2.gcno
        -:    0:Data:cardtest2.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2: * cardtest2.c
        -:    3: *
        -:    4: 
        -:    5: */
        -:    6:
        -:    7:/*
        -:    8: * Include the following lines in your makefile:
        -:    9: *
        -:   10: * cardtest2: cardtest2.c dominion.o rngs.o
        -:   11: *      gcc -o cardtest2 -g  cardtest2.c dominion.o rngs.o $(CFLAGS)
        -:   12: */
        -:   13:
        -:   14:
        -:   15:#include "dominion.h"
        -:   16:#include "dominion_helpers.h"
        -:   17:#include <string.h>
        -:   18:#include <stdio.h>
        -:   19:#include <assert.h>
        -:   20:#include "rngs.h"
        -:   21:#include <stdlib.h>
        -:   22:
        -:   23:#define TESTCARD "adventurer"
        -:   24:
function main called 1 returned 100% blocks executed 73%
        1:   25:int main() {
        1:   26:    int numPlayers = 2, thisPlayer = 0, otherPlayer = 1;
        1:   27:    int newCards = 2, discarded = 1;
        1:   28:    int errors = 0;
        1:   29:    int seed = 1000;
        1:   30:    int choice1 = 0, choice2 = 0, choice3 = 0;
        1:   31:    int handpos = 0, bonus = 0;
        -:   32:    int testTreasureCount, realTreasureCount;
        -:   33:    int testHandCount, realHandCount;
        1:   34:    int handIndex, shuffledCards = 0;
        -:   35:    struct gameState G, testG;
        1:   36:	int k[10] = {adventurer, embargo, village, minion, mine, cutpurse,
        -:   37:			sea_hag, tribute, smithy, council_room};
        -:   38:    
        -:   39:    // initialize a game state and player cards
        1:   40:	initializeGame(numPlayers, k, seed, &G);
call    0 returned 100%
        -:   41:    //insert a adventurer card in players hand for testing
        1:   42:    G.hand[thisPlayer][0] = adventurer; 
        1:   43:    printf("----------------- Testing Card: %s ----------------\n", TESTCARD);
call    0 returned 100%
        -:   44:    // copy the game state to a test case
        1:   45:	memcpy(&testG, &G, sizeof(struct gameState));
        -:   46:    
        -:   47:    //get amount of treasure cards in hand before adventure card is played
        1:   48:    realHandCount = G.handCount[thisPlayer];  //get current num of cards in hand
        -:   49:    
        -:   50:    //print players hand for error checking. 
        1:   51:    realTreasureCount = 0;
        -:   52://    if(realHandCount > 0) printf("#  Card\n");
        6:   53:    for(handIndex = 0; handIndex < realHandCount; handIndex++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        5:   54:        int card = G.deck[thisPlayer][handIndex];
        5:   55:        if(card == 4 || card == 5 || card == 6){
branch  0 taken 40% (fallthrough)
branch  1 taken 60%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        3:   56:           realTreasureCount++;    
        -:   57:        }
        -:   58:    }
        -:   59://    printf("Player %d's hand has %d treasure cards BEFORE:\n", thisPlayer, realTreasureCount);
        -:   60://    printf("\n");  
        -:   61:    
        -:   62:    
        -:   63:    //call cardEffect
        1:   64:    cardEffect(smithy, choice1, choice2, choice3, &testG, handpos, &bonus);
call    0 returned 100%
        -:   65:    
        -:   66:    //check to see that 2 treasure cards 
        -:   67:    //test to make sure play is recieving 2 cards
        -:   68:    //and then discarding 1, resulting in the handCount
        -:   69:    //growing by 1
        -:   70: //   printf("Player %d hand count = %d, expected = %d\n", thisPlayer, testG.handCount[thisPlayer], G.handCount[thisPlayer] + newCards - discarded);
        1:   71:    if(testG.handCount[thisPlayer] != G.handCount[thisPlayer] + newCards - discarded){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   72:        //check if hand is correct
        1:   73:            printf("****FAIL Player %d Returned Hand Count = %d, expected = %d\n", thisPlayer, testG.handCount[thisPlayer], G.handCount[thisPlayer] + newCards - discarded); 
call    0 returned 100%
        1:   74:            errors++;
        -:   75:    }
        -:   76:    
        -:   77:    //test to see that cards added are treasure cards
        -:   78:    //the enum for copper is 4, silver =5, and gold =6
        -:   79:    //get amount of treasure cards in hand before adventure card is played
        1:   80:    testHandCount = testG.handCount[thisPlayer];  //get current num of cards in hand
        -:   81:    
        -:   82:    //print players hand for error checking. 
        1:   83:    testTreasureCount = 0;
        -:   84: //   if(testHandCount > 0) printf("#  Card\n");
        9:   85:    for(handIndex = 0; handIndex < testHandCount; handIndex++) {
branch  0 taken 89%
branch  1 taken 11% (fallthrough)
        8:   86:        int card = testG.deck[thisPlayer][handIndex];
        8:   87:        if(card == 4 || card == 5 || card == 6){
branch  0 taken 38% (fallthrough)
branch  1 taken 63%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        5:   88:           testTreasureCount++;    
        -:   89:        }
        -:   90:    }
        -:   91://    printf("Player %d's test hand has %d treasure cards AFTER:\n", thisPlayer, testTreasureCount);
        -:   92://    printf("\n");
        -:   93://    printf("Player %d treasure count in hand= %d, expected = %d\n", thisPlayer, testTreasureCount, realTreasureCount+2);
        1:   94:    if(testTreasureCount != realTreasureCount+2){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   95:        //check if hand is correct
    #####:   96:            printf("****FAIL Player %d Returned Treasure Count in Hand = %d, expected = %d\n", thisPlayer, testTreasureCount, realTreasureCount+2); 
call    0 never executed
    #####:   97:            errors++;
        -:   98:    }
        -:   99:    
        -:  100:    //
        -:  101:    //test to make sure player is drawing from their own pile
        -:  102://    printf("Player %d deck count = %d, expected = %d\n", thisPlayer, testG.deckCount[thisPlayer], G.deckCount[thisPlayer] - newCards + shuffledCards);
        1:  103:    if(testG.deckCount[thisPlayer] != G.deckCount[thisPlayer] - newCards + shuffledCards){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  104:        //check if deck is correct
        1:  105:            printf("****FAIL Returned Deck Count for Player %d = %d, expected = %d\n", thisPlayer, testG.deckCount[thisPlayer], G.deckCount[thisPlayer] - newCards + shuffledCards); 
call    0 returned 100%
        1:  106:            errors++;
        -:  107:    }
        -:  108:    
        -:  109:    //test to make sure other players game state has not changed
        -:  110:    //test to make sure other players hand is not changed
        1:  111:    int recievedResult = testG.handCount[otherPlayer];
        1:  112:    int expected = G.handCount[otherPlayer];
        -:  113: //   printf("Player %d hand count = %d, expected = %d\n", otherPlayer, recievedResult, expected);
        1:  114:    if(recievedResult != expected){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  115:        //check if hand is correct
    #####:  116:            printf("****FAIL Returned Hand Count for Player %d = %d, expected = %d\n", otherPlayer, recievedResult, expected); 
call    0 never executed
    #####:  117:            errors++;
        -:  118:    }
        -:  119:    
        -:  120:    //test to make sure other player deck is same and first player did not draw
        -:  121:    //from other players pile
        -:  122://    printf("Player %d deck count = %d, expected = %d\n", otherPlayer, testG.deckCount[otherPlayer], G.deckCount[otherPlayer]);
        1:  123:    if(testG.deckCount[otherPlayer] != G.deckCount[otherPlayer]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  124:        //check if deck is correct
    #####:  125:            printf("****FAIL Returned Deck Count for Player %d = %d, expected = %d\n", otherPlayer, testG.deckCount[thisPlayer], G.deckCount[thisPlayer]); 
call    0 never executed
    #####:  126:            errors++;
        -:  127:    }
        -:  128:    
        -:  129:    //test to make sure victory card piles where untouched.
        -:  130:    //check curse
        1:  131:    if(testG.supplyCount[curse] != G.supplyCount[curse]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  132:         printf("****FAIL Curse Count for Player %d = %d, expected = %d\n", thisPlayer, testG.supplyCount[curse], G.supplyCount[curse]); 
call    0 never executed
    #####:  133:            errors++;
        -:  134:    }
        -:  135:    //check estate
        1:  136:    if(testG.supplyCount[estate] != G.supplyCount[estate]){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  137:         printf("****FAIL Estate Count for Player %d = %d, expected = %d\n", thisPlayer, testG.supplyCount[estate], G.supplyCount[estate]); 
call    0 returned 100%
        1:  138:            errors++;
        -:  139:    }
        -:  140:    //check duchy
        1:  141:    if(testG.supplyCount[duchy] != G.supplyCount[duchy]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  142:         printf("****FAIL Duchy Count for Player %d = %d, expected = %d\n", thisPlayer, testG.supplyCount[duchy], G.supplyCount[duchy]); 
call    0 never executed
    #####:  143:            errors++;
        -:  144:    }
        -:  145:    //check province
        1:  146:    if(testG.supplyCount[province] != G.supplyCount[province]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  147:         printf("****FAIL Province Count for Player %d = %d, expected = %d\n", thisPlayer, testG.supplyCount[province], G.supplyCount[province]); 
call    0 never executed
    #####:  148:            errors++;
        -:  149:    }
        -:  150:    
        -:  151:    //test to make sure the kingdom cards count have not been altered
        -:  152:    int i;
       11:  153:    for(i=0; i < 10; i++){
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
       10:  154:        if(testG.supplyCount[k[i]] != G.supplyCount[k[i]]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  155:         printf("****FAIL Count for Player %d = %d, expected = %d\n", thisPlayer, testG.supplyCount[k[i]], G.supplyCount[k[i]]); 
call    0 never executed
    #####:  156:            errors++;
    #####:  157:         printf("%d is incorrect\n", k[i]);    
call    0 never executed
        -:  158:        }
        -:  159:    }
        -:  160:    
        1:  161:    if(errors == 0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  162:     printf("ALL TESTS PASS for adventurer card.\n");   
call    0 never executed
        -:  163:    }
        -:  164:    else{
        1:  165:     printf("FAIL: There are %d errors for playing adventurer card.\n", errors);   
call    0 returned 100%
        -:  166:    }
        1:  167: return 0; 
        -:  168:}
----------------- Testing Card: village ----------------
****FAIL Returned Hand Count = 6, expected = 5
****FAIL Returned Deck Count for Player 0 = 3, expected = 4
****FAIL Estate Count for Player 0 = 6, expected = 8
FAIL: There are 3 errors for playing village card.
File 'cardtest3.c'
Lines executed:71.43% of 56
Creating 'cardtest3.c.gcov'

File 'cardtest3.c'
Lines executed:71.43% of 56
Branches executed:100.00% of 24
Taken at least once:54.17% of 24
Calls executed:43.75% of 16
Creating 'cardtest3.c.gcov'

        -:    0:Source:cardtest3.c
        -:    0:Graph:cardtest3.gcno
        -:    0:Data:cardtest3.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2: * cardtest3.c
        -:    3: *
        -:    4: 
        -:    5: */
        -:    6:
        -:    7:/*
        -:    8: * Include the following lines in your makefile:
        -:    9: *
        -:   10: * cardtest3: cardtest3.c dominion.o rngs.o
        -:   11: *      gcc -o cardtest3 -g  cardtest3.c dominion.o rngs.o $(CFLAGS)
        -:   12: */
        -:   13:
        -:   14:
        -:   15:#include "dominion.h"
        -:   16:#include "dominion_helpers.h"
        -:   17:#include <string.h>
        -:   18:#include <stdio.h>
        -:   19:#include <assert.h>
        -:   20:#include "rngs.h"
        -:   21:#include <stdlib.h>
        -:   22:
        -:   23:#define TESTCARD "village"
        -:   24:
function main called 1 returned 100% blocks executed 63%
        1:   25:int main() {
        1:   26:    int numPlayers = 2;
        1:   27:    int choice1 = 0, choice2 = 0, choice3 = 0;
        1:   28:    int handpos = 0, bonus = 0;
        1:   29:    int thisPlayer = 0, otherPlayer = 1;
        1:   30:    int shuffledCards = 0;
        1:   31:    int seed = 1000;
        1:   32:    int newCards = 1;
        1:   33:    int discarded = 1;
        1:   34:    int errors = 0;
        -:   35:    int recievedResult, expected;
        -:   36:    struct gameState G, testG;
        1:   37:	int k[10] = {adventurer, embargo, village, minion, mine, cutpurse,
        -:   38:			sea_hag, tribute, smithy, council_room};
        -:   39:    
        -:   40:    // initialize a game state and player cards
        1:   41:	initializeGame(numPlayers, k, seed, &G);
call    0 returned 100%
        -:   42:    //insert a village card in players hand for testing
        1:   43:    G.hand[thisPlayer][0] = village; 
        -:   44:    
        1:   45:	printf("----------------- Testing Card: %s ----------------\n", TESTCARD);
call    0 returned 100%
        -:   46:    // copy the game state to a test case
        1:   47:	memcpy(&testG, &G, sizeof(struct gameState));
        -:   48:    //call cardEffect
        1:   49:    cardEffect(village, choice1, choice2, choice3, &testG, handpos, &bonus);
call    0 returned 100%
        -:   50:    
        -:   51:    //test to make sure play is recieving 1 cards
        -:   52:    //the player should draw 1 card and discard the village card
        -:   53:    //this should make the hand the same count
        1:   54:    recievedResult = testG.handCount[thisPlayer];
        1:   55:    expected = G.handCount[thisPlayer] + newCards - discarded;
        -:   56: //   printf("Player %d hand count = %d, expected = %d\n", thisPlayer, recievedResult, expected);
        1:   57:    if(recievedResult != expected){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   58:        //check if hand is correct
        1:   59:            printf("****FAIL Returned Hand Count = %d, expected = %d\n", recievedResult, expected); 
call    0 returned 100%
        1:   60:            errors++;
        -:   61:    }
        -:   62:    
        -:   63:    //test to make sure player is drawing from their own pile
        -:   64: //   printf("Player %d deck count = %d, expected = %d\n", thisPlayer, testG.deckCount[thisPlayer], G.deckCount[thisPlayer] - newCards + shuffledCards);
        1:   65:    if(testG.deckCount[thisPlayer] != G.deckCount[thisPlayer] - newCards + shuffledCards){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   66:        //check if deck is correct
        1:   67:            printf("****FAIL Returned Deck Count for Player %d = %d, expected = %d\n", thisPlayer, testG.deckCount[thisPlayer], G.deckCount[thisPlayer] - newCards + shuffledCards); 
call    0 returned 100%
        1:   68:            errors++;
        -:   69:    }
        -:   70:    
        -:   71:    //test for players number of actions
        -:   72:    //the player shoud have 2 action moves
        -:   73: //   printf("Player %d action count = %d, expected = %d\n", thisPlayer, testG.numActions, G.numActions+2);
        1:   74:    if(testG.numActions != G.numActions+2){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   75:        //check if deck is correct
    #####:   76:            printf("****FAIL Returned Action Count for Player %d = %d, expected = %d\n", thisPlayer, testG.numActions, G.numActions+2); 
call    0 never executed
    #####:   77:            errors++;
        -:   78:    }
        -:   79:    
        -:   80:        //test to make sure other players game state has not changed
        -:   81:    
        -:   82:    //test to make sure other players hand is not changed
        1:   83:    recievedResult = testG.handCount[otherPlayer];
        1:   84:    expected = G.handCount[otherPlayer];
        -:   85: //   printf("Player %d hand count = %d, expected = %d\n", otherPlayer, recievedResult, expected);
        1:   86:    if(recievedResult != expected){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   87:        //check if hand is correct
    #####:   88:            printf("****FAIL Returned Hand Count for Player %d = %d, expected = %d\n", otherPlayer, recievedResult, expected); 
call    0 never executed
    #####:   89:            errors++;
        -:   90:    }
        -:   91:    
        -:   92:    //test to make sure other player deck is same and first player did not draw
        -:   93:    //from other players pile
        -:   94://    printf("Player %d deck count = %d, expected = %d\n", otherPlayer, testG.deckCount[otherPlayer], G.deckCount[otherPlayer]);
        1:   95:    if(testG.deckCount[otherPlayer] != G.deckCount[otherPlayer]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   96:        //check if deck is correct
    #####:   97:            printf("****FAIL Returned Deck Count for Player %d = %d, expected = %d\n", otherPlayer, testG.deckCount[thisPlayer], G.deckCount[thisPlayer]); 
call    0 never executed
    #####:   98:            errors++;
        -:   99:    }
        -:  100:    
        -:  101:    //test to make sure victory card piles where untouched.
        -:  102:    //check curse
        1:  103:    if(testG.supplyCount[curse] != G.supplyCount[curse]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  104:         printf("****FAIL Curse Count for Player %d = %d, expected = %d\n", thisPlayer, testG.supplyCount[curse], G.supplyCount[curse]); 
call    0 never executed
    #####:  105:            errors++;
        -:  106:    }
        -:  107:    //check estate
        1:  108:    if(testG.supplyCount[estate] != G.supplyCount[estate]){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  109:         printf("****FAIL Estate Count for Player %d = %d, expected = %d\n", thisPlayer, testG.supplyCount[estate], G.supplyCount[estate]); 
call    0 returned 100%
        1:  110:            errors++;
        -:  111:    }
        -:  112:    //check duchy
        1:  113:    if(testG.supplyCount[duchy] != G.supplyCount[duchy]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  114:         printf("****FAIL Duchy Count for Player %d = %d, expected = %d\n", thisPlayer, testG.supplyCount[duchy], G.supplyCount[duchy]); 
call    0 never executed
    #####:  115:            errors++;
        -:  116:    }
        -:  117:    //check province
        1:  118:    if(testG.supplyCount[province] != G.supplyCount[province]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  119:         printf("****FAIL Province Count for Player %d = %d, expected = %d\n", thisPlayer, testG.supplyCount[province], G.supplyCount[province]); 
call    0 never executed
    #####:  120:            errors++;
        -:  121:    }
        -:  122:    
        -:  123:    //test to make sure the kingdom cards count have not been altered
        -:  124:    int i;
       11:  125:    for(i=0; i < 10; i++){
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
       10:  126:        if(testG.supplyCount[k[i]] != G.supplyCount[k[i]]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  127:         printf("****FAIL Count for Player %d = %d, expected = %d\n", thisPlayer, testG.supplyCount[k[i]], G.supplyCount[k[i]]); 
call    0 never executed
    #####:  128:            errors++;
    #####:  129:         printf("%d is incorrect\n", k[i]);    
call    0 never executed
        -:  130:        }
        -:  131:    }
        -:  132:    
        -:  133:    
        -:  134:    
        -:  135:    
        -:  136:    
        -:  137:    
        -:  138:    
        -:  139:    
        1:  140:    if(errors == 0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  141:     printf("ALL TESTS PASS for village card.\n");   
call    0 never executed
        -:  142:    }
        -:  143:    else{
        1:  144:     printf("FAIL: There are %d errors for playing village card.\n", errors);   
call    0 returned 100%
        -:  145:    }
        -:  146:    
        -:  147:    
        -:  148:    
        -:  149:    
        1:  150: return 0;   
        -:  151:}
----------------- Testing Card: great_hall ----------------
****FAIL Returned Hand Count = 1, expected = 5
****FAIL Returned Action Count for Player 0 = 3, expected = 2
FAIL: There are 2 errors for playing great hall card.
File 'cardtest4.c'
Lines executed:67.86% of 56
Creating 'cardtest4.c.gcov'

File 'cardtest4.c'
Lines executed:67.86% of 56
Branches executed:100.00% of 24
Taken at least once:54.17% of 24
Calls executed:37.50% of 16
Creating 'cardtest4.c.gcov'

        -:    0:Source:cardtest4.c
        -:    0:Graph:cardtest4.gcno
        -:    0:Data:cardtest4.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2: * cardtest4.c
        -:    3: *
        -:    4: 
        -:    5: */
        -:    6:
        -:    7:/*
        -:    8: * Include the following lines in your makefile:
        -:    9: *
        -:   10: * cardtest4: cardtest4.c dominion.o rngs.o
        -:   11: *      gcc -o cardtest4 -g  cardtest4.c dominion.o rngs.o $(CFLAGS)
        -:   12: */
        -:   13:
        -:   14:
        -:   15:#include "dominion.h"
        -:   16:#include "dominion_helpers.h"
        -:   17:#include <string.h>
        -:   18:#include <stdio.h>
        -:   19:#include <assert.h>
        -:   20:#include "rngs.h"
        -:   21:#include <stdlib.h>
        -:   22:
        -:   23:#define TESTCARD "great_hall"
        -:   24:
function main called 1 returned 100% blocks executed 59%
        1:   25:int main() {
        1:   26:    int numPlayers = 2;
        1:   27:    int choice1 = 0, choice2 = 0, choice3 = 0;
        1:   28:    int handpos = 0, bonus = 0;
        1:   29:    int thisPlayer = 0, otherPlayer = 1;
        1:   30:    int shuffledCards = 0;
        1:   31:    int seed = 1000;
        1:   32:    int newCards = 1;
        1:   33:    int discarded = 1;
        1:   34:    int errors = 0;
        -:   35:    int recievedResult, expected;
        -:   36:    struct gameState G, testG;
        1:   37:	int k[10] = {adventurer, embargo, village, minion, mine, cutpurse,
        -:   38:			sea_hag, tribute, smithy, council_room};
        -:   39:    
        -:   40:    // initialize a game state and player cards
        1:   41:	initializeGame(numPlayers, k, seed, &G);
call    0 returned 100%
        -:   42:    //insert a smithy card in players hand for testing
        1:   43:    G.hand[thisPlayer][0] = great_hall; 
        -:   44:    
        1:   45:	printf("----------------- Testing Card: %s ----------------\n", TESTCARD);
call    0 returned 100%
        -:   46:    
        -:   47:    // copy the game state to a test case
        1:   48:	memcpy(&testG, &G, sizeof(struct gameState));
        -:   49: //   printf("BEFORE---Player %d hand count = %d, expected = %d\n", thisPlayer, testG.handCount[thisPlayer], G.handCount[thisPlayer] + newCards - discarded);
        -:   50:    //call cardEffect
        1:   51:    cardEffect(great_hall, choice1, choice2, choice3, &testG, handpos, &bonus);
call    0 returned 100%
        -:   52:    
        -:   53:    //test to make sure play is recieving 1 card
        -:   54:    //the player should draw 1 card and discard the great hall card
        -:   55:    //this should make the hand the same count
        1:   56:    recievedResult = testG.handCount[thisPlayer];
        1:   57:    expected = G.handCount[thisPlayer] + newCards - discarded;
        -:   58: //   printf("Player %d hand count = %d, expected = %d\n", thisPlayer, recievedResult, expected);
        1:   59:    if(recievedResult != expected){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   60:        //check if hand is correct
        1:   61:            printf("****FAIL Returned Hand Count = %d, expected = %d\n", recievedResult, expected); 
call    0 returned 100%
        1:   62:            errors++;
        -:   63:    }
        -:   64:    
        -:   65:    //test to make sure player is drawing from their own pile
        -:   66: //   printf("Player %d deck count = %d, expected = %d\n", thisPlayer, testG.deckCount[thisPlayer], G.deckCount[thisPlayer] - newCards + shuffledCards);
        1:   67:    if(testG.deckCount[thisPlayer] != G.deckCount[thisPlayer] - newCards + shuffledCards){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   68:        //check if deck is correct
    #####:   69:            printf("****FAIL Returned Deck Count for Player %d = %d, expected = %d\n", thisPlayer, testG.deckCount[thisPlayer], G.deckCount[thisPlayer] - newCards + shuffledCards); 
call    0 never executed
    #####:   70:            errors++;
        -:   71:    }
        -:   72:    
        -:   73:    //test for players number of actions
        -:   74:    //the player shoud have 2 action moves
        -:   75: //   printf("Player %d action count = %d, expected = %d\n", thisPlayer, testG.numActions, G.numActions+1);
        1:   76:    if(testG.numActions != G.numActions+1){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   77:        //check if deck is correct
        1:   78:            printf("****FAIL Returned Action Count for Player %d = %d, expected = %d\n", thisPlayer, testG.numActions, G.numActions+1); 
call    0 returned 100%
        1:   79:            errors++;
        -:   80:    }
        -:   81:    
        -:   82:    //test to make sure other players game state has not changed
        -:   83:    
        -:   84:    //test to make sure other players hand is not changed
        1:   85:    recievedResult = testG.handCount[otherPlayer];
        1:   86:    expected = G.handCount[otherPlayer];
        -:   87: //   printf("Player %d hand count = %d, expected = %d\n", otherPlayer, recievedResult, expected);
        1:   88:    if(recievedResult != expected){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   89:        //check if hand is correct
    #####:   90:            printf("****FAIL Returned Hand Count for Player %d = %d, expected = %d\n", otherPlayer, recievedResult, expected); 
call    0 never executed
    #####:   91:            errors++;
        -:   92:    }
        -:   93:    
        -:   94:    //test to make sure other player deck is same and first player did not draw
        -:   95:    //from other players pile
        -:   96: //   printf("Player %d deck count = %d, expected = %d\n", otherPlayer, testG.deckCount[otherPlayer], G.deckCount[otherPlayer]);
        1:   97:    if(testG.deckCount[otherPlayer] != G.deckCount[otherPlayer]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   98:        //check if deck is correct
    #####:   99:            printf("****FAIL Returned Deck Count for Player %d = %d, expected = %d\n", otherPlayer, testG.deckCount[thisPlayer], G.deckCount[thisPlayer]); 
call    0 never executed
    #####:  100:            errors++;
        -:  101:    }
        -:  102:    
        -:  103:    //test to make sure victory card piles where untouched.
        -:  104:    //check curse
        1:  105:    if(testG.supplyCount[curse] != G.supplyCount[curse]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  106:         printf("****FAIL Curse Count for Player %d = %d, expected = %d\n", thisPlayer, testG.supplyCount[curse], G.supplyCount[curse]); 
call    0 never executed
    #####:  107:            errors++;
        -:  108:    }
        -:  109:    //check estate
        1:  110:    if(testG.supplyCount[estate] != G.supplyCount[estate]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  111:         printf("****FAIL Estate Count for Player %d = %d, expected = %d\n", thisPlayer, testG.supplyCount[estate], G.supplyCount[estate]); 
call    0 never executed
    #####:  112:            errors++;
        -:  113:    }
        -:  114:    //check duchy
        1:  115:    if(testG.supplyCount[duchy] != G.supplyCount[duchy]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  116:         printf("****FAIL Duchy Count for Player %d = %d, expected = %d\n", thisPlayer, testG.supplyCount[duchy], G.supplyCount[duchy]); 
call    0 never executed
    #####:  117:            errors++;
        -:  118:    }
        -:  119:    //check province
        1:  120:    if(testG.supplyCount[province] != G.supplyCount[province]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  121:         printf("****FAIL Province Count for Player %d = %d, expected = %d\n", thisPlayer, testG.supplyCount[province], G.supplyCount[province]); 
call    0 never executed
    #####:  122:            errors++;
        -:  123:    }
        -:  124:    
        -:  125:    //test to make sure the kingdom cards count have not been altered
        -:  126:    int i;
       11:  127:    for(i=0; i < 10; i++){
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
       10:  128:        if(testG.supplyCount[k[i]] != G.supplyCount[k[i]]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  129:         printf("****FAIL Count for Player %d = %d, expected = %d\n", thisPlayer, testG.supplyCount[k[i]], G.supplyCount[k[i]]); 
call    0 never executed
    #####:  130:            errors++;
    #####:  131:         printf("%d is incorrect\n", k[i]);    
call    0 never executed
        -:  132:        }
        -:  133:    }
        -:  134:    
        -:  135:    
        -:  136:    
        -:  137:    
        -:  138:    
        -:  139:    
        -:  140:    
        -:  141:    
        1:  142:    if(errors == 0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  143:     printf("ALL TESTS PASS for great hall card.\n");   
call    0 never executed
        -:  144:    }
        -:  145:    else{
        1:  146:     printf("FAIL: There are %d errors for playing great hall card.\n", errors);   
call    0 returned 100%
        -:  147:    }
        -:  148:    
        -:  149:    
        -:  150:    
        -:  151:    
        -:  152:    
        -:  153:    
        -:  154:    
        -:  155:    
        1:  156: return 0;
        -:  157:}
File 'dominion.c'
Lines executed:46.11% of 566
Creating 'dominion.c.gcov'

File 'dominion.c'
Lines executed:46.11% of 566
Branches executed:50.60% of 417
Taken at least once:39.57% of 417
Calls executed:37.62% of 101
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:8
        -:    0:Programs:8
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function playSmithyCard called 2 returned 100% blocks executed 100%
        2:    8:void playSmithyCard(int handPos, struct gameState *state){
        -:    9:    //find current player
        2:   10:    int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:   11:    int i;
        -:   12:    //+3 Cards
       10:   13:      for (i = 0; i <= 3; i++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:   14:	{
        8:   15:	  drawCard(currentPlayer, state);
call    0 returned 100%
        -:   16:	}
        -:   17:			
        -:   18:      //discard card from hand
        2:   19:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        2:   20:}
        -:   21:
function playAdventurerCard called 0 returned 0% blocks executed 0%
    #####:   22:void playAdventurerCard(struct gameState *state){
        -:   23:     //find current player
    #####:   24:    int currentPlayer = whoseTurn(state);
call    0 never executed
        -:   25:    //set the amount of treasure to 0
    #####:   26:    int drawntreasure = 0;
        -:   27:    //set z to 0
    #####:   28:    int z = 0;
        -:   29:    int cardDrawn;
        -:   30:    //initialize a temp hand
        -:   31:    int temphand[MAX_HAND];
        -:   32:    
    #####:   33:    while(drawntreasure<2){
branch  0 never executed
branch  1 never executed
    #####:   34:        if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 never executed
branch  1 never executed
    #####:   35:          shuffle(currentPlayer, state);
call    0 never executed
        -:   36:        }
    #####:   37:        drawCard(currentPlayer, state);
call    0 never executed
    #####:   38:        cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####:   39:        if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   40:          drawntreasure++;
        -:   41:        else{
    #####:   42:          temphand[z]=cardDrawn;
    #####:   43:          state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:   44:          z++;
        -:   45:        }
        -:   46:          }
    #####:   47:     while(z-1>=0){
branch  0 never executed
branch  1 never executed
    #####:   48:        state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:   49:        z=z-1;
        -:   50:          } 
    #####:   51:}
        -:   52:    
function playVillageCard called 3 returned 100% blocks executed 100%
        3:   53:void playVillageCard(int handPos, struct gameState *state){
        -:   54:       //find current player
        3:   55:    int currentPlayer = whoseTurn(state); 
call    0 returned 100%
        -:   56:    
        -:   57:      //+1 Card
        3:   58:      drawCard(currentPlayer, state);
call    0 returned 100%
        3:   59:      drawCard(currentPlayer, state);
call    0 returned 100%
        -:   60:    
        -:   61:      //+2 Actions
        3:   62:      state->numActions = state->numActions + 2;
        -:   63:			
        -:   64:      //discard played card from hand
        3:   65:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        3:   66:}
        -:   67:
function playGreat_HallCard called 1 returned 100% blocks executed 100%
        1:   68:void playGreat_HallCard(int handPos, struct gameState *state){
        -:   69:    //find current player
        1:   70:    int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:   71:    
        -:   72:    //+1 Card
        1:   73:      drawCard(currentPlayer, state);
call    0 returned 100%
        -:   74:			
        -:   75:      //+1 Actions
        1:   76:      state->numActions++;
        -:   77:			
        -:   78:      //discard card from hand
        1:   79:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        1:   80:}
        -:   81:
function playMinionCard called 1 returned 100% blocks executed 22%
        1:   82:void playMinionCard(int handPos, int choice1, int choice2, struct gameState *state){
        -:   83:    int i;
        -:   84:    int j;
        -:   85:    //find current player
        1:   86:    int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:   87:    
        -:   88:    int cardDrawn;
        -:   89:    
        -:   90:    //+1 action
        1:   91:      state->numActions++;
        -:   92:			
        -:   93:      //discard card from hand
        1:   94:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:   95:			
        1:   96:      if (choice1)		//+2 coins
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   97:	{
    #####:   98:	  state->coins = state->coins + 2;
        -:   99:	}
        -:  100:			
        1:  101:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  102:	{
        -:  103:	  //discard hand
    #####:  104:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  105:	    {
    #####:  106:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  107:	    }
        -:  108:				
        -:  109:	  //draw 4
    #####:  110:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  111:	    {
    #####:  112:	      drawCard(currentPlayer, state);
call    0 never executed
        -:  113:	    }
        -:  114:				
        -:  115:	  //other players discard hand and redraw if hand size > 4
    #####:  116:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  117:	    {
    #####:  118:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:  119:		{
    #####:  120:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -:  121:		    {
        -:  122:		      //discard hand
    #####:  123:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -:  124:			{
    #####:  125:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -:  126:			}
        -:  127:							
        -:  128:		      //draw 4
    #####:  129:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -:  130:			{
    #####:  131:			  drawCard(i, state);
call    0 never executed
        -:  132:			}
        -:  133:		    }
        -:  134:		}
        -:  135:	    }
        -:  136:				
        -:  137:	}
        1:  138:      return 0;   
        -:  139:}
        -:  140:    
function compare called 48360 returned 100% blocks executed 83%
    48360:  141:int compare(const void* a, const void* b) {
    48360:  142:  if (*(int*)a > *(int*)b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  143:    return 1;
    48360:  144:  if (*(int*)a < *(int*)b)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
    12896:  145:    return -1;
    35464:  146:  return 0;
        -:  147:}
        -:  148:
        -:  149:
function newGame called 0 returned 0% blocks executed 0%
    #####:  150:struct gameState* newGame() {
    #####:  151:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:  152:  return g;
        -:  153:}
        -:  154:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:  155:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:  156:		  int k8, int k9, int k10) {
    #####:  157:  int* k = malloc(10 * sizeof(int));
    #####:  158:  k[0] = k1;
    #####:  159:  k[1] = k2;
    #####:  160:  k[2] = k3;
    #####:  161:  k[3] = k4;
    #####:  162:  k[4] = k5;
    #####:  163:  k[5] = k6;
    #####:  164:  k[6] = k7;
    #####:  165:  k[7] = k8;
    #####:  166:  k[8] = k9;
    #####:  167:  k[9] = k10;
    #####:  168:  return k;
        -:  169:}
        -:  170:
function initializeGame called 1602 returned 100% blocks executed 94%
     1602:  171:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:  172:		   struct gameState *state) {
        -:  173:
        -:  174:  int i;
        -:  175:  int j;
        -:  176:  int it;			
        -:  177:  //set up random number generator
     1602:  178:  SelectStream(1);
call    0 returned 100%
     1602:  179:  PutSeed((long)randomSeed);
call    0 returned 100%
        -:  180:  
        -:  181:  //check number of players
     1602:  182:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  183:    {
    #####:  184:      return -1;
        -:  185:    }
        -:  186:
        -:  187:  //set number of players
     1602:  188:  state->numPlayers = numPlayers;
        -:  189:
        -:  190:  //check selected kingdom cards are different
    17622:  191:  for (i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:  192:    {
   176220:  193:      for (j = 0; j < 10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:  194:        {
   160200:  195:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  196:	    {
    #####:  197:	      return -1;
        -:  198:	    }
        -:  199:        }
        -:  200:    }
        -:  201:
        -:  202:
        -:  203:  //initialize supply
        -:  204:  ///////////////////////////////
        -:  205:
        -:  206:  //set number of Curse cards
     1602:  207:  if (numPlayers == 2)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:  208:    {
     1592:  209:      state->supplyCount[curse] = 10;
        -:  210:    }
       10:  211:  else if (numPlayers == 3)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  212:    {
    #####:  213:      state->supplyCount[curse] = 20;
        -:  214:    }
        -:  215:  else
        -:  216:    {
       10:  217:      state->supplyCount[curse] = 30;
        -:  218:    }
        -:  219:
        -:  220:  //set number of Victory cards
     1602:  221:  if (numPlayers == 2)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:  222:    {
     1592:  223:      state->supplyCount[estate] = 8;
     1592:  224:      state->supplyCount[duchy] = 8;
     1592:  225:      state->supplyCount[province] = 8;
        -:  226:    }
        -:  227:  else
        -:  228:    {
       10:  229:      state->supplyCount[estate] = 12;
       10:  230:      state->supplyCount[duchy] = 12;
       10:  231:      state->supplyCount[province] = 12;
        -:  232:    }
        -:  233:
        -:  234:  //set number of Treasure cards
     1602:  235:  state->supplyCount[copper] = 60 - (7 * numPlayers);
     1602:  236:  state->supplyCount[silver] = 40;
     1602:  237:  state->supplyCount[gold] = 30;
        -:  238:
        -:  239:  //set number of Kingdom cards
    33642:  240:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  241:    {
   264330:  242:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  243:	{
   248310:  244:	  if (kingdomCards[j] == i)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  245:	    {
        -:  246:	      //check if card is a 'Victory' Kingdom card
    16020:  247:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 11% (fallthrough)
branch  3 taken 89%
        -:  248:		{
     6392:  249:		  if (numPlayers == 2){ 
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
     3176:  250:		    state->supplyCount[i] = 8; 
        -:  251:		  }
       20:  252:		  else{ state->supplyCount[i] = 12; }
        -:  253:		}
        -:  254:	      else
        -:  255:		{
    12824:  256:		  state->supplyCount[i] = 10;
        -:  257:		}
    16020:  258:	      break;
        -:  259:	    }
        -:  260:	  else    //card is not in the set choosen for the game
        -:  261:	    {
   232290:  262:	      state->supplyCount[i] = -1;
        -:  263:	    }
        -:  264:	}
        -:  265:
        -:  266:    }
        -:  267:
        -:  268:  ////////////////////////
        -:  269:  //supply intilization complete
        -:  270:
        -:  271:  //set player decks
     4826:  272:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  273:    {
     3224:  274:      state->deckCount[i] = 0;
    12896:  275:      for (j = 0; j < 3; j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  276:	{
     9672:  277:	  state->deck[i][j] = estate;
     9672:  278:	  state->deckCount[i]++;
        -:  279:	}
    25792:  280:      for (j = 3; j < 10; j++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -:  281:	{
    22568:  282:	  state->deck[i][j] = copper;
    22568:  283:	  state->deckCount[i]++;		
        -:  284:	}
        -:  285:    }
        -:  286:
        -:  287:  //shuffle player decks
     4826:  288:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  289:    {
     3224:  290:      if ( shuffle(i, state) < 0 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  291:	{
    #####:  292:	  return -1;
        -:  293:	}
        -:  294:    }
        -:  295:
        -:  296:  //draw player hands
     4826:  297:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  298:    {  
        -:  299:      //initialize hand size to zero
     3224:  300:      state->handCount[i] = 0;
     3224:  301:      state->discardCount[i] = 0;
        -:  302:      //draw 5 cards
        -:  303:      // for (j = 0; j < 5; j++)
        -:  304:      //	{
        -:  305:      //	  drawCard(i, state);
        -:  306:      //	}
        -:  307:    }
        -:  308:  
        -:  309:  //set embargo tokens to 0 for all supply piles
    44856:  310:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  311:    {
    43254:  312:      state->embargoTokens[i] = 0;
        -:  313:    }
        -:  314:
        -:  315:  //initialize first player's turn
     1602:  316:  state->outpostPlayed = 0;
     1602:  317:  state->phase = 0;
     1602:  318:  state->numActions = 1;
     1602:  319:  state->numBuys = 1;
     1602:  320:  state->playedCardCount = 0;
     1602:  321:  state->whoseTurn = 0;
     1602:  322:  state->handCount[state->whoseTurn] = 0;
        -:  323:  //int it; move to top
        -:  324:
        -:  325:  //Moved draw cards to here, only drawing at the start of a turn
     9612:  326:  for (it = 0; it < 5; it++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
     8010:  327:    drawCard(state->whoseTurn, state);
call    0 returned 100%
        -:  328:  }
        -:  329:
     1602:  330:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 100%
        -:  331:
     1602:  332:  return 0;
        -:  333:}
        -:  334:
function shuffle called 3226 returned 100% blocks executed 100%
     3226:  335:int shuffle(int player, struct gameState *state) {
        -:  336: 
        -:  337:
        -:  338:  int newDeck[MAX_DECK];
     3226:  339:  int newDeckPos = 0;
        -:  340:  int card;
        -:  341:  int i;
        -:  342:
     3226:  343:  if (state->deckCount[player] < 1)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        2:  344:    return -1;
     3224:  345:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 100%
        -:  346:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  347:
    38688:  348:  while (state->deckCount[player] > 0) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
    32240:  349:    card = floor(Random() * state->deckCount[player]);
call    0 returned 100%
    32240:  350:    newDeck[newDeckPos] = state->deck[player][card];
    32240:  351:    newDeckPos++;
   112830:  352:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 71%
branch  1 taken 29% (fallthrough)
    80590:  353:      state->deck[player][i] = state->deck[player][i+1];
        -:  354:    }
    32240:  355:    state->deckCount[player]--;
        -:  356:  }
    35464:  357:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
    32240:  358:    state->deck[player][i] = newDeck[i];
    32240:  359:    state->deckCount[player]++;
        -:  360:  }
        -:  361:
     3224:  362:  return 0;
        -:  363:}
        -:  364:
function playCard called 0 returned 0% blocks executed 0%
    #####:  365:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  366:{	
        -:  367:  int card;
    #####:  368:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  369:
        -:  370:  //check if it is the right phase
    #####:  371:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  372:    {
    #####:  373:      return -1;
        -:  374:    }
        -:  375:	
        -:  376:  //check if player has enough actions
    #####:  377:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  378:    {
    #####:  379:      return -1;
        -:  380:    }
        -:  381:	
        -:  382:  //get card played
    #####:  383:  card = handCard(handPos, state);
call    0 never executed
        -:  384:	
        -:  385:  //check if selected card is an action
    #####:  386:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  387:    {
    #####:  388:      return -1;
        -:  389:    }
        -:  390:	
        -:  391:  //play card
    #####:  392:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  393:    {
    #####:  394:      return -1;
        -:  395:    }
        -:  396:	
        -:  397:  //reduce number of actions
    #####:  398:  state->numActions--;
        -:  399:
        -:  400:  //update coins (Treasure cards may be added with card draws)
    #####:  401:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  402:	
    #####:  403:  return 0;
        -:  404:}
        -:  405:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  406:int buyCard(int supplyPos, struct gameState *state) {
        -:  407:  int who;
        -:  408:  if (DEBUG){
        -:  409:    printf("Entering buyCard...\n");
        -:  410:  }
        -:  411:
        -:  412:  // I don't know what to do about the phase thing.
        -:  413:
    #####:  414:  who = state->whoseTurn;
        -:  415:
    #####:  416:  if (state->numBuys < 1){
branch  0 never executed
branch  1 never executed
        -:  417:    if (DEBUG)
        -:  418:      printf("You do not have any buys left\n");
    #####:  419:    return -1;
    #####:  420:  } else if (supplyCount(supplyPos, state) <1){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  421:    if (DEBUG)
        -:  422:      printf("There are not any of that type of card left\n");
    #####:  423:    return -1;
    #####:  424:  } else if (state->coins < getCost(supplyPos)){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  425:    if (DEBUG) 
        -:  426:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  427:    return -1;
        -:  428:  } else {
    #####:  429:    state->phase=1;
        -:  430:    //state->supplyCount[supplyPos]--;
    #####:  431:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  432:  
    #####:  433:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  434:    state->numBuys--;
        -:  435:    if (DEBUG)
        -:  436:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  437:  }
        -:  438:
        -:  439:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  440:  //state->discardCount[who]++;
        -:  441:    
    #####:  442:  return 0;
        -:  443:}
        -:  444:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  445:int numHandCards(struct gameState *state) {
    #####:  446:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  447:}
        -:  448:
function handCard called 0 returned 0% blocks executed 0%
    #####:  449:int handCard(int handPos, struct gameState *state) {
    #####:  450:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  451:  return state->hand[currentPlayer][handPos];
        -:  452:}
        -:  453:
function supplyCount called 9 returned 100% blocks executed 100%
        9:  454:int supplyCount(int card, struct gameState *state) {
        9:  455:  return state->supplyCount[card];
        -:  456:}
        -:  457:
function fullDeckCount called 1606 returned 100% blocks executed 100%
     1606:  458:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  459:  int i;
     1606:  460:  int count = 0;
        -:  461:
   113934:  462:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  463:    {
   112328:  464:      if (state->deck[player][i] == card) count++;
branch  0 taken 49% (fallthrough)
branch  1 taken 51%
        -:  465:    }
        -:  466:
   113934:  467:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  468:    {
   112328:  469:      if (state->hand[player][i] == card) count++;
branch  0 taken 49% (fallthrough)
branch  1 taken 51%
        -:  470:    }
        -:  471:
   113934:  472:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  473:    {
   112328:  474:      if (state->discard[player][i] == card) count++;
branch  0 taken 49% (fallthrough)
branch  1 taken 51%
        -:  475:    }
        -:  476:
     1606:  477:  return count;
        -:  478:}
        -:  479:
function whoseTurn called 101 returned 100% blocks executed 100%
      101:  480:int whoseTurn(struct gameState *state) {
      101:  481:  return state->whoseTurn;
        -:  482:}
        -:  483:
function endTurn called 40 returned 100% blocks executed 100%
       40:  484:int endTurn(struct gameState *state) {
        -:  485:  int k;
        -:  486:  int i;
       40:  487:  int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  488:  
        -:  489:  //Discard hand
      240:  490:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
      200:  491:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
      200:  492:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  493:  }
       40:  494:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  495:    
        -:  496:  //Code for determining the player
       40:  497:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
       30:  498:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  499:  }
        -:  500:  else{
       10:  501:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  502:  }
        -:  503:
       40:  504:  state->outpostPlayed = 0;
       40:  505:  state->phase = 0;
       40:  506:  state->numActions = 1;
       40:  507:  state->coins = 0;
       40:  508:  state->numBuys = 1;
       40:  509:  state->playedCardCount = 0;
       40:  510:  state->handCount[state->whoseTurn] = 0;
        -:  511:
        -:  512:  //int k; move to top
        -:  513:  //Next player draws hand
      240:  514:  for (k = 0; k < 5; k++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
      200:  515:    drawCard(state->whoseTurn, state);//Draw a card
call    0 returned 100%
        -:  516:  }
        -:  517:
        -:  518:  //Update money
       40:  519:  updateCoins(state->whoseTurn, state , 0);
call    0 returned 100%
        -:  520:
       40:  521:  return 0;
        -:  522:}
        -:  523:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  524:int isGameOver(struct gameState *state) {
        -:  525:  int i;
        -:  526:  int j;
        -:  527:	
        -:  528:  //if stack of Province cards is empty, the game ends
    #####:  529:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  530:    {
    #####:  531:      return 1;
        -:  532:    }
        -:  533:
        -:  534:  //if three supply pile are at 0, the game ends
    #####:  535:  j = 0;
    #####:  536:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  537:    {
    #####:  538:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  539:	{
    #####:  540:	  j++;
        -:  541:	}
        -:  542:    }
    #####:  543:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  544:    {
    #####:  545:      return 1;
        -:  546:    }
        -:  547:
    #####:  548:  return 0;
        -:  549:}
        -:  550:
function scoreFor called 324 returned 100% blocks executed 92%
      324:  551:int scoreFor (int player, struct gameState *state) {
        -:  552:
        -:  553:  int i;
      324:  554:  int score = 0;
        -:  555:  //score from hand
     1404:  556:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 77%
branch  1 taken 23% (fallthrough)
        -:  557:    {
     1080:  558:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
     1080:  559:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
     1080:  560:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
     1080:  561:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
     1080:  562:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
     1080:  563:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
call    2 returned 100%
        -:  564:    }
        -:  565:
        -:  566:  //score from discard
     1044:  567:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 taken 69%
branch  1 taken 31% (fallthrough)
        -:  568:    {
      720:  569:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
      720:  570:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
      720:  571:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
      720:  572:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
      720:  573:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
      720:  574:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
call    2 returned 100%
        -:  575:    }
        -:  576:
        -:  577:  //score from deck
     1044:  578:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 taken 69%
branch  1 taken 31% (fallthrough)
        -:  579:    {
      720:  580:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
      720:  581:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      720:  582:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      720:  583:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      720:  584:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      720:  585:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
call    2 returned 100%
        -:  586:    }
        -:  587:
      324:  588:  return score;
        -:  589:}
        -:  590:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  591:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  592:  int i;	
        -:  593:  int j;
        -:  594:  int highScore;
        -:  595:  int currentPlayer;
        -:  596:
        -:  597:  //get score for each player
    #####:  598:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  599:    {
        -:  600:      //set unused player scores to -9999
    #####:  601:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  602:	{
    #####:  603:	  players[i] = -9999;
        -:  604:	}
        -:  605:      else
        -:  606:	{
    #####:  607:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  608:	}
        -:  609:    }
        -:  610:
        -:  611:  //find highest score
    #####:  612:  j = 0;
    #####:  613:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  614:    {
    #####:  615:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  616:	{
    #####:  617:	  j = i;
        -:  618:	}
        -:  619:    }
    #####:  620:  highScore = players[j];
        -:  621:
        -:  622:  //add 1 to players who had less turns
    #####:  623:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  624:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  625:    {
    #####:  626:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  627:	{
    #####:  628:	  players[i]++;
        -:  629:	}
        -:  630:    }
        -:  631:
        -:  632:  //find new highest score
    #####:  633:  j = 0;
    #####:  634:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  635:    {
    #####:  636:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  637:	{
    #####:  638:	  j = i;
        -:  639:	}
        -:  640:    }
    #####:  641:  highScore = players[j];
        -:  642:
        -:  643:  //set winners in array to 1 and rest to 0
    #####:  644:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  645:    {
    #####:  646:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  647:	{
    #####:  648:	  players[i] = 1;
        -:  649:	}
        -:  650:      else
        -:  651:	{
    #####:  652:	  players[i] = 0;
        -:  653:	}
        -:  654:    }
        -:  655:
    #####:  656:  return 0;
        -:  657:}
        -:  658:
function drawCard called 8225 returned 100% blocks executed 85%
     8225:  659:int drawCard(int player, struct gameState *state)
        -:  660:{	int count;
        -:  661:  int deckCounter;
     8225:  662:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  663:    
        -:  664:    //Step 1 Shuffle the discard pile back into a deck
        -:  665:    int i;
        -:  666:    //Move discard to deck
        2:  667:    for (i = 0; i < state->discardCount[player];i++){
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  668:      state->deck[player][i] = state->discard[player][i];
    #####:  669:      state->discard[player][i] = -1;
        -:  670:    }
        -:  671:
        2:  672:    state->deckCount[player] = state->discardCount[player];
        2:  673:    state->discardCount[player] = 0;//Reset discard
        -:  674:
        -:  675:    //Shufffle the deck
        2:  676:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 100%
        -:  677:   
        -:  678:    if (DEBUG){//Debug statements
        -:  679:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  680:    }
        -:  681:    
        2:  682:    state->discardCount[player] = 0;
        -:  683:
        -:  684:    //Step 2 Draw Card
        2:  685:    count = state->handCount[player];//Get current player's hand count
        -:  686:    
        -:  687:    if (DEBUG){//Debug statements
        -:  688:      printf("Current hand count: %d\n", count);
        -:  689:    }
        -:  690:    
        2:  691:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  692:
        2:  693:    if (deckCounter == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2:  694:      return -1;
        -:  695:
    #####:  696:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  697:    state->deckCount[player]--;
    #####:  698:    state->handCount[player]++;//Increment hand count
        -:  699:  }
        -:  700:
        -:  701:  else{
     8223:  702:    int count = state->handCount[player];//Get current hand count for player
        -:  703:    int deckCounter;
        -:  704:    if (DEBUG){//Debug statements
        -:  705:      printf("Current hand count: %d\n", count);
        -:  706:    }
        -:  707:
     8223:  708:    deckCounter = state->deckCount[player];//Create holder for the deck count
     8223:  709:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     8223:  710:    state->deckCount[player]--;
     8223:  711:    state->handCount[player]++;//Increment hand count
        -:  712:  }
        -:  713:
     8223:  714:  return 0;
        -:  715:}
        -:  716:
function getCost called 27 returned 100% blocks executed 97%
       27:  717:int getCost(int cardNumber)
        -:  718:{
       27:  719:  switch( cardNumber ) 
branch  0 taken 4%
branch  1 taken 4%
branch  2 taken 4%
branch  3 taken 4%
branch  4 taken 4%
branch  5 taken 4%
branch  6 taken 4%
branch  7 taken 4%
branch  8 taken 4%
branch  9 taken 4%
branch 10 taken 4%
branch 11 taken 4%
branch 12 taken 4%
branch 13 taken 4%
branch 14 taken 4%
branch 15 taken 4%
branch 16 taken 4%
branch 17 taken 4%
branch 18 taken 4%
branch 19 taken 4%
branch 20 taken 4%
branch 21 taken 4%
branch 22 taken 4%
branch 23 taken 4%
branch 24 taken 4%
branch 25 taken 4%
branch 26 taken 4%
branch 27 taken 0%
        -:  720:    {
        -:  721:    case curse:
        1:  722:      return 0;
        -:  723:    case estate:
        1:  724:      return 2;
        -:  725:    case duchy:
        1:  726:      return 5;
        -:  727:    case province:
        1:  728:      return 8;
        -:  729:    case copper:
        1:  730:      return 0;
        -:  731:    case silver:
        1:  732:      return 3;
        -:  733:    case gold:
        1:  734:      return 6;
        -:  735:    case adventurer:
        1:  736:      return 6;
        -:  737:    case council_room:
        1:  738:      return 5;
        -:  739:    case feast:
        1:  740:      return 4;
        -:  741:    case gardens:
        1:  742:      return 4;
        -:  743:    case mine:
        1:  744:      return 5;
        -:  745:    case remodel:
        1:  746:      return 4;
        -:  747:    case smithy:
        1:  748:      return 4;
        -:  749:    case village:
        1:  750:      return 3;
        -:  751:    case baron:
        1:  752:      return 4;
        -:  753:    case great_hall:
        1:  754:      return 3;
        -:  755:    case minion:
        1:  756:      return 5;
        -:  757:    case steward:
        1:  758:      return 3;
        -:  759:    case tribute:
        1:  760:      return 5;
        -:  761:    case ambassador:
        1:  762:      return 3;
        -:  763:    case cutpurse:
        1:  764:      return 4;
        -:  765:    case embargo: 
        1:  766:      return 2;
        -:  767:    case outpost:
        1:  768:      return 5;
        -:  769:    case salvager:
        1:  770:      return 4;
        -:  771:    case sea_hag:
        1:  772:      return 4;
        -:  773:    case treasure_map:
        1:  774:      return 4;
        -:  775:    }
        -:  776:	
    #####:  777:  return -1;
        -:  778:}
        -:  779:
function cardEffect called 4 returned 100% blocks executed 10%
        4:  780:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  781:{
        -:  782:  int i;
        -:  783:  int j;
        -:  784:  int k;
        -:  785:  int x;
        -:  786:  int index;
        4:  787:  int currentPlayer = whoseTurn(state);
call    0 returned 100%
        4:  788:  int nextPlayer = currentPlayer + 1;
        -:  789:
        4:  790:  int tributeRevealedCards[2] = {-1, -1};
        -:  791:  int temphand[MAX_HAND];// moved above the if statement
        4:  792:  int drawntreasure=0;
        -:  793:  int cardDrawn;
        4:  794:  int z = 0;// this is the counter for the temp hand
        4:  795:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  796:    nextPlayer = 0;
        -:  797:  }
        -:  798:  
        -:  799:	
        -:  800:  //uses switch to select card and perform actions
        4:  801:  switch( card ) 
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 0%
branch  5 taken 0%
branch  6 taken 50%
branch  7 taken 25%
branch  8 taken 0%
branch  9 taken 25%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 0%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
        -:  802:    {
        -:  803:    case adventurer:
    #####:  804:      playAdventurerCard(state);
call    0 never executed
        -:  805:			
        -:  806:    case council_room:
        -:  807:      //+4 Cards
    #####:  808:      for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  809:	{
    #####:  810:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  811:	}
        -:  812:			
        -:  813:      //+1 Buy
    #####:  814:      state->numBuys++;
        -:  815:			
        -:  816:      //Each other player draws a card
    #####:  817:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  818:	{
    #####:  819:	  if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
        -:  820:	    {
    #####:  821:	      drawCard(i, state);
call    0 never executed
        -:  822:	    }
        -:  823:	}
        -:  824:			
        -:  825:      //put played card in played card pile
    #####:  826:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  827:			
    #####:  828:      return 0;
        -:  829:			
        -:  830:    case feast:
        -:  831:      //gain card with cost up to 5
        -:  832:      //Backup hand
    #####:  833:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  834:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  835:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  836:      }
        -:  837:      //Backup hand
        -:  838:
        -:  839:      //Update Coins for Buy
    #####:  840:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  841:      x = 1;//Condition to loop on
    #####:  842:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  843:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  844:	  if (DEBUG)
        -:  845:	    printf("None of that card left, sorry!\n");
        -:  846:
        -:  847:	  if (DEBUG){
        -:  848:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  849:	  }
        -:  850:	}
    #####:  851:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  852:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  853:
        -:  854:	  if (DEBUG){
        -:  855:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  856:	  }
        -:  857:	}
        -:  858:	else{
        -:  859:
        -:  860:	  if (DEBUG){
        -:  861:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  862:	  }
        -:  863:
    #####:  864:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  865:	  x = 0;//No more buying cards
        -:  866:
        -:  867:	  if (DEBUG){
        -:  868:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  869:	  }
        -:  870:
        -:  871:	}
        -:  872:      }     
        -:  873:
        -:  874:      //Reset Hand
    #####:  875:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  876:	state->hand[currentPlayer][i] = temphand[i];
    #####:  877:	temphand[i] = -1;
        -:  878:      }
        -:  879:      //Reset Hand
        -:  880:      			
    #####:  881:      return 0;
        -:  882:			
        -:  883:    case gardens:
    #####:  884:      return -1;
        -:  885:			
        -:  886:    case mine:
    #####:  887:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  888:
    #####:  889:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  890:	{
    #####:  891:	  return -1;
        -:  892:	}
        -:  893:		
    #####:  894:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  895:	{
    #####:  896:	  return -1;
        -:  897:	}
        -:  898:
    #####:  899:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  900:	{
    #####:  901:	  return -1;
        -:  902:	}
        -:  903:
    #####:  904:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  905:
        -:  906:      //discard card from hand
    #####:  907:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  908:
        -:  909:      //discard trashed card
    #####:  910:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  911:	{
    #####:  912:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  913:	    {
    #####:  914:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  915:	      break;
        -:  916:	    }
        -:  917:	}
        -:  918:			
    #####:  919:      return 0;
        -:  920:			
        -:  921:    case remodel:
    #####:  922:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  923:
    #####:  924:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  925:	{
    #####:  926:	  return -1;
        -:  927:	}
        -:  928:
    #####:  929:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  930:
        -:  931:      //discard card from hand
    #####:  932:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  933:
        -:  934:      //discard trashed card
    #####:  935:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  936:	{
    #####:  937:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  938:	    {
    #####:  939:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  940:	      break;
        -:  941:	    }
        -:  942:	}
        -:  943:
        -:  944:
    #####:  945:      return 0;
        -:  946:		
        -:  947:    case smithy:
        2:  948:      playSmithyCard(handPos, state);
call    0 returned 100%
        -:  949:          
        -:  950:    case village:
        3:  951:      playVillageCard(handPos, state);
call    0 returned 100%
        -:  952:		
        -:  953:    case baron:
        3:  954:      state->numBuys++;//Increase buys by 1!
        3:  955:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  956:	int p = 0;//Iterator for hand!
    #####:  957:	int card_not_discarded = 1;//Flag for discard set!
    #####:  958:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####:  959:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  960:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  961:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  962:	    state->discardCount[currentPlayer]++;
    #####:  963:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####:  964:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  965:	    }
    #####:  966:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  967:	    state->handCount[currentPlayer]--;
    #####:  968:	    card_not_discarded = 0;//Exit the loop
        -:  969:	  }
    #####:  970:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -:  971:	    if(DEBUG) {
        -:  972:	      printf("No estate cards in your hand, invalid choice\n");
        -:  973:	      printf("Must gain an estate if there are any\n");
        -:  974:	    }
    #####:  975:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  976:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  977:	      state->supplyCount[estate]--;//Decrement estates
    #####:  978:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  979:		isGameOver(state);
call    0 never executed
        -:  980:	      }
        -:  981:	    }
    #####:  982:	    card_not_discarded = 0;//Exit the loop
        -:  983:	  }
        -:  984:			    
        -:  985:	  else{
    #####:  986:	    p++;//Next card
        -:  987:	  }
        -:  988:	}
        -:  989:      }
        -:  990:			    
        -:  991:      else{
        3:  992:	if (supplyCount(estate, state) > 0){
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        3:  993:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 returned 100%
        3:  994:	  state->supplyCount[estate]--;//Decrement Estates
        3:  995:	  if (supplyCount(estate, state) == 0){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  996:	    isGameOver(state);
call    0 never executed
        -:  997:	  }
        -:  998:	}
        -:  999:      }
        -: 1000:	    
        -: 1001:      
        3: 1002:      return 0;
        -: 1003:		
        -: 1004:    case great_hall:
        1: 1005:      playGreat_HallCard(handPos, state);
call    0 returned 100%
        -: 1006:		
        -: 1007:    case minion:
        1: 1008:      playMinionCard(handPos, choice1, choice2, state);
call    0 returned 100%
        -: 1009:		
        -: 1010:    case steward:
        1: 1011:      if (choice1 == 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1012:	{
        -: 1013:	  //+2 cards
    #####: 1014:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1015:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1016:	}
        1: 1017:      else if (choice1 == 2)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1018:	{
        -: 1019:	  //+2 coins
    #####: 1020:	  state->coins = state->coins + 2;
        -: 1021:	}
        -: 1022:      else
        -: 1023:	{
        -: 1024:	  //trash 2 cards in hand
        1: 1025:	  discardCard(choice2, currentPlayer, state, 1);
call    0 returned 100%
        1: 1026:	  discardCard(choice3, currentPlayer, state, 1);
call    0 returned 100%
        -: 1027:	}
        -: 1028:			
        -: 1029:      //discard card from hand
        1: 1030:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        1: 1031:      return 0;
        -: 1032:		
        -: 1033:    case tribute:
    #####: 1034:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1035:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1036:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1037:	  state->deckCount[nextPlayer]--;
        -: 1038:	}
    #####: 1039:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1040:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1041:	  state->discardCount[nextPlayer]--;
        -: 1042:	}
        -: 1043:	else{
        -: 1044:	  //No Card to Reveal
        -: 1045:	  if (DEBUG){
        -: 1046:	    printf("No cards to reveal\n");
        -: 1047:	  }
        -: 1048:	}
        -: 1049:      }
        -: 1050:	    
        -: 1051:      else{
    #####: 1052:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1053:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1054:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1055:	    state->deckCount[nextPlayer]++;
    #####: 1056:	    state->discard[nextPlayer][i] = -1;
    #####: 1057:	    state->discardCount[nextPlayer]--;
        -: 1058:	  }
        -: 1059:			    
    #####: 1060:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1061:	} 
    #####: 1062:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1063:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1064:	state->deckCount[nextPlayer]--;
    #####: 1065:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1066:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1067:	state->deckCount[nextPlayer]--;
        -: 1068:      }    
        -: 1069:		       
    #####: 1070:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1071:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1072:	state->playedCardCount++;
    #####: 1073:	tributeRevealedCards[1] = -1;
        -: 1074:      }
        -: 1075:
    #####: 1076:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1077:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1078:	  state->coins += 2;
        -: 1079:	}
        -: 1080:		    
    #####: 1081:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1082:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1083:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1084:	}
        -: 1085:	else{//Action Card
    #####: 1086:	  state->numActions = state->numActions + 2;
        -: 1087:	}
        -: 1088:      }
        -: 1089:	    
    #####: 1090:      return 0;
        -: 1091:		
        -: 1092:    case ambassador:
    #####: 1093:      j = 0;		//used to check if player has enough cards to discard
        -: 1094:
    #####: 1095:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1096:	{
    #####: 1097:	  return -1;				
        -: 1098:	}
        -: 1099:
    #####: 1100:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1101:	{
    #####: 1102:	  return -1;
        -: 1103:	}
        -: 1104:
    #####: 1105:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1106:	{
    #####: 1107:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1108:	    {
    #####: 1109:	      j++;
        -: 1110:	    }
        -: 1111:	}
    #####: 1112:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1113:	{
    #####: 1114:	  return -1;				
        -: 1115:	}
        -: 1116:
        -: 1117:      if (DEBUG) 
        -: 1118:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1119:
        -: 1120:      //increase supply count for choosen card by amount being discarded
    #####: 1121:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1122:			
        -: 1123:      //each other player gains a copy of revealed card
    #####: 1124:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1125:	{
    #####: 1126:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1127:	    {
    #####: 1128:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1129:	    }
        -: 1130:	}
        -: 1131:
        -: 1132:      //discard played card from hand
    #####: 1133:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1134:
        -: 1135:      //trash copies of cards returned to supply
    #####: 1136:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1137:	{
    #####: 1138:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1139:	    {
    #####: 1140:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1141:		{
    #####: 1142:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1143:		  break;
        -: 1144:		}
        -: 1145:	    }
        -: 1146:	}			
        -: 1147:
    #####: 1148:      return 0;
        -: 1149:		
        -: 1150:    case cutpurse:
        -: 1151:
    #####: 1152:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1153:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1154:	{
    #####: 1155:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1156:	    {
    #####: 1157:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1158:		{
    #####: 1159:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1160:		    {
    #####: 1161:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1162:		      break;
        -: 1163:		    }
    #####: 1164:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1165:		    {
    #####: 1166:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1167:			{
        -: 1168:			  if (DEBUG)
        -: 1169:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1170:			}	
    #####: 1171:		      break;
        -: 1172:		    }		
        -: 1173:		}
        -: 1174:					
        -: 1175:	    }
        -: 1176:				
        -: 1177:	}				
        -: 1178:
        -: 1179:      //discard played card from hand
    #####: 1180:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1181:
    #####: 1182:      return 0;
        -: 1183:
        -: 1184:		
        -: 1185:    case embargo: 
        -: 1186:      //+2 Coins
    #####: 1187:      state->coins = state->coins + 2;
        -: 1188:			
        -: 1189:      //see if selected pile is in play
    #####: 1190:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -: 1191:	{
    #####: 1192:	  return -1;
        -: 1193:	}
        -: 1194:			
        -: 1195:      //add embargo token to selected supply pile
    #####: 1196:      state->embargoTokens[choice1]++;
        -: 1197:			
        -: 1198:      //trash card
    #####: 1199:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####: 1200:      return 0;
        -: 1201:		
        -: 1202:    case outpost:
        -: 1203:      //set outpost flag
    #####: 1204:      state->outpostPlayed++;
        -: 1205:			
        -: 1206:      //discard card
    #####: 1207:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1208:      return 0;
        -: 1209:		
        -: 1210:    case salvager:
        -: 1211:      //+1 buy
    #####: 1212:      state->numBuys++;
        -: 1213:			
    #####: 1214:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1215:	{
        -: 1216:	  //gain coins equal to trashed card
    #####: 1217:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1218:	  //trash card
    #####: 1219:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1220:	}
        -: 1221:			
        -: 1222:      //discard card
    #####: 1223:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1224:      return 0;
        -: 1225:		
        -: 1226:    case sea_hag:
    #####: 1227:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1228:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1229:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1230:	  state->discardCount[i]++;
    #####: 1231:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1232:	}
        -: 1233:      }
    #####: 1234:      return 0;
        -: 1235:		
        -: 1236:    case treasure_map:
        -: 1237:      //search hand for another treasure_map
    #####: 1238:      index = -1;
    #####: 1239:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1240:	{
    #####: 1241:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1242:	    {
    #####: 1243:	      index = i;
    #####: 1244:	      break;
        -: 1245:	    }
        -: 1246:	}
    #####: 1247:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1248:	{
        -: 1249:	  //trash both treasure cards
    #####: 1250:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1251:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1252:
        -: 1253:	  //gain 4 Gold cards
    #####: 1254:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1255:	    {
    #####: 1256:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1257:	    }
        -: 1258:				
        -: 1259:	  //return success
    #####: 1260:	  return 1;
        -: 1261:	}
        -: 1262:			
        -: 1263:      //no second treasure_map found in hand
    #####: 1264:      return -1;
        -: 1265:    }
        -: 1266:	
    #####: 1267:  return -1;
        -: 1268:}
        -: 1269:
function discardCard called 10 returned 100% blocks executed 78%
       10: 1270:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1271:{
        -: 1272:	
        -: 1273:  //if card is not trashed, added to Played pile 
       10: 1274:  if (trashFlag < 1)
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -: 1275:    {
        -: 1276:      //add card to played pile
        8: 1277:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
        8: 1278:      state->playedCardCount++;
        -: 1279:    }
        -: 1280:	
        -: 1281:  //set played card to -1
       10: 1282:  state->hand[currentPlayer][handPos] = -1;
        -: 1283:	
        -: 1284:  //remove card from player's hand
       10: 1285:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1286:    {
        -: 1287:      //reduce number of cards in hand
    #####: 1288:      state->handCount[currentPlayer]--;
        -: 1289:    }
       10: 1290:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1291:    {
        -: 1292:      //reduce number of cards in hand
    #####: 1293:      state->handCount[currentPlayer]--;
        -: 1294:    }
        -: 1295:  else 	
        -: 1296:    {
        -: 1297:      //replace discarded card with last card in hand
       10: 1298:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1299:      //set last card to -1
       10: 1300:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1301:      //reduce number of cards in hand
       10: 1302:      state->handCount[currentPlayer]--;
        -: 1303:    }
        -: 1304:	
       10: 1305:  return 0;
        -: 1306:}
        -: 1307:
function gainCard called 3 returned 100% blocks executed 70%
        3: 1308:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1309:{
        -: 1310:  //Note: supplyPos is enum of choosen card
        -: 1311:	
        -: 1312:  //check if supply pile is empty (0) or card is not used in game (-1)
        3: 1313:  if ( supplyCount(supplyPos, state) < 1 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1314:    {
    #####: 1315:      return -1;
        -: 1316:    }
        -: 1317:	
        -: 1318:  //added card for [whoseTurn] current player:
        -: 1319:  // toFlag = 0 : add to discard
        -: 1320:  // toFlag = 1 : add to deck
        -: 1321:  // toFlag = 2 : add to hand
        -: 1322:
        3: 1323:  if (toFlag == 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1324:    {
    #####: 1325:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1326:      state->deckCount[player]++;
        -: 1327:    }
        3: 1328:  else if (toFlag == 2)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1329:    {
    #####: 1330:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1331:      state->handCount[player]++;
        -: 1332:    }
        -: 1333:  else
        -: 1334:    {
        3: 1335:      state->discard[player][ state->discardCount[player] ] = supplyPos;
        3: 1336:      state->discardCount[player]++;
        -: 1337:    }
        -: 1338:	
        -: 1339:  //decrease number in supply pile
        3: 1340:  state->supplyCount[supplyPos]--;
        -: 1341:	 
        3: 1342:  return 0;
        -: 1343:}
        -: 1344:
function updateCoins called 1642 returned 100% blocks executed 82%
     1642: 1345:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1346:{
        -: 1347:  int i;
        -: 1348:	
        -: 1349:  //reset coin count
     1642: 1350:  state->coins = 0;
        -: 1351:
        -: 1352:  //add coins for each Treasure card in player's hand
     9852: 1353:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -: 1354:    {
     8210: 1355:      if (state->hand[player][i] == copper)
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -: 1356:	{
     6538: 1357:	  state->coins += 1;
        -: 1358:	}
     1672: 1359:      else if (state->hand[player][i] == silver)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1360:	{
    #####: 1361:	  state->coins += 2;
        -: 1362:	}
     1672: 1363:      else if (state->hand[player][i] == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1364:	{
    #####: 1365:	  state->coins += 3;
        -: 1366:	}	
        -: 1367:    }	
        -: 1368:
        -: 1369:  //add bonus
     1642: 1370:  state->coins += bonus;
        -: 1371:
     1642: 1372:  return 0;
        -: 1373:}
        -: 1374:
        -: 1375:
        -: 1376://end of dominion.c
        -: 1377:
