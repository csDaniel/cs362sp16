%****************************testWhoseTurn() TEST****************************%


whoseTurn() Function test
Test WhoseTurn() #1 - once the game is initialized, first player goes 1st.
WhoseTurn(): function works as expected after game is initialized. 
WhoseTurn(): 0 
WhoseTurn(): function works as expected after game is initialized. 
WhoseTurn(): 0 
Test WhoseTurn() # 2- check that function works as expected during the game. 
WhoseTurn(): function works as expected for a specific player. 
WhoseTurn(): 5 
File 'unittest1.c'
Lines executed:83.33% of 24
Creating 'unittest1.c.gcov'

File 'unittest1.c'
Lines executed:83.33% of 24
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
Calls executed:70.59% of 17
Creating 'unittest1.c.gcov'

        -:    0:Source:unittest1.c
        -:    0:Graph:unittest1.gcno
        -:    0:Data:unittest1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <assert.h>
        -:    4:#include <time.h>
        -:    5:#include "dominion.h"
        -:    6://makefile was taken from https://github.com/aburasali/cs362sp16/blob/master/projects/batese/dominion/Makefile
        -:    7:
        -:    8:
function testWhoseTurn called 1 returned 100% blocks executed 77%
        1:    9:void testWhoseTurn() {
        1:   10:    printf("\n\nwhoseTurn() Function test\n");
call    0 returned 100%
        -:   11:    //initialize game
        1:   12:    struct gameState* g = malloc(sizeof(struct gameState));
        -:   13:    //assign cards
        1:   14:    int k[10] = {smithy, adventurer, feast, council_room, embargo, village, minion, mine, cutpurse, sea_hag, tribute};
        -:   15:    int player;
        1:   16:    printf("Test WhoseTurn() #1 - once the game is initialized, first player goes 1st.\n");
call    0 returned 100%
        3:   17:    for (player = 0; player < 2; player++){
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:   18:        //initialize game for each player
        2:   19:        initializeGame(player, k, 100, g);
call    0 returned 100%
        -:   20:        //check to make sure that whoseTurn function work as expected
        -:   21:        //no matter with how many players the game is initializes, the first
        -:   22:        //players should go first
        2:   23:        if (whoseTurn(g) == g->whoseTurn){
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        2:   24:            printf("WhoseTurn(): function works as expected after game is initialized. \n");
call    0 returned 100%
        2:   25:            printf("WhoseTurn(): %d \n", g->whoseTurn );
call    0 returned 100%
        -:   26:        }
        -:   27:        else{
    #####:   28:            printf("ERROR: There is an error in WhoseTurn():function  \n" );
call    0 never executed
    #####:   29:            printf("WhoseTurn(): %d \n", g->whoseTurn );
call    0 never executed
        -:   30:        }
        -:   31:    }
        1:   32:    printf("Test WhoseTurn() # 2- check that function works as expected during the game. \n");
call    0 returned 100%
        -:   33:    //assign turn to player 5 and make sure that it works as expectec
        1:   34:    int r = 5;
        -:   35:    //assign whoseturn to r
        1:   36:    g->whoseTurn = r;
        1:   37:    if (whoseTurn(g) == r){
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        1:   38:        printf("WhoseTurn(): function works as expected for a specific player. \n");
call    0 returned 100%
        1:   39:        printf("WhoseTurn(): %d \n", whoseTurn(g));
call    0 returned 100%
call    1 returned 100%
        -:   40:    }
        -:   41:    else{
    #####:   42:        printf("ERROR: There is an error in WhoseTurn():function  \n" );
call    0 never executed
    #####:   43:        printf("WhoseTurn(): %d \n", whoseTurn(g) );
call    0 never executed
call    1 never executed
        -:   44:    }
        -:   45:
        -:   46:
        1:   47:}
        -:   48:
function main called 1 returned 0% blocks executed 100%
        1:   49:int main () {
        1:   50:    testWhoseTurn();
call    0 returned 100%
        1:   51:    exit(0);
        -:   52:}
%****************************testNumHandCards()****************************%


NumHandCards() Function test
numHandCards(g) for the first player should yield 5 if works correctly: 5 
numHandCards(g) for the second player should yield 8 if works correctly: 8 
File 'unittest2.c'
Lines executed:100.00% of 18
Creating 'unittest2.c.gcov'

File 'unittest2.c'
Lines executed:100.00% of 18
Branches executed:100.00% of 4
Taken at least once:50.00% of 4
Calls executed:77.78% of 9
Creating 'unittest2.c.gcov'

        -:    0:Source:unittest2.c
        -:    0:Graph:unittest2.gcno
        -:    0:Data:unittest2.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <assert.h>
        -:    4:#include <time.h>
        -:    5:#include "dominion.h"
        -:    6://makefile was taken from https://github.com/aburasali/cs362sp16/blob/master/projects/batese/dominion/Makefile
        -:    7:/*
        -:    8:
        -:    9:int numHandCards(struct gameState *state) {
        -:   10:  return state->handCount[ whoseTurn(state) ];
        -:   11:}
        -:   12:
        -:   13:*/
function testNumHandCards called 1 returned 100% blocks executed 82%
        1:   14:void testNumHandCards() {
        1:   15:    printf("\n\nNumHandCards() Function test\n");
call    0 returned 100%
        -:   16:    //srand(time(NULL));
        -:   17:    //int r = rand();
        1:   18:    struct gameState* g = malloc(sizeof(struct gameState));
        1:   19:    int k[10] = {smithy, adventurer, feast, council_room, embargo, village, minion, mine, cutpurse, sea_hag, tribute};
        1:   20:    initializeGame(2, k, 100, g);
call    0 returned 100%
        -:   21:    //assign some value to the handCount for each player
        1:   22:    int player1 = 5;
        -:   23:    //at the begining of the game- its the fist players turn
        1:   24:    g->handCount[0] = player1;
        1:   25:    assert(numHandCards(g) == player1);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        1:   26:    printf("numHandCards(g) for the first player should yield 5 if works correctly: %d \n", g->handCount[0] );
call    0 returned 100%
        -:   27:    //now we need to reassign the turn
        1:   28:    g->whoseTurn = 1;
        1:   29:    int player2 = 8;
        1:   30:    g->handCount[1] = player2;
        -:   31:    //check to make sure that the handCount works for the second player as well.
        1:   32:    assert(numHandCards(g) == player2);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        1:   33:    printf("numHandCards(g) for the second player should yield 8 if works correctly: %d \n", g->handCount[1] );
call    0 returned 100%
        1:   34:}
        -:   35:
function main called 1 returned 0% blocks executed 100%
        1:   36:int main () {
        1:   37:    testNumHandCards();
call    0 returned 100%
        1:   38:    exit(0);
        -:   39:}
        -:   40:
%****************************isGameOver(struct gameState *state)****************************%


testing isGameOver
The game is still running because there is at least 1 province left.
Game has ended because all provinces are gone
Game has ended because 3 supply piles are consumed 
File 'unittest3.c'
Lines executed:80.00% of 25
Creating 'unittest3.c.gcov'

File 'unittest3.c'
Lines executed:80.00% of 25
Branches executed:66.67% of 12
Taken at least once:33.33% of 12
Calls executed:66.67% of 15
Creating 'unittest3.c.gcov'

        -:    0:Source:unittest3.c
        -:    0:Graph:unittest3.gcno
        -:    0:Data:unittest3.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <assert.h>
        -:    4:#include <time.h>
        -:    5:#include "dominion.h"
        -:    6://makefile was taken from https://github.com/aburasali/cs362sp16/blob/master/projects/batese/dominion/Makefile
        -:    7:
        -:    8:/*
        -:    9:
        -:   10:int isGameOver(struct gameState *state) {
        -:   11:  int i;
        -:   12:  int j;
        -:   13:
        -:   14:  //if stack of Province cards is empty, the game ends
        -:   15:  if (state->supplyCount[province] == 0)
        -:   16:    {
        -:   17:      return 1;
        -:   18:    }
        -:   19:
        -:   20:  //if three supply pile are at 0, the game ends
        -:   21:  j = 0;
        -:   22:  for (i = 0; i < 25; i++)
        -:   23:    {
        -:   24:      if (state->supplyCount[i] == 0)
        -:   25:	{
        -:   26:	  j++;
        -:   27:	}
        -:   28:    }
        -:   29:  if ( j >= 3)
        -:   30:    {
        -:   31:      return 1;
        -:   32:    }
        -:   33:
        -:   34:  return 0;
        -:   35:}
        -:   36:*/
        -:   37:
        -:   38:
function testisGameOver called 1 returned 100% blocks executed 67%
        1:   39:void testisGameOver() {
        1:   40:	printf("\n\ntesting isGameOver\n");
call    0 returned 100%
        1:   41:	struct gameState *g = malloc(sizeof(struct gameState));
        1:   42:	int k[10] = {smithy, adventurer, feast, council_room, embargo, village, minion, mine, cutpurse, sea_hag, tribute};
        1:   43:	initializeGame(2, k, 100, g);
call    0 returned 100%
        -:   44:	//when the game is initialized, none of the conditions that are required for the game to be over is complete, so
        -:   45:	//the game should be running.
        1:   46:	if( isGameOver(g) == 1 ){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   47:		printf("ERROR: there is at least 1 province left, so the game should not have ended\n");
call    0 never executed
        1:   48:	} else if ( isGameOver(g) == 0 ){
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        1:   49:		printf("The game is still running because there is at least 1 province left.\n");
call    0 returned 100%
        -:   50:	}
        -:   51:    //now lets check to make sure that the game will be over when the conditions for the end of the game is met
        -:   52:    //when province count =0, game ends
        1:   53:	g->supplyCount[province] = 0 ;
        1:   54:	if( isGameOver(g) == 1 ){
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        1:   55:		printf("Game has ended because all provinces are gone\n");
call    0 returned 100%
    #####:   56:	} else if ( isGameOver(g) == 0 ){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   57:		printf("ERROR: game has not ended eventhough all provinces are gone.\n");
call    0 never executed
        -:   58:	}
        -:   59:    //game also ends when 3 supply piles are consumed
        -:   60:    //3 supply counters will be assigned to 0
        1:   61:      g->supplyCount[1] = 0;
        1:   62:      g->supplyCount[2] = 0;
        1:   63:      g->supplyCount[3] = 0;
        1:   64:	if( isGameOver(g) == 1 ){
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        1:   65:		printf("Game has ended because 3 supply piles are consumed \n");
call    0 returned 100%
        -:   66:	}
    #####:   67:	else if (isGameOver(g) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   68:		printf("ERROR: Game has NOT ended even though 3 supply piles are consumed\n");
call    0 never executed
        -:   69:	}
        -:   70:
        1:   71:}
        -:   72:
function main called 1 returned 0% blocks executed 100%
        1:   73:int main () {
        1:   74:    testisGameOver();
call    0 returned 100%
        1:   75:    exit(0);
        -:   76:}
        -:   77:
        -:   78:
        -:   79:
%****************************testCompare()****************************%


compare() Function test
Smaller value was detected correctly
Smaller value was detected correctly
Both values are the same and this was correctly detected
File 'unittest4.c'
Lines executed:84.21% of 19
Creating 'unittest4.c.gcov'

File 'unittest4.c'
Lines executed:84.21% of 19
Branches executed:100.00% of 6
Taken at least once:50.00% of 6
Calls executed:72.73% of 11
Creating 'unittest4.c.gcov'

        -:    0:Source:unittest4.c
        -:    0:Graph:unittest4.gcno
        -:    0:Data:unittest4.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <assert.h>
        -:    4:#include <time.h>
        -:    5:#include "dominion.h"
        -:    6://makefile was taken from https://github.com/aburasali/cs362sp16/blob/master/projects/batese/dominion/Makefile
        -:    7:
        -:    8:
        -:    9:/*
        -:   10:int compare(const void* a, const void* b) {
        -:   11:  if (*(int*)a > *(int*)b)
        -:   12:    return 1;
        -:   13:  if (*(int*)a < *(int*)b)
        -:   14:    return -1;
        -:   15:  return 0;
        -:   16:}
        -:   17:
        -:   18:*/
        -:   19:
        -:   20:
function testCompare called 1 returned 100% blocks executed 81%
        1:   21:void testCompare() {
        1:   22:    printf("\n\ncompare() Function test\n");
call    0 returned 100%
        1:   23:	int smaller = 5;
        1:   24:	int larger = 8;
        1:   25:	int* smaller2 = &smaller;
        1:   26:	int* larger2 = &larger;
        1:   27:	if(compare(smaller2, larger2) == -1){
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        1:   28:		printf("Smaller value was detected correctly\n");
call    0 returned 100%
        -:   29:	} else {
    #####:   30:		printf("Smaller values was not detected correctly\n");
call    0 never executed
        -:   31:	}
        1:   32:	if(compare(larger2, smaller2) == 1){
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        1:   33:		printf("Smaller value was detected correctly\n");
call    0 returned 100%
        -:   34:	} else {
    #####:   35:		printf("Smaller values was not detected correctly\n");
call    0 never executed
        -:   36:	}
        1:   37:	if(compare(smaller2, smaller2) == 0){
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        1:   38:		printf("Both values are the same and this was correctly detected\n");
call    0 returned 100%
        -:   39:	} else {
    #####:   40:		printf("Both values are the same and the function did not produce correct results\n");
call    0 never executed
        -:   41:	}
        1:   42:	return 0;
        -:   43:}
        -:   44:
        -:   45:
function main called 1 returned 0% blocks executed 100%
        1:   46:int main () {
        1:   47:    testCompare();
call    0 returned 100%
        1:   48:    exit(0);
        -:   49:}
%****************************SMITHY CARD TEST****************************%


 Unit Test for SMITHY
Hand Count before Smithy Card is Played: 5 

Hand Count after Smithy Card is Played: 

ERROR: Hand Count Should be: 7. Instead Hand Count is: 6 

unit Test: Smithy test successful 
File 'cardtest1.c'
Lines executed:92.86% of 14
Creating 'cardtest1.c.gcov'

File 'cardtest1.c'
Lines executed:92.86% of 14
Branches executed:100.00% of 2
Taken at least once:50.00% of 2
Calls executed:87.50% of 8
Creating 'cardtest1.c.gcov'

        -:    0:Source:cardtest1.c
        -:    0:Graph:cardtest1.gcno
        -:    0:Data:cardtest1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <assert.h>
        -:    4:#include "dominion.h"
        -:    5://makefile was taken from https://github.com/aburasali/cs362sp16/blob/master/projects/batese/dominion/Makefile
        -:    6:/*
        -:    7:int card_Smithy(struct gameState *state, int handPos)
        -:    8:{
        -:    9:  int i;
        -:   10:  int currentPlayer = whoseTurn(state);
        -:   11:  // + 3 cards
        -:   12:  for (i = 1; i < 3; i++)
        -:   13:  {
        -:   14:    drawCard(currentPlayer, state);
        -:   15:  }
        -:   16:
        -:   17:  //discard card from hand
        -:   18:  discardCard(handPos, currentPlayer, state, 0);
        -:   19:  return 0;
        -:   20:}
        -:   21:
        -:   22:*/
        -:   23:
function main called 1 returned 100% blocks executed 91%
        1:   24:int main(){
        1:   25:    struct gameState* g = malloc(sizeof(struct gameState));
        -:   26:	int expectedHandCountAfterSmithy;
        1:   27:	int k[10] = {smithy, adventurer, feast, council_room, embargo, village, minion, mine, cutpurse, sea_hag, tribute};
        1:   28:	printf("\n\n Unit Test for SMITHY\n");
call    0 returned 100%
        -:   29:    //initializing a game: 2 players, cards- see above, seed =100, and game
        1:   30:	initializeGame(2, k, 100, g);
call    0 returned 100%
        -:   31:/*
        -:   32:    Smithy is a terminal card, meaning it provides no +Action. This card lets the user to draw 3 additional cards.
        -:   33:    The implementation of the card is a simple for loop that calles the drawCard(currentPlayer, state) method 3 times.
        -:   34:    After 3 cards are drawn, the discardCard(handPos, currentPlayer, state, 0) method is called to discard the smithy
        -:   35:    card to the discarded pile.
        -:   36:    */
        -:   37:	//if 3 cards are drawn and then smithy card is discarded, we will expect that the handCount will be handCount + 2
        1:   38:	expectedHandCountAfterSmithy = g->handCount[0] + 2;
        1:   39:	printf("Hand Count before Smithy Card is Played: %d \n", g->handCount[0]);
call    0 returned 100%
        -:   40:    //( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:   41:    //play smithy card
        1:   42:	cardEffect(smithy, 0, 0, 0, g, 0, 0);
call    0 returned 100%
        1:   43:	printf("\nHand Count after Smithy Card is Played: \n\n");
call    0 returned 100%
        1:   44:	if(g->handCount[0] != expectedHandCountAfterSmithy){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   45:		printf("ERROR: Hand Count Should be: %d. Instead Hand Count is: %d \n", expectedHandCountAfterSmithy, g->handCount[0]);
call    0 returned 100%
        -:   46:	}
        -:   47:	else{
    #####:   48:		printf("No Errors were detected in the Smithy card.\n", g->handCount[0]);
call    0 never executed
        -:   49:	}
        1:   50:	printf("\nunit Test: Smithy test successful \n");
call    0 returned 100%
        1:   51:return 0;
        -:   52:}
        -:   53:
%****************************ADVENTURE CARD TEST****************************%


 Unit Test for ADVENTURE
Hand Count before Adventure Card is Played: 5 

Hand Count after Adventure Card is Played: 

No Errors were detected in the Adventure card. Hand Count is: 7

unit Test: Adventure test successful 
File 'cardtest2.c'
Lines executed:92.86% of 14
Creating 'cardtest2.c.gcov'

File 'cardtest2.c'
Lines executed:92.86% of 14
Branches executed:100.00% of 2
Taken at least once:50.00% of 2
Calls executed:87.50% of 8
Creating 'cardtest2.c.gcov'

        -:    0:Source:cardtest2.c
        -:    0:Graph:cardtest2.gcno
        -:    0:Data:cardtest2.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "assert.h"
        -:    2:#include "dominion.h"
        -:    3:#include <stdio.h>
        -:    4:#include "rngs.h"
        -:    5:#include <stdlib.h>
        -:    6://makefile was taken from https://github.com/aburasali/cs362sp16/blob/master/projects/batese/dominion/Makefile
        -:    7:
        -:    8://testing adventure card
        -:    9:/*
        -:   10:int card_Adventurer(struct gameState *state)
        -:   11:{
        -:   12:  //current player
        -:   13:  int currentPlayer = whoseTurn(state);
        -:   14:  //this should just remove the top card (the most recently drawn one).
        -:   15:  //this variable is needed in case a funciton that was drawn is not the treasure function
        -:   16:  int temphand[MAX_HAND];
        -:   17:  //count the treasures that were drawn
        -:   18:  int drawntreasure = 0;
        -:   19:  //counts the cards that were drawn
        -:   20:  int cardDrawn = 0;
        -:   21:  //used for the indexing of the temphand array
        -:   22:  int z = 0;
        -:   23:
        -:   24:
        -:   25:   while(drawntreasure<2){
        -:   26:	if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
        -:   27:	  shuffle(currentPlayer, state);
        -:   28:	}
        -:   29:	drawCard(currentPlayer, state);
        -:   30:	cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
        -:   31:	if (cardDrawn == copper || cardDrawn == silver || cardDrawn != gold)
        -:   32:	  drawntreasure++;
        -:   33:	else{
        -:   34:	  temphand[z]=cardDrawn;
        -:   35:	  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
        -:   36:	  z++;
        -:   37:	}
        -:   38:      }
        -:   39:      while(z-1>=0){
        -:   40:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
        -:   41:	z=z-1;
        -:   42:      }
        -:   43:     return 0;
        -:   44:}
        -:   45:
        -:   46:
        -:   47:*/
        -:   48:
        -:   49:
function main called 1 returned 100% blocks executed 91%
        1:   50:int main(){
        1:   51:    struct gameState* g = malloc(sizeof(struct gameState));
        -:   52:	int expectedHandCountAfterAdventure;
        1:   53:	int k[10] = {smithy, adventurer, feast, council_room, embargo, village, minion, mine, cutpurse, sea_hag, tribute};
        1:   54:	printf("\n\n Unit Test for ADVENTURE\n");
call    0 returned 100%
        -:   55:    //initializing a game: 2 players, cards- see above, seed =100, and game
        1:   56:	initializeGame(2, k, 100, g);
call    0 returned 100%
        -:   57:/*
        -:   58:    Adventure is an action card with the terminal action that digs for treasure cards in the deck. The palayer
        -:   59:    draws cards from their deck until they get 2 treasure cards. The treasure cards are added to the deck of the
        -:   60:    player and the rest of the cards that were revealed are placed in the discard pile. In case the deck is empty
        -:   61:    before the player find 2 treasure cards, the discarded cards are shuffled and placed on the deck.
        -:   62:    */
        -:   63:	//Based on the description above, after the adventure card is played, the handcount should go up +2
        1:   64:	expectedHandCountAfterAdventure = g->handCount[0] + 2;
        1:   65:	printf("Hand Count before Adventure Card is Played: %d \n", g->handCount[0]);
call    0 returned 100%
        -:   66:    //( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:   67:    //play smithy card
        1:   68:	cardEffect(adventurer, 0, 0, 0, g, 0, 0);
call    0 returned 100%
        1:   69:	printf("\nHand Count after Adventure Card is Played: \n\n");
call    0 returned 100%
        1:   70:	if(g->handCount[0] != expectedHandCountAfterAdventure){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   71:		printf("ERROR: Hand Count Should be: %d. Instead Hand Count is: %d \n", expectedHandCountAfterAdventure, g->handCount[0]);
call    0 never executed
        -:   72:	}
        -:   73:	else{
        1:   74:		printf("No Errors were detected in the Adventure card. Hand Count is: %d\n", g->handCount[0]);
call    0 returned 100%
        -:   75:	}
        1:   76:	printf("\nunit Test: Adventure test successful \n");
call    0 returned 100%
        1:   77:return 0;
        -:   78:}
%****************************COUNCIL_ROOM CARD TEST****************************%


 Unit Test for council_room
Hand Count of the CURRENT player before council_room Card is Played: 5 
Hand Count of the OTHER player before council_room Card is Played: 0 

Hand Count Of the CURRENT Player after council_room Card is Played: 

ERROR: Hand Count Should be: 9. Instead Hand Count is: 8 

Hand Count Of the OTHER Player after council_room Card is Played: 

No Errors were detected in the Council_room card. Hand Count is: 1

unit Test: Council_room test successful 
File 'cardtest3.c'
Lines executed:90.00% of 20
Creating 'cardtest3.c.gcov'

File 'cardtest3.c'
Lines executed:90.00% of 20
Branches executed:100.00% of 4
Taken at least once:50.00% of 4
Calls executed:83.33% of 12
Creating 'cardtest3.c.gcov'

        -:    0:Source:cardtest3.c
        -:    0:Graph:cardtest3.gcno
        -:    0:Data:cardtest3.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "assert.h"
        -:    2:#include "dominion.h"
        -:    3:#include <stdio.h>
        -:    4:#include "rngs.h"
        -:    5:#include <stdlib.h>
        -:    6://makefile was taken from https://github.com/aburasali/cs362sp16/blob/master/projects/batese/dominion/Makefile
        -:    7:
        -:    8:
        -:    9://testing council_room card
        -:   10:/*
        -:   11:int card_Council_Room(struct gameState *state, int handPos){
        -:   12:  int i;
        -:   13:  int currentPlayer = whoseTurn(state);
        -:   14:      for (i = 0; i < 4; i++)
        -:   15:	{
        -:   16:	  drawCard(currentPlayer, state);
        -:   17:	}
        -:   18:
        -:   19:      //+1 Buy
        -:   20:      //state->numBuys++;
        -:   21:
        -:   22:      //Each other player draws a card
        -:   23:      for (i = 0; i < state->numPlayers; i++)
        -:   24:	{
        -:   25:	  if ( i != currentPlayer )
        -:   26:	    {
        -:   27:	      drawCard(i, state);
        -:   28:	      //drawCard(i, state);
        -:   29:	    }
        -:   30:	}
        -:   31:
        -:   32:      //put played card in played card pile
        -:   33:      discardCard(handPos, currentPlayer, state, 0);
        -:   34:      return 0;
        -:   35:  }
        -:   36:
        -:   37:
        -:   38:*/
        -:   39:
        -:   40:
        -:   41:
function main called 1 returned 100% blocks executed 88%
        1:   42:int main(){
        1:   43:    struct gameState* g = malloc(sizeof(struct gameState));
        -:   44:	int expectedHandCountAfterCouncil_room, expectedHandCountAfterCouncil_room2;
        1:   45:	int k[10] = {smithy, adventurer, feast, council_room, embargo, village, minion, mine, cutpurse, sea_hag, tribute};
        1:   46:	printf("\n\n Unit Test for council_room\n");
call    0 returned 100%
        -:   47:    //initializing a game: 2 players, cards- see above, seed =100, and game
        1:   48:	initializeGame(2, k, 100, g);
call    0 returned 100%
        -:   49:	//Based on the original Council_room function [ the one wihout bug], after the Council_room card is played,
        -:   50:	//the handcount of the current player should go up + 4
        -:   51:	//and the count of all other players should be handout +1
        -:   52:	//current player
        1:   53:	expectedHandCountAfterCouncil_room = g->handCount[0] + 4;
        -:   54:	//all other players
        1:   55:	expectedHandCountAfterCouncil_room2 = g->handCount[1] + 1;
        -:   56:	//testing the current player
        1:   57:	printf("Hand Count of the CURRENT player before council_room Card is Played: %d \n", g->handCount[0]);
call    0 returned 100%
        1:   58:	printf("Hand Count of the OTHER player before council_room Card is Played: %d \n", g->handCount[1]);
call    0 returned 100%
        -:   59:    //( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:   60:    //play smithy card
        1:   61:	cardEffect(council_room, 0, 0, 0, g, 0, 0);
call    0 returned 100%
        1:   62:	printf("\nHand Count Of the CURRENT Player after council_room Card is Played: \n\n");
call    0 returned 100%
        1:   63:	if(g->handCount[0] != expectedHandCountAfterCouncil_room){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   64:		printf("ERROR: Hand Count Should be: %d. Instead Hand Count is: %d \n", expectedHandCountAfterCouncil_room, g->handCount[0]);
call    0 returned 100%
        -:   65:	}
        -:   66:	else{
    #####:   67:		printf("No Errors were detected in the Council_room card. Hand Count is: %d\n", g->handCount[0]);
call    0 never executed
        -:   68:	}
        -:   69:
        1:   70:    printf("\nHand Count Of the OTHER Player after council_room Card is Played: \n\n");
call    0 returned 100%
        1:   71:	if(g->handCount[1] != expectedHandCountAfterCouncil_room2){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   72:		printf("ERROR: Hand Count Should be: %d. Instead Hand Count is: %d \n", expectedHandCountAfterCouncil_room2, g->handCount[1]);
call    0 never executed
        -:   73:	}
        -:   74:	else{
        1:   75:		printf("No Errors were detected in the Council_room card. Hand Count is: %d\n", g->handCount[1]);
call    0 returned 100%
        -:   76:	}
        1:   77:	printf("\nunit Test: Council_room test successful \n");
call    0 returned 100%
        1:   78:return 0;
        -:   79:}
        -:   80:
%****************************VILLAGE CARD TEST****************************%


 Unit Test for Village
Hand Count before Village Card is Played: 5 
Num Action before Village Card is Played: 1 

Hand Count Of the Player after village Card is Played: 

No Errors were detected in the Village card. Hand Count is: 5

Num Action Of the Player after village Card is Played: 

ERROR: Num Action Should be: 3. Instead Hand Count is: 4 

unit Test: Council_room test successful 
File 'cardtest4.c'
Lines executed:90.00% of 20
Creating 'cardtest4.c.gcov'

File 'cardtest4.c'
Lines executed:90.00% of 20
Branches executed:100.00% of 4
Taken at least once:50.00% of 4
Calls executed:83.33% of 12
Creating 'cardtest4.c.gcov'

        -:    0:Source:cardtest4.c
        -:    0:Graph:cardtest4.gcno
        -:    0:Data:cardtest4.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "assert.h"
        -:    2:#include "dominion.h"
        -:    3:#include <stdio.h>
        -:    4:#include "rngs.h"
        -:    5:#include <stdlib.h>
        -:    6://makefile was taken from https://github.com/aburasali/cs362sp16/blob/master/projects/batese/dominion/Makefile
        -:    7:
        -:    8:
        -:    9://testing village card
        -:   10:/*
        -:   11:int card_Village(struct gameState *state, int handPos){
        -:   12:      int currentPlayer = whoseTurn(state);
        -:   13:      //+1 Card
        -:   14:      drawCard(currentPlayer, state);
        -:   15:
        -:   16:      //+2 Actions
        -:   17:      state->numActions = state->numActions + 3;
        -:   18:
        -:   19:      //discard played card from hand
        -:   20:      discardCard(handPos, currentPlayer, state, 0);
        -:   21:      return 0;
        -:   22:
        -:   23:
        -:   24:}
        -:   25:
        -:   26:*/
        -:   27:
        -:   28:
        -:   29:
function main called 1 returned 100% blocks executed 88%
        1:   30:int main(){
        1:   31:    struct gameState* g = malloc(sizeof(struct gameState));
        -:   32:	int expectedHandCountAfterVillage, expectednumActionsAfterVillage;
        1:   33:	int k[10] = {smithy, adventurer, feast, council_room, embargo, village, minion, mine, cutpurse, sea_hag, tribute};
        1:   34:	printf("\n\n Unit Test for Village\n");
call    0 returned 100%
        -:   35:    //initializing a game: 2 players, cards- see above, seed =100, and game
        1:   36:	initializeGame(2, k, 100, g);
call    0 returned 100%
        -:   37:    //for the village card, the user draws 1 card, so the hand count should go +1
        1:   38:	expectedHandCountAfterVillage = g->handCount[0];
        -:   39:	//expected number of action will be +2
        1:   40:	expectednumActionsAfterVillage =  g->numActions +2;
        -:   41:	//testing the current player
        1:   42:	printf("Hand Count before Village Card is Played: %d \n", g->handCount[0]);
call    0 returned 100%
        1:   43:	printf("Num Action before Village Card is Played: %d \n", g->numActions);
call    0 returned 100%
        -:   44:
        -:   45:    //( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:   46:    //play smithy card
        1:   47:	cardEffect(village, 0, 0, 0, g, 0, 0);
call    0 returned 100%
        1:   48:	printf("\nHand Count Of the Player after village Card is Played: \n\n");
call    0 returned 100%
        1:   49:	if(g->handCount[0] != expectedHandCountAfterVillage){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   50:		printf("ERROR: Hand Count Should be: %d. Instead Hand Count is: %d \n", expectedHandCountAfterVillage, g->handCount[0]);
call    0 never executed
        -:   51:	}
        -:   52:	else{
        1:   53:		printf("No Errors were detected in the Village card. Hand Count is: %d\n", g->handCount[0]);
call    0 returned 100%
        -:   54:	}
        -:   55:
        1:   56:	printf("\nNum Action Of the Player after village Card is Played: \n\n");
call    0 returned 100%
        1:   57:	if(g->numActions != expectednumActionsAfterVillage){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   58:		printf("ERROR: Num Action Should be: %d. Instead Hand Count is: %d \n", expectednumActionsAfterVillage, g->numActions);
call    0 returned 100%
        -:   59:	}
        -:   60:	else{
    #####:   61:		printf("No Errors were detected in the Village card. Num Action is: %d\n", g->numActions);
call    0 never executed
        -:   62:	}
        -:   63:
        -:   64:
        1:   65:	printf("\nunit Test: Council_room test successful \n");
call    0 returned 100%
        1:   66:return 0;
        -:   67:}
        -:   68:
dominion.c:
%****************************DOMINION CODE COVERAGE****************************%
File 'dominion.c'
Lines executed:28.42% of 570
Creating 'dominion.c.gcov'

File 'dominion.c'
Lines executed:28.42% of 570
Branches executed:28.06% of 417
Taken at least once:19.18% of 417
Calls executed:25.00% of 100
Creating 'dominion.c.gcov'

